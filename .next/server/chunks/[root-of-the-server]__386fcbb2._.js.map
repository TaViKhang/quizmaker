{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/auth-middleware.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth/next\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { Role } from \"@prisma/client\";\r\n\r\n/**\r\n * Middleware to check if user is authenticated\r\n * @returns User session or throws 401 error\r\n */\r\nexport async function requireAuth() {\r\n  const session = await getServerSession(authOptions);\r\n  \r\n  if (!session?.user) {\r\n    throw new Response(\"Unauthorized\", { status: 401 });\r\n  }\r\n  \r\n  return session;\r\n}\r\n\r\n/**\r\n * Middleware to check if user is a teacher\r\n * @returns User session or throws 403 error\r\n */\r\nexport async function requireTeacherRole() {\r\n  const session = await requireAuth();\r\n  \r\n  if (session.user.role !== Role.TEACHER) {\r\n    throw new Response(\"Forbidden: Teachers only\", { status: 403 });\r\n  }\r\n  \r\n  return session;\r\n}\r\n\r\n/**\r\n * Middleware to check if teacher has access to a specific class\r\n * @param classId - The ID of the class to check access for\r\n * @returns The class object if access is granted or throws 403 error\r\n */\r\nexport async function requireTeacherClassAccess(classId: string) {\r\n  const session = await requireTeacherRole();\r\n  \r\n  const classData = await prisma.class.findUnique({\r\n    where: {\r\n      id: classId,\r\n    },\r\n  });\r\n  \r\n  if (!classData) {\r\n    throw new Response(\"Class not found\", { status: 404 });\r\n  }\r\n  \r\n  if (classData.teacherId !== session.user.id) {\r\n    throw new Response(\"Forbidden: You don't have access to this class\", { status: 403 });\r\n  }\r\n  \r\n  return { session, classData };\r\n}\r\n\r\n/**\r\n * Middleware to check if teacher has access to a specific student\r\n * @param studentId - The ID of the student to check access for\r\n * @returns Object containing session, student and classes if access is granted or throws 403 error\r\n */\r\nexport async function requireTeacherStudentAccess(studentId: string) {\r\n  const session = await requireTeacherRole();\r\n  \r\n  // Find classes taught by this teacher that have this student enrolled\r\n  const studentEnrollments = await prisma.classEnrollment.findMany({\r\n    where: {\r\n      studentId: studentId,\r\n      class: {\r\n        teacherId: session.user.id,\r\n      },\r\n    },\r\n    include: {\r\n      class: true,\r\n    },\r\n  });\r\n  \r\n  if (studentEnrollments.length === 0) {\r\n    throw new Response(\"Forbidden: You don't have access to this student\", { status: 403 });\r\n  }\r\n  \r\n  const student = await prisma.user.findUnique({\r\n    where: {\r\n      id: studentId,\r\n    },\r\n    select: {\r\n      id: true,\r\n      name: true,\r\n      email: true,\r\n      image: true,\r\n    },\r\n  });\r\n  \r\n  if (!student) {\r\n    throw new Response(\"Student not found\", { status: 404 });\r\n  }\r\n  \r\n  const classes = studentEnrollments.map(enrollment => enrollment.class);\r\n  \r\n  return { session, student, classes };\r\n}\r\n\r\n/**\r\n * Middleware to check if teacher has access to a specific quiz\r\n * @param quizId - The ID of the quiz to check access for\r\n * @returns The quiz object if access is granted or throws 403 error\r\n */\r\nexport async function requireTeacherQuizAccess(quizId: string) {\r\n  const session = await requireTeacherRole();\r\n  \r\n  const quiz = await prisma.quiz.findUnique({\r\n    where: {\r\n      id: quizId,\r\n    },\r\n  });\r\n  \r\n  if (!quiz) {\r\n    throw new Response(\"Quiz not found\", { status: 404 });\r\n  }\r\n  \r\n  if (quiz.authorId !== session.user.id) {\r\n    throw new Response(\"Forbidden: You don't have access to this quiz\", { status: 403 });\r\n  }\r\n  \r\n  return { session, quiz };\r\n}\r\n\r\n/**\r\n * Middleware to check if teacher has access to a specific quiz attempt\r\n * @param attemptId - The ID of the quiz attempt to check access for\r\n * @returns The attempt object if access is granted or throws 403 error\r\n */\r\nexport async function requireTeacherAttemptAccess(attemptId: string) {\r\n  const session = await requireTeacherRole();\r\n  \r\n  const attempt = await prisma.quizAttempt.findUnique({\r\n    where: {\r\n      id: attemptId,\r\n    },\r\n    include: {\r\n      quiz: true,\r\n    },\r\n  });\r\n  \r\n  if (!attempt) {\r\n    throw new Response(\"Attempt not found\", { status: 404 });\r\n  }\r\n  \r\n  if (attempt.quiz.authorId !== session.user.id) {\r\n    throw new Response(\"Forbidden: You don't have access to this attempt\", { status: 403 });\r\n  }\r\n  \r\n  return { session, attempt };\r\n}\r\n\r\n/**\r\n * Error handling wrapper for API route handlers\r\n * @param handler - The route handler function\r\n * @returns A function that handles errors from the route handler\r\n */\r\nexport function withErrorHandling(handler: Function) {\r\n  return async (req: NextRequest, params?: any) => {\r\n    try {\r\n      return await handler(req, params);\r\n    } catch (error) {\r\n      console.error(\"API Error:\", error);\r\n      \r\n      if (error instanceof Response) {\r\n        return NextResponse.json(\r\n          { error: error.statusText },\r\n          { status: error.status }\r\n        );\r\n      }\r\n      \r\n      return NextResponse.json(\r\n        { error: \"Internal server error\" },\r\n        { status: 500 }\r\n      );\r\n    }\r\n  };\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 537, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/teacher/students/route.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { withErrorHandling, requireTeacherRole } from \"@/lib/auth-middleware\";\r\n\r\n/**\r\n * GET handler for retrieving all students enrolled in teacher's classes\r\n */\r\nexport const GET = withErrorHandling(async (req: NextRequest) => {\r\n  const session = await requireTeacherRole();\r\n  const teacherId = session.user.id;\r\n  \r\n  // Get URL parameters for pagination, sorting, etc.\r\n  const { searchParams } = new URL(req.url);\r\n  const classId = searchParams.get(\"classId\");\r\n  const search = searchParams.get(\"search\");\r\n  const page = parseInt(searchParams.get(\"page\") || \"1\");\r\n  const limit = parseInt(searchParams.get(\"limit\") || \"20\");\r\n  const offset = (page - 1) * limit;\r\n  \r\n  // Base query filters\r\n  const whereClause: any = {\r\n    class: {\r\n      teacherId,\r\n    },\r\n  };\r\n  \r\n  // Add optional class filter\r\n  if (classId) {\r\n    whereClause.classId = classId;\r\n  }\r\n  \r\n  // Get unique student IDs from enrollments in teacher's classes\r\n  const enrollments = await prisma.classEnrollment.findMany({\r\n    where: whereClause,\r\n    select: {\r\n      studentId: true,\r\n      student: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n          email: true,\r\n          image: true,\r\n        },\r\n      },\r\n      class: {\r\n        select: {\r\n          id: true,\r\n          name: true,\r\n        },\r\n      },\r\n      joinedAt: true,\r\n    },\r\n    orderBy: {\r\n      joinedAt: 'desc',\r\n    },\r\n  });\r\n  \r\n  // Group by student ID to get unique students with all their classes\r\n  const studentMap = new Map();\r\n  \r\n  for (const enrollment of enrollments) {\r\n    if (!studentMap.has(enrollment.studentId)) {\r\n      studentMap.set(enrollment.studentId, {\r\n        id: enrollment.student.id,\r\n        name: enrollment.student.name,\r\n        email: enrollment.student.email,\r\n        image: enrollment.student.image,\r\n        classes: [],\r\n      });\r\n    }\r\n    \r\n    studentMap.get(enrollment.studentId).classes.push({\r\n      id: enrollment.class.id,\r\n      name: enrollment.class.name,\r\n      joinedAt: enrollment.joinedAt,\r\n    });\r\n  }\r\n  \r\n  // Convert map to array and apply search filter if needed\r\n  let students = Array.from(studentMap.values());\r\n  \r\n  if (search) {\r\n    const searchLower = search.toLowerCase();\r\n    students = students.filter(student => \r\n      student.name?.toLowerCase().includes(searchLower) || \r\n      student.email?.toLowerCase().includes(searchLower)\r\n    );\r\n  }\r\n  \r\n  // Apply pagination\r\n  const totalCount = students.length;\r\n  const paginatedStudents = students.slice(offset, offset + limit);\r\n  \r\n  // Get activity data for these students (quiz attempts)\r\n  const studentIds = paginatedStudents.map(student => student.id);\r\n  \r\n  const quizAttempts = await prisma.quizAttempt.findMany({\r\n    where: {\r\n      userId: {\r\n        in: studentIds,\r\n      },\r\n      quiz: {\r\n        authorId: teacherId,\r\n      },\r\n    },\r\n    select: {\r\n      userId: true,\r\n      score: true,\r\n      completedAt: true,\r\n      quiz: {\r\n        select: {\r\n          id: true,\r\n          title: true,\r\n          classId: true,\r\n        },\r\n      },\r\n    },\r\n    orderBy: {\r\n      createdAt: 'desc',\r\n    },\r\n  });\r\n  \r\n  // Group quiz attempts by student\r\n  const attemptsMap = new Map();\r\n  \r\n  for (const attempt of quizAttempts) {\r\n    if (!attemptsMap.has(attempt.userId)) {\r\n      attemptsMap.set(attempt.userId, []);\r\n    }\r\n    \r\n    attemptsMap.get(attempt.userId).push({\r\n      quizId: attempt.quiz.id,\r\n      quizTitle: attempt.quiz.title,\r\n      classId: attempt.quiz.classId,\r\n      score: attempt.score,\r\n      completedAt: attempt.completedAt,\r\n    });\r\n  }\r\n  \r\n  // Add activity data to student records\r\n  for (const student of paginatedStudents) {\r\n    student.recentActivity = attemptsMap.get(student.id) || [];\r\n    \r\n    // Calculate average score\r\n    if (student.recentActivity.length > 0) {\r\n      const completedAttempts = student.recentActivity.filter((a: any) => a.score !== null);\r\n      if (completedAttempts.length > 0) {\r\n        const totalScore = completedAttempts.reduce((sum: number, a: any) => sum + a.score, 0);\r\n        student.averageScore = Math.round(totalScore / completedAttempts.length);\r\n      } else {\r\n        student.averageScore = null;\r\n      }\r\n    } else {\r\n      student.averageScore = null;\r\n    }\r\n  }\r\n  \r\n  return Response.json({\r\n    students: paginatedStudents,\r\n    pagination: {\r\n      total: totalCount,\r\n      page,\r\n      limit,\r\n      pages: Math.ceil(totalCount / limit),\r\n    },\r\n  });\r\n}); "],"names":[],"mappings":";;;AACA;AACA;;;AAKO,MAAM,MAAM,CAAA,GAAA,2HAAA,CAAA,oBAAiB,AAAD,EAAE,OAAO;IAC1C,MAAM,UAAU,MAAM,CAAA,GAAA,2HAAA,CAAA,qBAAkB,AAAD;IACvC,MAAM,YAAY,QAAQ,IAAI,CAAC,EAAE;IAEjC,mDAAmD;IACnD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;IACxC,MAAM,UAAU,aAAa,GAAG,CAAC;IACjC,MAAM,SAAS,aAAa,GAAG,CAAC;IAChC,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;IAClD,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;IACpD,MAAM,SAAS,CAAC,OAAO,CAAC,IAAI;IAE5B,qBAAqB;IACrB,MAAM,cAAmB;QACvB,OAAO;YACL;QACF;IACF;IAEA,4BAA4B;IAC5B,IAAI,SAAS;QACX,YAAY,OAAO,GAAG;IACxB;IAEA,+DAA+D;IAC/D,MAAM,cAAc,MAAM,+GAAA,CAAA,SAAM,CAAC,eAAe,CAAC,QAAQ,CAAC;QACxD,OAAO;QACP,QAAQ;YACN,WAAW;YACX,SAAS;gBACP,QAAQ;oBACN,IAAI;oBACJ,MAAM;oBACN,OAAO;oBACP,OAAO;gBACT;YACF;YACA,OAAO;gBACL,QAAQ;oBACN,IAAI;oBACJ,MAAM;gBACR;YACF;YACA,UAAU;QACZ;QACA,SAAS;YACP,UAAU;QACZ;IACF;IAEA,oEAAoE;IACpE,MAAM,aAAa,IAAI;IAEvB,KAAK,MAAM,cAAc,YAAa;QACpC,IAAI,CAAC,WAAW,GAAG,CAAC,WAAW,SAAS,GAAG;YACzC,WAAW,GAAG,CAAC,WAAW,SAAS,EAAE;gBACnC,IAAI,WAAW,OAAO,CAAC,EAAE;gBACzB,MAAM,WAAW,OAAO,CAAC,IAAI;gBAC7B,OAAO,WAAW,OAAO,CAAC,KAAK;gBAC/B,OAAO,WAAW,OAAO,CAAC,KAAK;gBAC/B,SAAS,EAAE;YACb;QACF;QAEA,WAAW,GAAG,CAAC,WAAW,SAAS,EAAE,OAAO,CAAC,IAAI,CAAC;YAChD,IAAI,WAAW,KAAK,CAAC,EAAE;YACvB,MAAM,WAAW,KAAK,CAAC,IAAI;YAC3B,UAAU,WAAW,QAAQ;QAC/B;IACF;IAEA,yDAAyD;IACzD,IAAI,WAAW,MAAM,IAAI,CAAC,WAAW,MAAM;IAE3C,IAAI,QAAQ;QACV,MAAM,cAAc,OAAO,WAAW;QACtC,WAAW,SAAS,MAAM,CAAC,CAAA,UACzB,QAAQ,IAAI,EAAE,cAAc,SAAS,gBACrC,QAAQ,KAAK,EAAE,cAAc,SAAS;IAE1C;IAEA,mBAAmB;IACnB,MAAM,aAAa,SAAS,MAAM;IAClC,MAAM,oBAAoB,SAAS,KAAK,CAAC,QAAQ,SAAS;IAE1D,uDAAuD;IACvD,MAAM,aAAa,kBAAkB,GAAG,CAAC,CAAA,UAAW,QAAQ,EAAE;IAE9D,MAAM,eAAe,MAAM,+GAAA,CAAA,SAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;QACrD,OAAO;YACL,QAAQ;gBACN,IAAI;YACN;YACA,MAAM;gBACJ,UAAU;YACZ;QACF;QACA,QAAQ;YACN,QAAQ;YACR,OAAO;YACP,aAAa;YACb,MAAM;gBACJ,QAAQ;oBACN,IAAI;oBACJ,OAAO;oBACP,SAAS;gBACX;YACF;QACF;QACA,SAAS;YACP,WAAW;QACb;IACF;IAEA,iCAAiC;IACjC,MAAM,cAAc,IAAI;IAExB,KAAK,MAAM,WAAW,aAAc;QAClC,IAAI,CAAC,YAAY,GAAG,CAAC,QAAQ,MAAM,GAAG;YACpC,YAAY,GAAG,CAAC,QAAQ,MAAM,EAAE,EAAE;QACpC;QAEA,YAAY,GAAG,CAAC,QAAQ,MAAM,EAAE,IAAI,CAAC;YACnC,QAAQ,QAAQ,IAAI,CAAC,EAAE;YACvB,WAAW,QAAQ,IAAI,CAAC,KAAK;YAC7B,SAAS,QAAQ,IAAI,CAAC,OAAO;YAC7B,OAAO,QAAQ,KAAK;YACpB,aAAa,QAAQ,WAAW;QAClC;IACF;IAEA,uCAAuC;IACvC,KAAK,MAAM,WAAW,kBAAmB;QACvC,QAAQ,cAAc,GAAG,YAAY,GAAG,CAAC,QAAQ,EAAE,KAAK,EAAE;QAE1D,0BAA0B;QAC1B,IAAI,QAAQ,cAAc,CAAC,MAAM,GAAG,GAAG;YACrC,MAAM,oBAAoB,QAAQ,cAAc,CAAC,MAAM,CAAC,CAAC,IAAW,EAAE,KAAK,KAAK;YAChF,IAAI,kBAAkB,MAAM,GAAG,GAAG;gBAChC,MAAM,aAAa,kBAAkB,MAAM,CAAC,CAAC,KAAa,IAAW,MAAM,EAAE,KAAK,EAAE;gBACpF,QAAQ,YAAY,GAAG,KAAK,KAAK,CAAC,aAAa,kBAAkB,MAAM;YACzE,OAAO;gBACL,QAAQ,YAAY,GAAG;YACzB;QACF,OAAO;YACL,QAAQ,YAAY,GAAG;QACzB;IACF;IAEA,OAAO,SAAS,IAAI,CAAC;QACnB,UAAU;QACV,YAAY;YACV,OAAO;YACP;YACA;YACA,OAAO,KAAK,IAAI,CAAC,aAAa;QAChC;IACF;AACF","debugId":null}}]
}
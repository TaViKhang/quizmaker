{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const db = globalThis.prisma || new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\r\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\r\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\r\nimport { db } from \"@/lib/db\"\r\nimport GoogleProvider from \"next-auth/providers/google\"\r\nimport { ROLES, RoleType } from \"@/lib/constants\"\r\n\r\n// Domain email được ủy quyền cao hơn\r\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\r\n\r\n// Fix cho type adapter\r\nconst prismaAdapter = PrismaAdapter(db) as any\r\n\r\n// Cải thiện error handling\r\nconst handleAuthError = (error: any, context: string) => {\r\n  console.error(`[Auth Error] ${context}:`, error);\r\n  return false;\r\n}\r\n\r\nexport const authOptions: AuthOptions = {\r\n  adapter: prismaAdapter,\r\n  providers: [\r\n    GoogleProvider({\r\n      clientId: process.env.GOOGLE_CLIENT_ID!,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\r\n      allowDangerousEmailAccountLinking: true,\r\n    }),\r\n  ],\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 24 * 60 * 60, // 24 hours\r\n    updateAge: 4 * 60 * 60, // 4 hours\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user, account, profile, trigger }) {\r\n      try {\r\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\r\n        if (user) {\r\n          // Đảm bảo role có thể null\r\n          token.role = user.role as RoleType | null;\r\n          token.id = user.id;\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\r\n        if (trigger === 'update' && token?.sub) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { \r\n                id: true, \r\n                name: true, \r\n                email: true, \r\n                role: true, \r\n                image: true \r\n              }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              // Cập nhật token với giá trị mới\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.name = dbUser.name;\r\n              token.email = dbUser.email;\r\n              token.picture = dbUser.image;\r\n              \r\n              // Thêm timestamp để đảm bảo không cache token cũ\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error updating token:\", error);\r\n          }\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\r\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { role: true }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error refreshing token:\", error);\r\n          }\r\n        }\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        console.error(\"JWT callback error:\", error);\r\n        return token;\r\n      }\r\n    },\r\n    async session({ session, token }) {\r\n      try {\r\n        if (session.user && token) {\r\n          // Đảm bảo role có thể null\r\n          session.user.role = token.role as RoleType | null;\r\n          session.user.id = token.id as string;\r\n        }\r\n        return session;\r\n      } catch (error) {\r\n        console.error(\"Session callback error:\", error);\r\n        return session;\r\n      }\r\n    },\r\n    async signIn({ user, account, profile }) {\r\n      // Nếu user có email\r\n      if (user?.email) {\r\n        try {\r\n          // Kiểm tra user đã tồn tại chưa\r\n          const existingUser = await db.user.findUnique({\r\n            where: { email: user.email },\r\n          })\r\n          \r\n          if (!existingUser) {\r\n            // Tạo user mới không có role (null) để người dùng chọn sau\r\n            await db.user.create({\r\n              data: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                image: user.image,\r\n                role: null, // Không thiết lập role mặc định\r\n              },\r\n            })\r\n            \r\n            // Đánh dấu để redirect tới trang chọn role\r\n            return true\r\n          }\r\n          \r\n          return true\r\n        } catch (error) {\r\n          return handleAuthError(error, \"signIn callback\");\r\n        }\r\n      }\r\n      \r\n      return true\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/auth/signin',\r\n    signOut: '/',\r\n    error: '/auth/error',\r\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n  debug: process.env.NODE_ENV === \"development\",\r\n  logger: {\r\n    error(code, ...message) {\r\n      console.error(`[NextAuth Error] ${code}:`, ...message);\r\n    },\r\n    warn(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\r\n      }\r\n    },\r\n    debug(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\r\n      }\r\n    },\r\n  },\r\n}\r\n\r\nconst handler = NextAuth(authOptions)\r\nexport { handler as GET, handler as POST }\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/auth.ts"],"sourcesContent":["import { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { Role } from \"@prisma/client\";\r\nimport { cache } from \"react\";\r\n\r\n// Re-export authOptions from here to fix import issue\r\nexport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\n\r\n// Cache getSession để không truy vấn nhiều lần trong cùng một request\r\nexport const getSession = cache(async () => {\r\n  return await getServerSession(authOptions);\r\n});\r\n\r\n// Cache getCurrentUser để tối ưu hiệu suất\r\nexport const getCurrentUser = cache(async () => {\r\n  const session = await getSession();\r\n  return session?.user;\r\n});\r\n\r\nexport async function isAuthenticated() {\r\n  const session = await getSession();\r\n  return !!session?.user;\r\n}\r\n\r\nexport async function hasRole(role: Role) {\r\n  const user = await getCurrentUser();\r\n  return user?.role === role;\r\n}\r\n\r\nexport async function isTeacher() {\r\n  const user = await getCurrentUser();\r\n  return user?.role === Role.TEACHER;\r\n}\r\n\r\nexport async function isStudent() {\r\n  const user = await getCurrentUser();\r\n  return user?.role === Role.STUDENT;\r\n} "],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;;AAMO,MAAM,aAAa,CAAA,GAAA,uMAAA,CAAA,QAAK,AAAD,EAAE;IAC9B,OAAO,MAAM,CAAA,GAAA,uIAAA,CAAA,mBAAgB,AAAD,EAAE,mJAAA,CAAA,cAAW;AAC3C;AAGO,MAAM,iBAAiB,CAAA,GAAA,uMAAA,CAAA,QAAK,AAAD,EAAE;IAClC,MAAM,UAAU,MAAM;IACtB,OAAO,SAAS;AAClB;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,CAAC,CAAC,SAAS;AACpB;AAEO,eAAe,QAAQ,IAAU;IACtC,MAAM,OAAO,MAAM;IACnB,OAAO,MAAM,SAAS;AACxB;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,OAAO,MAAM,SAAS,6HAAA,CAAA,OAAI,CAAC,OAAO;AACpC;AAEO,eAAe;IACpB,MAAM,OAAO,MAAM;IACnB,OAAO,MAAM,SAAS,6HAAA,CAAA,OAAI,CAAC,OAAO;AACpC","debugId":null}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/users/me/quiz-completion-analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/lib/auth\";\r\nimport { db } from \"@/lib/db\";\r\nimport { Role, Prisma } from \"@prisma/client\";\r\nimport { ApiError } from \"@/app/api/utils/api-response\";\r\nimport { \r\n  startOfToday, \r\n  subDays, \r\n  subMonths, \r\n  endOfDay,\r\n  startOfMonth,\r\n  endOfMonth,\r\n  format,\r\n  parseISO\r\n} from \"date-fns\";\r\n\r\n// Helper functions for API responses\r\nfunction createApiResponse({ status = 200, data = {}, message = \"\" }) {\r\n  return NextResponse.json(\r\n    {\r\n      success: true,\r\n      data,\r\n      message,\r\n    },\r\n    { status }\r\n  );\r\n}\r\n\r\nfunction createApiErrorResponse({ status = 400, message = \"\" }) {\r\n  return NextResponse.json(\r\n    {\r\n      success: false,\r\n      message,\r\n    },\r\n    { status }\r\n  );\r\n}\r\n\r\n/**\r\n * API endpoint to get student quiz completion analytics.\r\n * This endpoint returns detailed metrics about student's quiz completion rates and statistics.\r\n * \r\n * @route GET /api/users/me/quiz-completion-analytics\r\n * @query timeFrame - Optional parameter to filter data by time range\r\n *                    Options: \"last7days\", \"last30days\", \"last90days\", \"allTime\"\r\n *                    Default: \"last30days\"\r\n * @returns {Object} Analytics data including key metrics, quiz breakdown, completion trends, and category analysis\r\n */\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    const session = await getServerSession(authOptions);\r\n    \r\n    if (!session?.user) {\r\n      return createApiErrorResponse({\r\n        status: 401,\r\n        message: \"Unauthorized\",\r\n      });\r\n    }\r\n    \r\n    const userId = session.user.id;\r\n    const searchParams = req.nextUrl.searchParams;\r\n    const timeFrame = searchParams.get(\"timeFrame\") || \"last30days\";\r\n    \r\n    // Calculate date range based on time frame\r\n    const now = new Date();\r\n    let startDate: Date;\r\n    \r\n    switch (timeFrame) {\r\n      case \"last7days\":\r\n        startDate = new Date(now);\r\n        startDate.setDate(now.getDate() - 7);\r\n        break;\r\n      case \"last30days\":\r\n        startDate = new Date(now);\r\n        startDate.setDate(now.getDate() - 30);\r\n        break;\r\n      case \"last90days\":\r\n        startDate = new Date(now);\r\n        startDate.setDate(now.getDate() - 90);\r\n        break;\r\n      case \"last6months\":\r\n        startDate = new Date(now);\r\n        startDate.setMonth(now.getMonth() - 6);\r\n        break;\r\n      case \"lastYear\":\r\n        startDate = new Date(now);\r\n        startDate.setFullYear(now.getFullYear() - 1);\r\n        break;\r\n      case \"allTime\":\r\n        startDate = new Date(0); // January 1, 1970\r\n        break;\r\n      default:\r\n        startDate = new Date(now);\r\n        startDate.setDate(now.getDate() - 30);\r\n    }\r\n    \r\n    // Get user's enrolled classes first\r\n    const enrolledClasses = await db.classEnrollment.findMany({\r\n      where: {\r\n        studentId: userId,\r\n        class: {\r\n          isActive: true\r\n        }\r\n      },\r\n      select: {\r\n        classId: true\r\n      }\r\n    });\r\n    \r\n    const enrolledClassIds = enrolledClasses.map(ec => ec.classId);\r\n    \r\n    // Get total assigned quizzes (only from enrolled classes)\r\n    // Count all published quizzes in enrolled classes, regardless of time range\r\n    // This ensures logical consistency: completed ≤ total always\r\n    let totalQuizzes = 0;\r\n    if (enrolledClassIds.length > 0) {\r\n      totalQuizzes = await db.quiz.count({\r\n        where: {\r\n          classId: {\r\n            in: enrolledClassIds\r\n          },\r\n          isPublished: true,\r\n          isActive: true,\r\n        },\r\n      });\r\n    }\r\n    \r\n    // Get completed quizzes (only from enrolled classes)\r\n    const completedQuizAttempts = enrolledClassIds.length > 0 \r\n      ? await db.quizAttempt.findMany({\r\n          where: {\r\n            userId,\r\n            completedAt: {\r\n              not: null,\r\n              gte: startDate,\r\n              lte: now\r\n            },\r\n            quiz: {\r\n              classId: {\r\n                in: enrolledClassIds\r\n              },\r\n              isPublished: true\r\n            }\r\n          },\r\n          select: {\r\n            quizId: true,\r\n            score: true, // Include score for average calculation\r\n          }\r\n        })\r\n      : [];\r\n\r\n    // Count distinct quizIds\r\n    const uniqueQuizIds = new Set(completedQuizAttempts.map(attempt => attempt.quizId));\r\n    const completedQuizzes = uniqueQuizIds.size;\r\n\r\n    // Calculate average score using best attempt per quiz (not all attempts)\r\n    const quizBestScores = new Map<string, number>();\r\n\r\n    completedQuizAttempts.forEach(attempt => {\r\n      if (attempt.score !== null) {\r\n        const currentBest = quizBestScores.get(attempt.quizId) || 0;\r\n        if (attempt.score > currentBest) {\r\n          quizBestScores.set(attempt.quizId, attempt.score);\r\n        }\r\n      }\r\n    });\r\n\r\n    const bestScores = Array.from(quizBestScores.values());\r\n    const averageScore = bestScores.length > 0\r\n      ? parseFloat((bestScores.reduce((sum, score) => sum + score, 0) / bestScores.length).toFixed(1))\r\n      : 0;\r\n      \r\n    // Calculate average attempts per quiz\r\n    const quizAttemptsCount = new Map();\r\n    completedQuizAttempts.forEach(attempt => {\r\n      const count = quizAttemptsCount.get(attempt.quizId) || 0;\r\n      quizAttemptsCount.set(attempt.quizId, count + 1);\r\n    });\r\n    \r\n    const totalAttempts = Array.from(quizAttemptsCount.values()).reduce((sum, count) => sum + count, 0);\r\n    const averageAttempts = quizAttemptsCount.size > 0 \r\n      ? parseFloat((totalAttempts / quizAttemptsCount.size).toFixed(1))\r\n      : 0;\r\n    \r\n    // Calculate completion rate\r\n    const completionRate = totalQuizzes > 0 \r\n      ? Math.round((completedQuizzes / totalQuizzes) * 100) \r\n      : 0;\r\n    \r\n    // Get quizzes by subject with completion stats (only from enrolled classes)\r\n    // Count all published quizzes by category, regardless of time range for consistency\r\n    const quizzesBySubject = enrolledClassIds.length > 0\r\n      ? await db.quiz.groupBy({\r\n          by: [\"category\"],\r\n          where: {\r\n            classId: {\r\n              in: enrolledClassIds\r\n            },\r\n            isPublished: true,\r\n            isActive: true,\r\n            category: {\r\n              not: null,\r\n            },\r\n          },\r\n          _count: {\r\n            id: true,\r\n          },\r\n        })\r\n      : [];\r\n    \r\n    // Get completed quizzes by subject (only from enrolled classes)\r\n    const completedBySubject = enrolledClassIds.length > 0\r\n      ? await db.quizAttempt.groupBy({\r\n          by: [\"quizId\"],\r\n          where: {\r\n            userId,\r\n            completedAt: {\r\n              not: null,\r\n              gte: startDate,\r\n              lte: now,\r\n            },\r\n            quiz: {\r\n              classId: {\r\n                in: enrolledClassIds\r\n              },\r\n              category: {\r\n                not: null,\r\n              },\r\n            },\r\n          },\r\n          _count: {\r\n            id: true,\r\n          },\r\n        })\r\n      : [];\r\n    \r\n    // Map quiz IDs to subjects\r\n    const quizSubjectMap = await db.quiz.findMany({\r\n      where: {\r\n        id: {\r\n          in: completedBySubject.map(q => q.quizId),\r\n        },\r\n      },\r\n      select: {\r\n        id: true,\r\n        category: true,\r\n      },\r\n    });\r\n    \r\n    // Create a map of subject to completions\r\n    const subjectCompletions = new Map();\r\n    \r\n    quizSubjectMap.forEach(quiz => {\r\n      const subject = quiz.category || \"Uncategorized\";\r\n      if (!subjectCompletions.has(subject)) {\r\n        subjectCompletions.set(subject, 0);\r\n      }\r\n      \r\n      const completion = completedBySubject.find(c => c.quizId === quiz.id);\r\n      if (completion) {\r\n        subjectCompletions.set(subject, subjectCompletions.get(subject) + 1);\r\n      }\r\n    });\r\n    \r\n    // Format subject completion data\r\n    const subjectStats = quizzesBySubject.map(subject => {\r\n      const subjectName = subject.category || \"Uncategorized\";\r\n      const totalSubjectQuizzes = subject._count.id;\r\n      const completedSubjectQuizzes = subjectCompletions.get(subjectName) || 0;\r\n      const subjectCompletionRate = totalSubjectQuizzes > 0 \r\n        ? Math.round((completedSubjectQuizzes / totalSubjectQuizzes) * 100) \r\n        : 0;\r\n      \r\n      return {\r\n        subject: subjectName,\r\n        totalQuizzes: totalSubjectQuizzes,\r\n        completedQuizzes: completedSubjectQuizzes,\r\n        completionRate: subjectCompletionRate,\r\n      };\r\n    });\r\n    \r\n    // Get latest completed quiz (only from enrolled classes)\r\n    const latestCompletion = enrolledClassIds.length > 0\r\n      ? await db.quizAttempt.findFirst({\r\n          where: {\r\n            userId,\r\n            completedAt: {\r\n              not: null,\r\n            },\r\n            quiz: {\r\n              classId: {\r\n                in: enrolledClassIds\r\n              }\r\n            }\r\n          },\r\n          orderBy: {\r\n            completedAt: \"desc\",\r\n          },\r\n          select: {\r\n            completedAt: true,\r\n            quiz: {\r\n              select: {\r\n                title: true,\r\n              },\r\n            },\r\n          },\r\n        })\r\n      : null;\r\n    \r\n    // Find subjects with highest and lowest completion rates\r\n    let bestSubject = null;\r\n    let worstSubject = null;\r\n    \r\n    if (subjectStats.length > 0) {\r\n      const sortedByCompletion = [...subjectStats].sort(\r\n        (a, b) => b.completionRate - a.completionRate\r\n      );\r\n      \r\n      bestSubject = {\r\n        name: sortedByCompletion[0].subject,\r\n        completionRate: sortedByCompletion[0].completionRate,\r\n      };\r\n      \r\n      worstSubject = {\r\n        name: sortedByCompletion[sortedByCompletion.length - 1].subject,\r\n        completionRate: sortedByCompletion[sortedByCompletion.length - 1].completionRate,\r\n      };\r\n    }\r\n    \r\n    // Check if we have quiz data\r\n    if (totalQuizzes === 0) {\r\n      return createApiResponse({\r\n        status: 200,\r\n        data: {\r\n          totalQuizzes: 0,\r\n          completedQuizzes: 0,\r\n          completionRate: 0,\r\n          subjectStats: [],\r\n          latestCompletion: null,\r\n          bestSubject: null,\r\n          worstSubject: null,\r\n          timeFrame,\r\n        },\r\n        message: \"No quiz data found\",\r\n      });\r\n    }\r\n\r\n    // Continue with the rest of the function if real data exists...\r\n    \r\n    // Generate completion trend data\r\n    // Create time periods based on time frame\r\n    const { startDate: trendStartDate, endDate: trendEndDate } = getTimeRange(timeFrame);\r\n    const timePeriods = generateTimePeriods(trendStartDate, trendEndDate, \"month\");\r\n\r\n    // Group completed quizzes by month using best attempt per quiz\r\n    const completionTrends = await Promise.all(\r\n      timePeriods.map(async (period) => {\r\n        const [year, month] = period.split('-');\r\n        const periodStartDate = new Date(parseInt(year), parseInt(month) - 1, 1);\r\n        const periodEndDate = new Date(parseInt(year), parseInt(month), 0); // Last day of month\r\n\r\n        const periodAttempts = enrolledClassIds.length > 0\r\n          ? await db.quizAttempt.findMany({\r\n              where: {\r\n                userId,\r\n                completedAt: {\r\n                  not: null,\r\n                  gte: periodStartDate,\r\n                  lte: periodEndDate\r\n                },\r\n                quiz: {\r\n                  classId: {\r\n                    in: enrolledClassIds\r\n                  }\r\n                }\r\n              },\r\n              select: {\r\n                score: true,\r\n                quizId: true\r\n              }\r\n            })\r\n          : [];\r\n\r\n        // Get best score per quiz for this period\r\n        const periodQuizBestScores = new Map<string, number>();\r\n\r\n        periodAttempts.forEach(attempt => {\r\n          if (attempt.score !== null) {\r\n            const currentBest = periodQuizBestScores.get(attempt.quizId) || 0;\r\n            if (attempt.score > currentBest) {\r\n              periodQuizBestScores.set(attempt.quizId, attempt.score);\r\n            }\r\n          }\r\n        });\r\n\r\n        const periodBestScores = Array.from(periodQuizBestScores.values());\r\n        const periodAverageScore = periodBestScores.length > 0\r\n          ? parseFloat((periodBestScores.reduce((sum, score) => sum + score, 0) / periodBestScores.length).toFixed(1))\r\n          : 0;\r\n\r\n        return {\r\n          period,\r\n          completedCount: periodQuizBestScores.size, // Count unique quizzes, not total attempts\r\n          averageScore: periodAverageScore\r\n        };\r\n      })\r\n    );\r\n    \r\n    // Get quiz details for breakdown (simplified version - just most recent attempts from enrolled classes)\r\n    const recentQuizAttempts = enrolledClassIds.length > 0\r\n      ? await db.quizAttempt.findMany({\r\n          where: {\r\n            userId,\r\n            completedAt: {\r\n              not: null,\r\n              gte: startDate,\r\n              lte: now\r\n            },\r\n            quiz: {\r\n              classId: {\r\n                in: enrolledClassIds\r\n              }\r\n            }\r\n          },\r\n          orderBy: {\r\n            completedAt: 'desc'\r\n          },\r\n          take: 5, // Get just the 5 most recent for simplicity\r\n          select: {\r\n            quizId: true,\r\n            score: true,\r\n            completedAt: true,\r\n            quiz: {\r\n              select: {\r\n                id: true,\r\n                title: true,\r\n                class: {\r\n                  select: {\r\n                    name: true\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        })\r\n      : [];\r\n    \r\n    // Transform to expected format\r\n    const quizBreakdown = recentQuizAttempts.map(attempt => ({\r\n      quizId: attempt.quiz.id,\r\n      title: attempt.quiz.title,\r\n      className: attempt.quiz.class?.name || \"No Class\",\r\n      completionStatus: \"completed\" as const,\r\n      bestScore: attempt.score,\r\n      attemptCount: 1, // Simplified - would need additional query for real count\r\n      lastAttemptDate: attempt.completedAt?.toISOString() || null\r\n    }));\r\n    \r\n    return createApiResponse({\r\n      status: 200,\r\n      data: {\r\n        // Key metrics\r\n        totalQuizzes,\r\n        completedQuizzes,\r\n        completionRate,\r\n        averageScore,\r\n        averageAttempts,\r\n        \r\n        // Subject stats (categories)\r\n        subjectStats,\r\n        \r\n        // Latest completion info\r\n        latestCompletion: latestCompletion ? {\r\n          title: latestCompletion.quiz.title,\r\n          completedAt: latestCompletion.completedAt,\r\n        } : null,\r\n        \r\n        // Subject performance\r\n        bestSubject,\r\n        worstSubject,\r\n        \r\n        // Time series data\r\n        completionTrends,\r\n        \r\n        // Quiz breakdown\r\n        quizBreakdown,\r\n        \r\n        // Selected time frame\r\n        timeFrame,\r\n      },\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error(\"Error fetching quiz completion analytics:\", error);\r\n    return createApiErrorResponse({\r\n      status: 500,\r\n      message: \"Failed to fetch quiz completion analytics\",\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Determines the time range based on the specified timeFrame.\r\n * \r\n * @param timeFrame - \"last7days\", \"last30days\", \"last90days\", or \"allTime\"\r\n * @returns Object containing startDate and endDate\r\n */\r\nfunction getTimeRange(timeFrame: string) {\r\n  const today = startOfToday();\r\n  \r\n  switch (timeFrame) {\r\n    case \"last7days\":\r\n      return {\r\n        startDate: subDays(today, 7),\r\n        endDate: today\r\n      };\r\n    case \"last30days\":\r\n      return {\r\n        startDate: subDays(today, 30),\r\n        endDate: today\r\n      };\r\n    case \"last90days\":\r\n      return {\r\n        startDate: subDays(today, 90),\r\n        endDate: today\r\n      };\r\n    case \"allTime\":\r\n    default:\r\n      return {\r\n        startDate: subMonths(today, 12), // Default to last 12 months\r\n        endDate: today\r\n      };\r\n  }\r\n}\r\n\r\n/**\r\n * Generates all time periods between start and end dates based on monthly grouping.\r\n * \r\n * @param startDate - Start date of the range\r\n * @param endDate - End date of the range\r\n * @param groupBy - Currently only supports \"month\"\r\n * @returns Array of period keys in format YYYY-MM\r\n */\r\nfunction generateTimePeriods(\r\n  startDate: Date,\r\n  endDate: Date,\r\n  groupBy: \"month\"\r\n): string[] {\r\n  const periods: string[] = [];\r\n  let currentDate = new Date(startDate);\r\n  \r\n  while (currentDate <= endDate) {\r\n    const periodKey = format(currentDate, \"yyyy-MM\");\r\n    periods.push(periodKey);\r\n    \r\n    // Move to next month\r\n    currentDate = new Date(currentDate.setMonth(currentDate.getMonth() + 1));\r\n  }\r\n  \r\n  return periods;\r\n} "],"names":[],"mappings":"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","debugId":null}}]
}
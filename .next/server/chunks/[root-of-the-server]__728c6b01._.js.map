{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/users/me/quiz-analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth/next\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { endOfDay, startOfDay, subDays, subMonths, subYears, format, parseISO } from \"date-fns\";\r\nimport { QuizAttempt, Prisma } from \"@prisma/client\";\r\n\r\ninterface TimeSeriesDataPoint {\r\n  date: string;\r\n  averageScore: number;\r\n  assessmentCount: number;\r\n}\r\n\r\ninterface SubjectPerformanceData {\r\n  subject: string;\r\n  averageScore: number;\r\n  assessmentCount: number;\r\n  trend: number | null;\r\n}\r\n\r\ninterface AttemptWithQuiz extends QuizAttempt {\r\n  quiz: {\r\n    title: string;\r\n    category: string | null;\r\n  }\r\n}\r\n\r\n/**\r\n * GET handler for /api/users/me/quiz-analytics\r\n * Provides analytics data for the student's quiz results\r\n */\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    // Check authentication\r\n    const session = await getServerSession(authOptions);\r\n    if (!session || !session.user) {\r\n      return NextResponse.json(\r\n        { success: false, message: \"Unauthorized\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Parse query parameters\r\n    const url = new URL(req.url);\r\n    const timeFrame = url.searchParams.get(\"timeFrame\") || \"last30days\";\r\n    const subject = url.searchParams.get(\"subject\");\r\n\r\n    // Determine date range based on timeFrame\r\n    const now = new Date();\r\n    let startDate: Date;\r\n\r\n    switch (timeFrame) {\r\n      case \"last7days\":\r\n        startDate = subDays(now, 7);\r\n        break;\r\n      case \"last30days\":\r\n        startDate = subDays(now, 30);\r\n        break;\r\n      case \"last90days\":\r\n        startDate = subDays(now, 90);\r\n        break;\r\n      case \"last6months\":\r\n        startDate = subMonths(now, 6);\r\n        break;\r\n      case \"lastYear\":\r\n        startDate = subYears(now, 1);\r\n        break;\r\n      case \"allTime\":\r\n        startDate = new Date(0); // Beginning of time\r\n        break;\r\n      default:\r\n        startDate = subDays(now, 30); // Default to last 30 days\r\n    }\r\n\r\n    // Build the base query for quiz attempts\r\n    const whereClause: Prisma.QuizAttemptWhereInput = {\r\n      userId: session.user.id,\r\n      completedAt: { \r\n        not: null,\r\n        gte: startDate\r\n      },\r\n      score: { not: null }\r\n    };\r\n\r\n    // Apply subject filter if specified\r\n    if (subject) {\r\n      whereClause.quiz = {\r\n        category: subject\r\n      };\r\n    }\r\n\r\n    // Fetch quiz attempts based on filters\r\n    const quizAttempts = await prisma.quizAttempt.findMany({\r\n      where: whereClause,\r\n      include: {\r\n        quiz: {\r\n          select: {\r\n            title: true,\r\n            category: true,\r\n          }\r\n        }\r\n      },\r\n      orderBy: {\r\n        completedAt: 'desc' as Prisma.SortOrder\r\n      }\r\n    });\r\n\r\n    // Calculate the previous period for comparison\r\n    const previousPeriodStartDate = (() => {\r\n      switch (timeFrame) {\r\n        case \"last7days\":\r\n          return subDays(startDate, 7);\r\n        case \"last30days\":\r\n          return subDays(startDate, 30);\r\n        case \"last90days\":\r\n          return subDays(startDate, 90);\r\n        case \"last6months\":\r\n          return subMonths(startDate, 6);\r\n        case \"lastYear\":\r\n          return subYears(startDate, 1);\r\n        default:\r\n          return subDays(startDate, 30);\r\n      }\r\n    })();\r\n\r\n    // Fetch previous period attempts for comparison\r\n    const previousPeriodAttempts = await prisma.quizAttempt.findMany({\r\n      where: {\r\n        userId: session.user.id,\r\n        completedAt: { \r\n          not: null,\r\n          gte: previousPeriodStartDate,\r\n          lt: startDate\r\n        },\r\n        score: { not: null }\r\n      },\r\n      include: {\r\n        quiz: {\r\n          select: {\r\n            title: true,\r\n            category: true,\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Generate time series data for score chart\r\n    const timeSeriesData = generateTimeSeriesData(quizAttempts as AttemptWithQuiz[], timeFrame);\r\n\r\n    // Generate subject performance data\r\n    const subjectPerformance = generateSubjectPerformance(\r\n      quizAttempts as AttemptWithQuiz[], \r\n      previousPeriodAttempts as AttemptWithQuiz[]\r\n    );\r\n\r\n    // Calculate overall statistics\r\n    const currentAverageScore = quizAttempts.length > 0\r\n      ? quizAttempts.reduce((sum, attempt) => sum + (attempt.score || 0), 0) / quizAttempts.length\r\n      : 0;\r\n    \r\n    const previousAverageScore = previousPeriodAttempts.length > 0\r\n      ? previousPeriodAttempts.reduce((sum, attempt) => sum + (attempt.score || 0), 0) / previousPeriodAttempts.length\r\n      : null;\r\n    \r\n    const improvement = previousAverageScore !== null\r\n      ? currentAverageScore - previousAverageScore\r\n      : null;\r\n\r\n    // Get all quizzes assigned to the student\r\n    const assignedQuizzes = await prisma.quiz.count({\r\n      where: {\r\n        OR: [\r\n          {\r\n            class: {\r\n              students: {\r\n                some: {\r\n                  studentId: session.user.id\r\n                }\r\n              }\r\n            }\r\n          },\r\n          {\r\n            isPublic: true\r\n          }\r\n        ]\r\n      }\r\n    });\r\n\r\n    // Calculate completion data\r\n    const completedQuizzes = await prisma.$queryRaw<{ count: bigint }[]>`\r\n      SELECT COUNT(DISTINCT \"quizId\") as count \r\n      FROM \"QuizAttempt\" \r\n      WHERE \"userId\" = ${session.user.id} AND \"completedAt\" IS NOT NULL\r\n    `;\r\n\r\n    // Format the response data\r\n    const analyticsData = {\r\n      overallStats: {\r\n        averageScore: currentAverageScore,\r\n        previousAverageScore,\r\n        improvement,\r\n        totalAssessments: quizAttempts.length,\r\n        currentPeriodLabel: getTimeFrameLabel(timeFrame),\r\n        previousPeriodLabel: previousAverageScore !== null ? `previous ${getTimeFrameLabel(timeFrame)}` : null,\r\n      },\r\n      completionData: {\r\n        totalQuizzes: assignedQuizzes,\r\n        completedQuizzes: Number(completedQuizzes[0]?.count || 0),\r\n        completionRate: assignedQuizzes > 0 ? Math.round((Number(completedQuizzes[0]?.count || 0) / assignedQuizzes) * 100) : 0,\r\n        bestSubject: getBestSubject(subjectPerformance),\r\n        mostImprovedSubject: getMostImprovedSubject(subjectPerformance)\r\n      },\r\n      timeSeriesData,\r\n      subjectPerformance,\r\n    };\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      data: analyticsData\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error(\"Error in quiz analytics API:\", error);\r\n    return NextResponse.json(\r\n      { success: false, message: \"Failed to fetch analytics data\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// Utility function to generate time series data for the score chart\r\nfunction generateTimeSeriesData(attempts: AttemptWithQuiz[], timeFrame: string): TimeSeriesDataPoint[] {\r\n  if (!attempts.length) return [];\r\n\r\n  // Create a map to store aggregated data by date\r\n  const dataByDate = new Map<string, { date: string, totalScore: number, count: number }>();\r\n\r\n  attempts.forEach(attempt => {\r\n    if (!attempt.completedAt || !attempt.score) return;\r\n\r\n    // Format date based on timeFrame\r\n    let dateKey: string;\r\n    const completedAt = new Date(attempt.completedAt);\r\n\r\n    switch (timeFrame) {\r\n      case \"last7days\":\r\n      case \"last30days\":\r\n        // For short timeframes, use daily data points\r\n        dateKey = format(completedAt, \"yyyy-MM-dd\");\r\n        break;\r\n      case \"last90days\":\r\n        // For medium timeframes, use weekly data points\r\n        const weekNumber = Math.floor(completedAt.getDate() / 7) + 1;\r\n        dateKey = `${format(completedAt, \"yyyy-MM\")}-W${weekNumber}`;\r\n        break;\r\n      default:\r\n        // For longer timeframes, use monthly data points\r\n        dateKey = format(completedAt, \"yyyy-MM\");\r\n    }\r\n\r\n    // Update the aggregated data\r\n    if (!dataByDate.has(dateKey)) {\r\n      dataByDate.set(dateKey, {\r\n        date: dateKey,\r\n        totalScore: attempt.score,\r\n        count: 1\r\n      });\r\n    } else {\r\n      const existingData = dataByDate.get(dateKey)!;\r\n      dataByDate.set(dateKey, {\r\n        ...existingData,\r\n        totalScore: existingData.totalScore + attempt.score,\r\n        count: existingData.count + 1\r\n      });\r\n    }\r\n  });\r\n\r\n  // Convert the map to an array of data points\r\n  const timeSeriesData = Array.from(dataByDate.values()).map(data => ({\r\n    date: data.date,\r\n    averageScore: parseFloat((data.totalScore / data.count).toFixed(1)),\r\n    assessmentCount: data.count\r\n  }));\r\n\r\n  // Sort by date\r\n  return timeSeriesData.sort((a, b) => a.date.localeCompare(b.date));\r\n}\r\n\r\n// Utility function to generate subject performance data\r\nfunction generateSubjectPerformance(\r\n  currentAttempts: AttemptWithQuiz[], \r\n  previousAttempts: AttemptWithQuiz[]\r\n): SubjectPerformanceData[] {\r\n  // Group current attempts by subject\r\n  const subjectMap = new Map<string, { subject: string, totalScore: number, count: number }>();\r\n\r\n  currentAttempts.forEach(attempt => {\r\n    if (!attempt.score || !attempt.quiz.category) return;\r\n    \r\n    const subject = attempt.quiz.category;\r\n    \r\n    if (!subjectMap.has(subject)) {\r\n      subjectMap.set(subject, {\r\n        subject,\r\n        totalScore: attempt.score,\r\n        count: 1\r\n      });\r\n    } else {\r\n      const existingData = subjectMap.get(subject)!;\r\n      subjectMap.set(subject, {\r\n        ...existingData,\r\n        totalScore: existingData.totalScore + attempt.score,\r\n        count: existingData.count + 1\r\n      });\r\n    }\r\n  });\r\n\r\n  // Group previous attempts by subject\r\n  const previousSubjectMap = new Map<string, { subject: string, totalScore: number, count: number }>();\r\n  \r\n  previousAttempts.forEach(attempt => {\r\n    if (!attempt.score || !attempt.quiz.category) return;\r\n    \r\n    const subject = attempt.quiz.category;\r\n    \r\n    if (!previousSubjectMap.has(subject)) {\r\n      previousSubjectMap.set(subject, {\r\n        subject,\r\n        totalScore: attempt.score,\r\n        count: 1\r\n      });\r\n    } else {\r\n      const existingData = previousSubjectMap.get(subject)!;\r\n      previousSubjectMap.set(subject, {\r\n        ...existingData,\r\n        totalScore: existingData.totalScore + attempt.score,\r\n        count: existingData.count + 1\r\n      });\r\n    }\r\n  });\r\n\r\n  // Calculate average scores and trends\r\n  return Array.from(subjectMap.values()).map(data => {\r\n    const averageScore = parseFloat((data.totalScore / data.count).toFixed(1));\r\n    \r\n    // Calculate trend if we have previous data for this subject\r\n    let trend = null;\r\n    if (previousSubjectMap.has(data.subject)) {\r\n      const previousData = previousSubjectMap.get(data.subject)!;\r\n      const previousAverage = previousData.totalScore / previousData.count;\r\n      trend = parseFloat((averageScore - previousAverage).toFixed(1));\r\n    }\r\n    \r\n    return {\r\n      subject: data.subject,\r\n      averageScore,\r\n      assessmentCount: data.count,\r\n      trend\r\n    };\r\n  }).sort((a, b) => b.averageScore - a.averageScore); // Sort by average score (highest first)\r\n}\r\n\r\n// Utility function to get the best subject\r\nfunction getBestSubject(subjectPerformance: SubjectPerformanceData[]) {\r\n  if (!subjectPerformance.length) {\r\n    return { name: \"N/A\", score: 0 };\r\n  }\r\n  \r\n  const best = subjectPerformance[0]; // Already sorted by score\r\n  return { name: best.subject, score: best.averageScore };\r\n}\r\n\r\n// Utility function to get the most improved subject\r\nfunction getMostImprovedSubject(subjectPerformance: SubjectPerformanceData[]) {\r\n  // Filter to subjects that have a positive trend value (improvement)\r\n  const subjectsWithImprovement = subjectPerformance.filter(subject => \r\n    subject.trend !== null && subject.trend > 0\r\n  );\r\n  \r\n  if (!subjectsWithImprovement.length) {\r\n    return null;\r\n  }\r\n  \r\n  // Sort by trend value (highest improvement first)\r\n  const mostImproved = subjectsWithImprovement.sort((a, b) => \r\n    (b.trend as number) - (a.trend as number)\r\n  )[0];\r\n  \r\n  return { \r\n    name: mostImproved.subject, \r\n    improvement: mostImproved.trend as number\r\n  };\r\n}\r\n\r\n// Utility function to get a human-readable label for the time frame\r\nfunction getTimeFrameLabel(timeFrame: string): string {\r\n  switch (timeFrame) {\r\n    case \"last7days\": return \"last 7 days\";\r\n    case \"last30days\": return \"last 30 days\";\r\n    case \"last90days\": return \"last 90 days\";\r\n    case \"last6months\": return \"last 6 months\";\r\n    case \"lastYear\": return \"last year\";\r\n    case \"allTime\": return \"all time\";\r\n    default: return timeFrame;\r\n  }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;;;;;AA2BO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,uBAAuB;QACvB,MAAM,UAAU,MAAM,CAAA,GAAA,+IAAA,CAAA,mBAAgB,AAAD,EAAE,mJAAA,CAAA,cAAW;QAClD,IAAI,CAAC,WAAW,CAAC,QAAQ,IAAI,EAAE;YAC7B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,SAAS;YAAe,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,MAAM,IAAI,IAAI,IAAI,GAAG;QAC3B,MAAM,YAAY,IAAI,YAAY,CAAC,GAAG,CAAC,gBAAgB;QACvD,MAAM,UAAU,IAAI,YAAY,CAAC,GAAG,CAAC;QAErC,0CAA0C;QAC1C,MAAM,MAAM,IAAI;QAChB,IAAI;QAEJ,OAAQ;YACN,KAAK;gBACH,YAAY,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,KAAK;gBACzB;YACF,KAAK;gBACH,YAAY,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,KAAK;gBACzB;YACF,KAAK;gBACH,YAAY,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,KAAK;gBACzB;YACF,KAAK;gBACH,YAAY,CAAA,GAAA,2IAAA,CAAA,YAAS,AAAD,EAAE,KAAK;gBAC3B;YACF,KAAK;gBACH,YAAY,CAAA,GAAA,0IAAA,CAAA,WAAQ,AAAD,EAAE,KAAK;gBAC1B;YACF,KAAK;gBACH,YAAY,IAAI,KAAK,IAAI,oBAAoB;gBAC7C;YACF;gBACE,YAAY,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,KAAK,KAAK,0BAA0B;QAC5D;QAEA,yCAAyC;QACzC,MAAM,cAA4C;YAChD,QAAQ,QAAQ,IAAI,CAAC,EAAE;YACvB,aAAa;gBACX,KAAK;gBACL,KAAK;YACP;YACA,OAAO;gBAAE,KAAK;YAAK;QACrB;QAEA,oCAAoC;QACpC,IAAI,SAAS;YACX,YAAY,IAAI,GAAG;gBACjB,UAAU;YACZ;QACF;QAEA,uCAAuC;QACvC,MAAM,eAAe,MAAM,+GAAA,CAAA,SAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;YACrD,OAAO;YACP,SAAS;gBACP,MAAM;oBACJ,QAAQ;wBACN,OAAO;wBACP,UAAU;oBACZ;gBACF;YACF;YACA,SAAS;gBACP,aAAa;YACf;QACF;QAEA,+CAA+C;QAC/C,MAAM,0BAA0B,CAAC;YAC/B,OAAQ;gBACN,KAAK;oBACH,OAAO,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,WAAW;gBAC5B,KAAK;oBACH,OAAO,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,WAAW;gBAC5B,KAAK;oBACH,OAAO,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,WAAW;gBAC5B,KAAK;oBACH,OAAO,CAAA,GAAA,2IAAA,CAAA,YAAS,AAAD,EAAE,WAAW;gBAC9B,KAAK;oBACH,OAAO,CAAA,GAAA,0IAAA,CAAA,WAAQ,AAAD,EAAE,WAAW;gBAC7B;oBACE,OAAO,CAAA,GAAA,yIAAA,CAAA,UAAO,AAAD,EAAE,WAAW;YAC9B;QACF,CAAC;QAED,gDAAgD;QAChD,MAAM,yBAAyB,MAAM,+GAAA,CAAA,SAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;YAC/D,OAAO;gBACL,QAAQ,QAAQ,IAAI,CAAC,EAAE;gBACvB,aAAa;oBACX,KAAK;oBACL,KAAK;oBACL,IAAI;gBACN;gBACA,OAAO;oBAAE,KAAK;gBAAK;YACrB;YACA,SAAS;gBACP,MAAM;oBACJ,QAAQ;wBACN,OAAO;wBACP,UAAU;oBACZ;gBACF;YACF;QACF;QAEA,4CAA4C;QAC5C,MAAM,iBAAiB,uBAAuB,cAAmC;QAEjF,oCAAoC;QACpC,MAAM,qBAAqB,2BACzB,cACA;QAGF,+BAA+B;QAC/B,MAAM,sBAAsB,aAAa,MAAM,GAAG,IAC9C,aAAa,MAAM,CAAC,CAAC,KAAK,UAAY,MAAM,CAAC,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,aAAa,MAAM,GAC1F;QAEJ,MAAM,uBAAuB,uBAAuB,MAAM,GAAG,IACzD,uBAAuB,MAAM,CAAC,CAAC,KAAK,UAAY,MAAM,CAAC,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,uBAAuB,MAAM,GAC9G;QAEJ,MAAM,cAAc,yBAAyB,OACzC,sBAAsB,uBACtB;QAEJ,0CAA0C;QAC1C,MAAM,kBAAkB,MAAM,+GAAA,CAAA,SAAM,CAAC,IAAI,CAAC,KAAK,CAAC;YAC9C,OAAO;gBACL,IAAI;oBACF;wBACE,OAAO;4BACL,UAAU;gCACR,MAAM;oCACJ,WAAW,QAAQ,IAAI,CAAC,EAAE;gCAC5B;4BACF;wBACF;oBACF;oBACA;wBACE,UAAU;oBACZ;iBACD;YACH;QACF;QAEA,4BAA4B;QAC5B,MAAM,mBAAmB,MAAM,+GAAA,CAAA,SAAM,CAAC,SAAS,AAAqB,CAAC;;;uBAGlD,EAAE,QAAQ,IAAI,CAAC,EAAE,CAAC;IACrC,CAAC;QAED,2BAA2B;QAC3B,MAAM,gBAAgB;YACpB,cAAc;gBACZ,cAAc;gBACd;gBACA;gBACA,kBAAkB,aAAa,MAAM;gBACrC,oBAAoB,kBAAkB;gBACtC,qBAAqB,yBAAyB,OAAO,CAAC,SAAS,EAAE,kBAAkB,YAAY,GAAG;YACpG;YACA,gBAAgB;gBACd,cAAc;gBACd,kBAAkB,OAAO,gBAAgB,CAAC,EAAE,EAAE,SAAS;gBACvD,gBAAgB,kBAAkB,IAAI,KAAK,KAAK,CAAC,AAAC,OAAO,gBAAgB,CAAC,EAAE,EAAE,SAAS,KAAK,kBAAmB,OAAO;gBACtH,aAAa,eAAe;gBAC5B,qBAAqB,uBAAuB;YAC9C;YACA;YACA;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;QACR;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,SAAS;QAAiC,GAC5D;YAAE,QAAQ;QAAI;IAElB;AACF;AAEA,oEAAoE;AACpE,SAAS,uBAAuB,QAA2B,EAAE,SAAiB;IAC5E,IAAI,CAAC,SAAS,MAAM,EAAE,OAAO,EAAE;IAE/B,gDAAgD;IAChD,MAAM,aAAa,IAAI;IAEvB,SAAS,OAAO,CAAC,CAAA;QACf,IAAI,CAAC,QAAQ,WAAW,IAAI,CAAC,QAAQ,KAAK,EAAE;QAE5C,iCAAiC;QACjC,IAAI;QACJ,MAAM,cAAc,IAAI,KAAK,QAAQ,WAAW;QAEhD,OAAQ;YACN,KAAK;YACL,KAAK;gBACH,8CAA8C;gBAC9C,UAAU,CAAA,GAAA,wJAAA,CAAA,SAAM,AAAD,EAAE,aAAa;gBAC9B;YACF,KAAK;gBACH,gDAAgD;gBAChD,MAAM,aAAa,KAAK,KAAK,CAAC,YAAY,OAAO,KAAK,KAAK;gBAC3D,UAAU,GAAG,CAAA,GAAA,wJAAA,CAAA,SAAM,AAAD,EAAE,aAAa,WAAW,EAAE,EAAE,YAAY;gBAC5D;YACF;gBACE,iDAAiD;gBACjD,UAAU,CAAA,GAAA,wJAAA,CAAA,SAAM,AAAD,EAAE,aAAa;QAClC;QAEA,6BAA6B;QAC7B,IAAI,CAAC,WAAW,GAAG,CAAC,UAAU;YAC5B,WAAW,GAAG,CAAC,SAAS;gBACtB,MAAM;gBACN,YAAY,QAAQ,KAAK;gBACzB,OAAO;YACT;QACF,OAAO;YACL,MAAM,eAAe,WAAW,GAAG,CAAC;YACpC,WAAW,GAAG,CAAC,SAAS;gBACtB,GAAG,YAAY;gBACf,YAAY,aAAa,UAAU,GAAG,QAAQ,KAAK;gBACnD,OAAO,aAAa,KAAK,GAAG;YAC9B;QACF;IACF;IAEA,6CAA6C;IAC7C,MAAM,iBAAiB,MAAM,IAAI,CAAC,WAAW,MAAM,IAAI,GAAG,CAAC,CAAA,OAAQ,CAAC;YAClE,MAAM,KAAK,IAAI;YACf,cAAc,WAAW,CAAC,KAAK,UAAU,GAAG,KAAK,KAAK,EAAE,OAAO,CAAC;YAChE,iBAAiB,KAAK,KAAK;QAC7B,CAAC;IAED,eAAe;IACf,OAAO,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,IAAI,CAAC,aAAa,CAAC,EAAE,IAAI;AAClE;AAEA,wDAAwD;AACxD,SAAS,2BACP,eAAkC,EAClC,gBAAmC;IAEnC,oCAAoC;IACpC,MAAM,aAAa,IAAI;IAEvB,gBAAgB,OAAO,CAAC,CAAA;QACtB,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,EAAE;QAE9C,MAAM,UAAU,QAAQ,IAAI,CAAC,QAAQ;QAErC,IAAI,CAAC,WAAW,GAAG,CAAC,UAAU;YAC5B,WAAW,GAAG,CAAC,SAAS;gBACtB;gBACA,YAAY,QAAQ,KAAK;gBACzB,OAAO;YACT;QACF,OAAO;YACL,MAAM,eAAe,WAAW,GAAG,CAAC;YACpC,WAAW,GAAG,CAAC,SAAS;gBACtB,GAAG,YAAY;gBACf,YAAY,aAAa,UAAU,GAAG,QAAQ,KAAK;gBACnD,OAAO,aAAa,KAAK,GAAG;YAC9B;QACF;IACF;IAEA,qCAAqC;IACrC,MAAM,qBAAqB,IAAI;IAE/B,iBAAiB,OAAO,CAAC,CAAA;QACvB,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,EAAE;QAE9C,MAAM,UAAU,QAAQ,IAAI,CAAC,QAAQ;QAErC,IAAI,CAAC,mBAAmB,GAAG,CAAC,UAAU;YACpC,mBAAmB,GAAG,CAAC,SAAS;gBAC9B;gBACA,YAAY,QAAQ,KAAK;gBACzB,OAAO;YACT;QACF,OAAO;YACL,MAAM,eAAe,mBAAmB,GAAG,CAAC;YAC5C,mBAAmB,GAAG,CAAC,SAAS;gBAC9B,GAAG,YAAY;gBACf,YAAY,aAAa,UAAU,GAAG,QAAQ,KAAK;gBACnD,OAAO,aAAa,KAAK,GAAG;YAC9B;QACF;IACF;IAEA,sCAAsC;IACtC,OAAO,MAAM,IAAI,CAAC,WAAW,MAAM,IAAI,GAAG,CAAC,CAAA;QACzC,MAAM,eAAe,WAAW,CAAC,KAAK,UAAU,GAAG,KAAK,KAAK,EAAE,OAAO,CAAC;QAEvE,4DAA4D;QAC5D,IAAI,QAAQ;QACZ,IAAI,mBAAmB,GAAG,CAAC,KAAK,OAAO,GAAG;YACxC,MAAM,eAAe,mBAAmB,GAAG,CAAC,KAAK,OAAO;YACxD,MAAM,kBAAkB,aAAa,UAAU,GAAG,aAAa,KAAK;YACpE,QAAQ,WAAW,CAAC,eAAe,eAAe,EAAE,OAAO,CAAC;QAC9D;QAEA,OAAO;YACL,SAAS,KAAK,OAAO;YACrB;YACA,iBAAiB,KAAK,KAAK;YAC3B;QACF;IACF,GAAG,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY,GAAG,wCAAwC;AAC9F;AAEA,2CAA2C;AAC3C,SAAS,eAAe,kBAA4C;IAClE,IAAI,CAAC,mBAAmB,MAAM,EAAE;QAC9B,OAAO;YAAE,MAAM;YAAO,OAAO;QAAE;IACjC;IAEA,MAAM,OAAO,kBAAkB,CAAC,EAAE,EAAE,0BAA0B;IAC9D,OAAO;QAAE,MAAM,KAAK,OAAO;QAAE,OAAO,KAAK,YAAY;IAAC;AACxD;AAEA,oDAAoD;AACpD,SAAS,uBAAuB,kBAA4C;IAC1E,oEAAoE;IACpE,MAAM,0BAA0B,mBAAmB,MAAM,CAAC,CAAA,UACxD,QAAQ,KAAK,KAAK,QAAQ,QAAQ,KAAK,GAAG;IAG5C,IAAI,CAAC,wBAAwB,MAAM,EAAE;QACnC,OAAO;IACT;IAEA,kDAAkD;IAClD,MAAM,eAAe,wBAAwB,IAAI,CAAC,CAAC,GAAG,IACpD,AAAC,EAAE,KAAK,GAAe,EAAE,KAAK,CAC/B,CAAC,EAAE;IAEJ,OAAO;QACL,MAAM,aAAa,OAAO;QAC1B,aAAa,aAAa,KAAK;IACjC;AACF;AAEA,oEAAoE;AACpE,SAAS,kBAAkB,SAAiB;IAC1C,OAAQ;QACN,KAAK;YAAa,OAAO;QACzB,KAAK;YAAc,OAAO;QAC1B,KAAK;YAAc,OAAO;QAC1B,KAAK;YAAe,OAAO;QAC3B,KAAK;YAAY,OAAO;QACxB,KAAK;YAAW,OAAO;QACvB;YAAS,OAAO;IAClB;AACF","debugId":null}}]
}
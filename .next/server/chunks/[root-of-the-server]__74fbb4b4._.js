module.exports = {

"[project]/.next-internal/server/app/api/users/me/quizzes/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/@prisma/client/runtime/library [external] (@prisma/client/runtime/library, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client/runtime/library", () => require("@prisma/client/runtime/library"));

module.exports = mod;
}}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}}),
"[project]/lib/db.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "db": (()=>db)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const db = globalThis.prisma || new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]();
if ("TURBOPACK compile-time truthy", 1) globalThis.prisma = db;
}}),
"[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>handler),
    "POST": (()=>handler),
    "authOptions": (()=>authOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/prisma-adapter/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/google.js [app-route] (ecmascript)");
;
;
;
;
// Domain email ƒë∆∞·ª£c ·ªßy quy·ªÅn cao h∆°n
const AUTHORIZED_TEACHER_DOMAINS = [
    'school.edu',
    'university.edu',
    'teacher.org'
];
// Fix cho type adapter
const prismaAdapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PrismaAdapter"])(__TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"]);
// C·∫£i thi·ªán error handling
const handleAuthError = (error, context)=>{
    console.error(`[Auth Error] ${context}:`, error);
    return false;
};
const authOptions = {
    adapter: prismaAdapter,
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true
        })
    ],
    session: {
        strategy: "jwt",
        maxAge: 24 * 60 * 60,
        updateAge: 4 * 60 * 60
    },
    callbacks: {
        async jwt ({ token, user, account, profile, trigger }) {
            try {
                // Tr∆∞·ªùng h·ª£p ƒëƒÉng nh·∫≠p - Ch·ªâ c·∫≠p nh·∫≠t token khi c√≥ user t·ª´ ƒëƒÉng nh·∫≠p
                if (user) {
                    // ƒê·∫£m b·∫£o role c√≥ th·ªÉ null
                    token.role = user.role;
                    token.id = user.id;
                    return token;
                }
                // Tr∆∞·ªùng h·ª£p trigger update - C·∫≠p nh·∫≠t token khi c√≥ s·ª± thay ƒë·ªïi r√µ r√†ng
                if (trigger === 'update' && token?.sub) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                id: true,
                                name: true,
                                email: true,
                                role: true,
                                image: true
                            }
                        });
                        if (dbUser) {
                            // C·∫≠p nh·∫≠t token v·ªõi gi√° tr·ªã m·ªõi
                            token.role = dbUser.role;
                            token.name = dbUser.name;
                            token.email = dbUser.email;
                            token.picture = dbUser.image;
                            // Th√™m timestamp ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng cache token c≈©
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error updating token:", error);
                    }
                    return token;
                }
                // Tr∆∞·ªùng h·ª£p token t·ª´ session: ki·ªÉm tra n·∫øu c·∫ßn c·∫≠p nh·∫≠t
                if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt || 0) > 60 * 1000)) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                role: true
                            }
                        });
                        if (dbUser) {
                            token.role = dbUser.role;
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error refreshing token:", error);
                    }
                }
                return token;
            } catch (error) {
                console.error("JWT callback error:", error);
                return token;
            }
        },
        async session ({ session, token }) {
            try {
                if (session.user && token) {
                    // ƒê·∫£m b·∫£o role c√≥ th·ªÉ null
                    session.user.role = token.role;
                    session.user.id = token.id;
                }
                return session;
            } catch (error) {
                console.error("Session callback error:", error);
                return session;
            }
        },
        async signIn ({ user, account, profile }) {
            // N·∫øu user c√≥ email
            if (user?.email) {
                try {
                    // Ki·ªÉm tra user ƒë√£ t·ªìn t·∫°i ch∆∞a
                    const existingUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                        where: {
                            email: user.email
                        }
                    });
                    if (!existingUser) {
                        // T·∫°o user m·ªõi kh√¥ng c√≥ role (null) ƒë·ªÉ ng∆∞·ªùi d√πng ch·ªçn sau
                        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.create({
                            data: {
                                id: user.id,
                                email: user.email,
                                name: user.name,
                                image: user.image,
                                role: null
                            }
                        });
                        // ƒê√°nh d·∫•u ƒë·ªÉ redirect t·ªõi trang ch·ªçn role
                        return true;
                    }
                    return true;
                } catch (error) {
                    return handleAuthError(error, "signIn callback");
                }
            }
            return true;
        }
    },
    pages: {
        signIn: '/auth/signin',
        signOut: '/',
        error: '/auth/error',
        newUser: '/auth/select-role' // ƒêi·ªÅu h∆∞·ªõng ng∆∞·ªùi d√πng m·ªõi ƒë·∫øn trang ch·ªçn role
    },
    secret: process.env.NEXTAUTH_SECRET,
    debug: ("TURBOPACK compile-time value", "development") === "development",
    logger: {
        error (code, ...message) {
            console.error(`[NextAuth Error] ${code}:`, ...message);
        },
        warn (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn(`[NextAuth Warning] ${code}:`, ...message);
            }
        },
        debug (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.debug(`[NextAuth Debug] ${code}:`, ...message);
            }
        }
    }
};
const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(authOptions);
;
}}),
"[project]/lib/prisma.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prisma": (()=>prisma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
;
const prisma = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"];
}}),
"[project]/app/api/users/me/quizzes/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>GET)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
;
;
;
;
async function GET(req) {
    try {
        // Get the authenticated user
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getServerSession"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
        if (!session?.user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                message: "Authentication required"
            }, {
                status: 401
            });
        }
        const userId = session.user.id;
        // Parse query parameters
        const searchParams = req.nextUrl.searchParams;
        const search = searchParams.get("search");
        const requestedStatus = searchParams.get("status"); // ‚úÖ T√äN M·ªöI ƒê·ªÇ TR√ÅNH XUNG ƒê·ªòT
        const classId = searchParams.get("classId");
        const subject = searchParams.get("subject");
        const startDateFrom = searchParams.get("startDateFrom");
        const endDateTo = searchParams.get("endDateTo");
        const sortBy = searchParams.get("sortBy") || "startDate";
        const sortOrder = searchParams.get("sortOrder") || "asc";
        // Pagination
        const page = parseInt(searchParams.get("page") || "1");
        const limit = parseInt(searchParams.get("limit") || "9");
        const skip = (page - 1) * limit;
        // Build filters object for Prisma query
        const filters = {
            // Only show published quizzes
            isPublished: true,
            OR: [
                // 1. Quiz t·ª´ c√°c l·ªõp h·ªçc sinh vi√™n ƒë√£ tham gia (ƒë√£ enrolled)
                {
                    class: {
                        students: {
                            some: {
                                studentId: userId
                            }
                        }
                    }
                },
                // 2. Quiz c√¥ng khai (isPublic = true)
                {
                    isPublic: true
                }
            ]
        };
        // Th√™m log ƒë·ªÉ ki·ªÉm tra
        console.log(`\nüîç [API] Fetching quizzes for student: ${userId}`);
        console.log(`üìã [API] Filters:`, JSON.stringify(filters, null, 2));
        console.log(`üéØ [API] Requested status filter: ${requestedStatus}`);
        console.log(`üìÑ [API] Pagination: page ${page}, limit ${limit}, skip ${skip}`);
        // ‚ùå B·ªé LOGIC FILTER SAI N√ÄY - N√ì LO·∫†I B·ªé T·∫§T C·∫¢ QUIZ UPCOMING V√Ä AVAILABLE
        // Quiz status s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n v√† filter sau trong processing logic
        // Kh√¥ng n√™n filter isPublished v√† isActive ·ªü ƒë√¢y v√¨ n√≥ s·∫Ω lo·∫°i b·ªè quiz c·∫ßn thi·∫øt
        // Search filter - index-based search optimization
        if (search) {
            filters.OR = [
                ...filters.OR,
                {
                    title: {
                        contains: search,
                        mode: "insensitive"
                    }
                },
                {
                    description: {
                        contains: search,
                        mode: "insensitive"
                    }
                }
            ];
        }
        // Class filter
        if (classId && classId !== "all") {
            filters.classId = classId;
        }
        // Subject filter - more direct filtering
        if (subject && subject !== "all") {
            // Need to adjust the OR clause to ensure class subject is considered
            filters.class = {
                subject
            };
        }
        // Date filters
        if (startDateFrom) {
            filters.startDate = {
                ...filters.startDate,
                gte: new Date(startDateFrom)
            };
        }
        if (endDateTo) {
            filters.endDate = {
                ...filters.endDate,
                lte: new Date(endDateTo)
            };
        }
        // Get current date
        const now = new Date();
        // Determine sort direction
        const direction = sortOrder === "desc" ? "desc" : "asc";
        // Determine sort field
        let orderBy = [];
        switch(sortBy){
            case "title":
                orderBy.push({
                    title: direction
                });
                break;
            case "endDate":
                orderBy.push({
                    endDate: direction
                });
                break;
            case "startDate":
            default:
                orderBy.push({
                    startDate: direction
                });
        }
        // Always add id as secondary sort for consistency
        orderBy.push({
            id: "asc"
        });
        // Status filter optimization - apply if needed
        let statusFilter = requestedStatus && requestedStatus !== "all" ? requestedStatus : null;
        // ‚ö†Ô∏è IMPORTANT: Don't pre-filter at database level for status
        // The status calculation is complex and depends on user attempts
        // We need to fetch all quizzes and then filter by status in JavaScript
        // Only apply basic database filters that are clearly safe
        if (statusFilter) {
            // Only apply very basic database filters that won't interfere with status calculation
            switch(statusFilter){
                case "expired":
                    break;
                case "upcoming":
                case "ongoing":
                case "completed":
                default:
                    break;
            }
        }
        // Fetch ALL quizzes first (without pagination) to properly calculate status
        // We need to do this because status filtering happens in JavaScript, not in database
        const allQuizzes = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quiz.findMany({
            where: filters,
            include: {
                class: {
                    select: {
                        name: true,
                        subject: true
                    }
                },
                attempts: {
                    where: {
                        userId
                    },
                    select: {
                        id: true,
                        score: true,
                        completedAt: true
                    }
                },
                _count: {
                    select: {
                        questions: true
                    }
                }
            },
            orderBy
        });
        console.log(`\nüìä [API] Database query results:`);
        console.log(`üìà [API] Total quizzes found: ${allQuizzes.length}`);
        // Process quizzes to determine status and transform data
        const processedQuizzes = allQuizzes.map((quiz)=>{
            // Calculate quiz status based on dates and attempts
            let status = "ongoing";
            const startDate = quiz.startDate;
            const endDate = quiz.endDate;
            const hasAttempts = quiz.attempts.length > 0;
            const hasCompletedAttempt = quiz.attempts.some((a)=>a.completedAt !== null);
            // Debug logging for status calculation
            console.log(`Quiz ${quiz.id} - ${quiz.title}:`, {
                startDate: startDate?.toISOString(),
                endDate: endDate?.toISOString(),
                now: now.toISOString(),
                hasAttempts,
                hasCompletedAttempt,
                maxAttempts: quiz.maxAttempts
            });
            // More precise status logic
            const hasStarted = !startDate || startDate <= now;
            const hasExpired = endDate && endDate < now;
            if (!hasStarted) {
                // Quiz has not started yet (startDate exists and is in future)
                status = "upcoming";
                console.log(`Quiz ${quiz.id} status: upcoming (not started)`);
            } else if (hasExpired) {
                // Quiz has ended - distinguish between completed and expired
                if (hasCompletedAttempt) {
                    status = "completed";
                    console.log(`Quiz ${quiz.id} status: completed (ended with completed attempt)`);
                } else {
                    status = "expired";
                    console.log(`Quiz ${quiz.id} status: expired (ended without completion)`);
                }
            } else if (hasCompletedAttempt && quiz.maxAttempts && quiz.attempts.length >= quiz.maxAttempts) {
                // Quiz is still open but user has completed all allowed attempts
                status = "completed";
                console.log(`Quiz ${quiz.id} status: completed (max attempts reached)`);
            } else {
                // Quiz is currently open and available
                status = "ongoing";
                console.log(`Quiz ${quiz.id} status: ongoing (available now)`);
            }
            // Calculate highest score from attempts - more efficient calculation
            let highestScore = null;
            if (hasCompletedAttempt) {
                const scores = quiz.attempts.filter((a)=>a.completedAt !== null && a.score !== null).map((a)=>a.score || 0);
                highestScore = scores.length ? Math.max(...scores) : null;
            }
            // Check if quiz is locked (formal class check)
            const userWithRoles = session.user;
            const isFormal = quiz.tags?.includes("formal") || false;
            const isLocked = isFormal && !userWithRoles.formalStudent || quiz.maxAttempts !== null && quiz.attempts.length >= quiz.maxAttempts && !hasCompletedAttempt;
            // Generate lock reason
            let lockReason = "";
            if (isLocked) {
                if (isFormal && !userWithRoles.formalStudent) {
                    lockReason = "This quiz is only available to formal class students";
                } else if (quiz.maxAttempts !== null && quiz.attempts.length >= quiz.maxAttempts) {
                    lockReason = "You have reached the maximum number of attempts";
                }
            }
            return {
                id: quiz.id,
                title: quiz.title,
                description: quiz.description,
                classId: quiz.classId,
                className: quiz.class?.name || null,
                subject: quiz.class?.subject || null,
                startDate: quiz.startDate?.toISOString() || null,
                endDate: quiz.endDate?.toISOString() || null,
                durationMinutes: quiz.timeLimit,
                totalQuestions: quiz._count.questions,
                status,
                isLocked,
                lockReason,
                isFormal,
                attemptLimit: quiz.maxAttempts,
                currentAttempts: quiz.attempts.length,
                highestScore
            };
        }).filter((quiz)=>quiz !== null); // Remove filtered out quizzes (null values) with proper typing
        // Filter by status AFTER processing all quizzes
        const filteredQuizzes = requestedStatus && requestedStatus !== "all" ? processedQuizzes.filter((quiz)=>quiz.status === requestedStatus) : processedQuizzes;
        // Apply pagination AFTER filtering
        const totalItems = filteredQuizzes.length;
        const totalPages = Math.max(1, Math.ceil(totalItems / limit));
        const startIndex = skip;
        const endIndex = startIndex + limit;
        const paginatedQuizzes = filteredQuizzes.slice(startIndex, endIndex);
        // Log final results summary
        const statusSummary = processedQuizzes.reduce((acc, quiz)=>{
            acc[quiz.status] = (acc[quiz.status] || 0) + 1;
            return acc;
        }, {});
        console.log(`\nüìã [API] Final results summary:`);
        console.log(`üéØ [API] Status filter requested: ${requestedStatus || 'none'}`);
        console.log(`üìä [API] Status distribution:`, statusSummary);
        console.log(`üìà [API] Total items after filtering: ${totalItems}`);
        console.log(`üìÑ [API] Total pages: ${totalPages}`);
        console.log(`üìã [API] Items on current page: ${paginatedQuizzes.length}`);
        // Log upcoming and expired quizzes specifically
        const upcomingQuizzes = processedQuizzes.filter((q)=>q.status === 'upcoming');
        const expiredQuizzes = processedQuizzes.filter((q)=>q.status === 'expired');
        if (upcomingQuizzes.length > 0) {
            console.log(`\nüîÆ [API] Upcoming quizzes (${upcomingQuizzes.length}):`);
            upcomingQuizzes.forEach((quiz)=>{
                console.log(`  üìù ${quiz.title} - Start: ${quiz.startDate}, End: ${quiz.endDate}`);
            });
        }
        if (expiredQuizzes.length > 0) {
            console.log(`\n‚è∞ [API] Expired quizzes (${expiredQuizzes.length}):`);
            expiredQuizzes.forEach((quiz)=>{
                console.log(`  üìù ${quiz.title} - Start: ${quiz.startDate}, End: ${quiz.endDate}`);
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                items: paginatedQuizzes,
                totalItems,
                totalPages,
                currentPage: page,
                pageSize: limit
            }
        });
    } catch (error) {
        console.error("[API] Error fetching quizzes:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            message: "Failed to fetch quizzes"
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__74fbb4b4._.js.map
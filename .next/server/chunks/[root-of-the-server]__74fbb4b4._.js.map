{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const db = globalThis.prisma || new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\r\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\r\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\r\nimport { db } from \"@/lib/db\"\r\nimport GoogleProvider from \"next-auth/providers/google\"\r\nimport { ROLES, RoleType } from \"@/lib/constants\"\r\n\r\n// Domain email được ủy quyền cao hơn\r\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\r\n\r\n// Fix cho type adapter\r\nconst prismaAdapter = PrismaAdapter(db) as any\r\n\r\n// Cải thiện error handling\r\nconst handleAuthError = (error: any, context: string) => {\r\n  console.error(`[Auth Error] ${context}:`, error);\r\n  return false;\r\n}\r\n\r\nexport const authOptions: AuthOptions = {\r\n  adapter: prismaAdapter,\r\n  providers: [\r\n    GoogleProvider({\r\n      clientId: process.env.GOOGLE_CLIENT_ID!,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\r\n      allowDangerousEmailAccountLinking: true,\r\n    }),\r\n  ],\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 24 * 60 * 60, // 24 hours\r\n    updateAge: 4 * 60 * 60, // 4 hours\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user, account, profile, trigger }) {\r\n      try {\r\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\r\n        if (user) {\r\n          // Đảm bảo role có thể null\r\n          token.role = user.role as RoleType | null;\r\n          token.id = user.id;\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\r\n        if (trigger === 'update' && token?.sub) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { \r\n                id: true, \r\n                name: true, \r\n                email: true, \r\n                role: true, \r\n                image: true \r\n              }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              // Cập nhật token với giá trị mới\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.name = dbUser.name;\r\n              token.email = dbUser.email;\r\n              token.picture = dbUser.image;\r\n              \r\n              // Thêm timestamp để đảm bảo không cache token cũ\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error updating token:\", error);\r\n          }\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\r\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { role: true }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error refreshing token:\", error);\r\n          }\r\n        }\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        console.error(\"JWT callback error:\", error);\r\n        return token;\r\n      }\r\n    },\r\n    async session({ session, token }) {\r\n      try {\r\n        if (session.user && token) {\r\n          // Đảm bảo role có thể null\r\n          session.user.role = token.role as RoleType | null;\r\n          session.user.id = token.id as string;\r\n        }\r\n        return session;\r\n      } catch (error) {\r\n        console.error(\"Session callback error:\", error);\r\n        return session;\r\n      }\r\n    },\r\n    async signIn({ user, account, profile }) {\r\n      // Nếu user có email\r\n      if (user?.email) {\r\n        try {\r\n          // Kiểm tra user đã tồn tại chưa\r\n          const existingUser = await db.user.findUnique({\r\n            where: { email: user.email },\r\n          })\r\n          \r\n          if (!existingUser) {\r\n            // Tạo user mới không có role (null) để người dùng chọn sau\r\n            await db.user.create({\r\n              data: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                image: user.image,\r\n                role: null, // Không thiết lập role mặc định\r\n              },\r\n            })\r\n            \r\n            // Đánh dấu để redirect tới trang chọn role\r\n            return true\r\n          }\r\n          \r\n          return true\r\n        } catch (error) {\r\n          return handleAuthError(error, \"signIn callback\");\r\n        }\r\n      }\r\n      \r\n      return true\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/auth/signin',\r\n    signOut: '/',\r\n    error: '/auth/error',\r\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n  debug: process.env.NODE_ENV === \"development\",\r\n  logger: {\r\n    error(code, ...message) {\r\n      console.error(`[NextAuth Error] ${code}:`, ...message);\r\n    },\r\n    warn(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\r\n      }\r\n    },\r\n    debug(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\r\n      }\r\n    },\r\n  },\r\n}\r\n\r\nconst handler = NextAuth(authOptions)\r\nexport { handler as GET, handler as POST }\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\r\n\r\n// Re-export với tên khác để không phá vỡ code đang sử dụng\r\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/users/me/quizzes/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    // Get the authenticated user\r\n    const session = await getServerSession(authOptions);\r\n    if (!session?.user) {\r\n      return NextResponse.json({ success: false, message: \"Authentication required\" }, { status: 401 });\r\n    }\r\n\r\n    const userId = session.user.id;\r\n    \r\n    // Parse query parameters\r\n    const searchParams = req.nextUrl.searchParams;\r\n    const search = searchParams.get(\"search\");\r\n    const requestedStatus = searchParams.get(\"status\");  // ✅ TÊN MỚI ĐỂ TRÁNH XUNG ĐỘT\r\n    const classId = searchParams.get(\"classId\");\r\n    const subject = searchParams.get(\"subject\");\r\n    const startDateFrom = searchParams.get(\"startDateFrom\");\r\n    const endDateTo = searchParams.get(\"endDateTo\");\r\n    const sortBy = searchParams.get(\"sortBy\") || \"startDate\";\r\n    const sortOrder = searchParams.get(\"sortOrder\") || \"asc\";\r\n    \r\n    // Pagination\r\n    const page = parseInt(searchParams.get(\"page\") || \"1\");\r\n    const limit = parseInt(searchParams.get(\"limit\") || \"9\");\r\n    const skip = (page - 1) * limit;\r\n    \r\n    // Build filters object for Prisma query\r\n    const filters: any = {\r\n      // Only show published quizzes\r\n      isPublished: true,\r\n      \r\n      OR: [\r\n        // 1. Quiz từ các lớp học sinh viên đã tham gia (đã enrolled)\r\n        {\r\n          class: {\r\n            students: {\r\n              some: {\r\n                studentId: userId\r\n              }\r\n            }\r\n          }\r\n        },\r\n        // 2. Quiz công khai (isPublic = true)\r\n        { isPublic: true }\r\n      ]\r\n    };\r\n    \r\n    // Thêm log để kiểm tra\r\n    console.log(`\\n🔍 [API] Fetching quizzes for student: ${userId}`);\r\n    console.log(`📋 [API] Filters:`, JSON.stringify(filters, null, 2));\r\n    console.log(`🎯 [API] Requested status filter: ${requestedStatus}`);\r\n    console.log(`📄 [API] Pagination: page ${page}, limit ${limit}, skip ${skip}`);\r\n    \r\n    // ❌ BỎ LOGIC FILTER SAI NÀY - NÓ LOẠI BỎ TẤT CẢ QUIZ UPCOMING VÀ AVAILABLE\r\n    // Quiz status sẽ được tính toán và filter sau trong processing logic\r\n    // Không nên filter isPublished và isActive ở đây vì nó sẽ loại bỏ quiz cần thiết\r\n    \r\n    // Search filter - index-based search optimization\r\n    if (search) {\r\n      filters.OR = [\r\n        ...filters.OR, // Giữ lại các điều kiện OR hiện có\r\n        { title: { contains: search, mode: \"insensitive\" } },\r\n        { description: { contains: search, mode: \"insensitive\" } }\r\n      ];\r\n    }\r\n    \r\n    // Class filter\r\n    if (classId && classId !== \"all\") {\r\n      filters.classId = classId;\r\n    }\r\n    \r\n    // Subject filter - more direct filtering\r\n    if (subject && subject !== \"all\") {\r\n      // Need to adjust the OR clause to ensure class subject is considered\r\n      filters.class = {\r\n        subject,\r\n      };\r\n    }\r\n    \r\n    // Date filters\r\n    if (startDateFrom) {\r\n      filters.startDate = {\r\n        ...filters.startDate,\r\n        gte: new Date(startDateFrom)\r\n      };\r\n    }\r\n    \r\n    if (endDateTo) {\r\n      filters.endDate = {\r\n        ...filters.endDate,\r\n        lte: new Date(endDateTo)\r\n      };\r\n    }\r\n    \r\n    // Get current date\r\n    const now = new Date();\r\n    \r\n    // Determine sort direction\r\n    const direction = sortOrder === \"desc\" ? \"desc\" : \"asc\";\r\n    \r\n    // Determine sort field\r\n    let orderBy: any = [];\r\n    switch (sortBy) {\r\n      case \"title\":\r\n        orderBy.push({ title: direction });\r\n        break;\r\n      case \"endDate\":\r\n        orderBy.push({ endDate: direction });\r\n        break;\r\n      case \"startDate\":\r\n      default:\r\n        orderBy.push({ startDate: direction });\r\n    }\r\n    // Always add id as secondary sort for consistency\r\n    orderBy.push({ id: \"asc\" });\r\n    \r\n    // Status filter optimization - apply if needed\r\n    let statusFilter = requestedStatus && requestedStatus !== \"all\" ? requestedStatus : null;\r\n    \r\n    // ⚠️ IMPORTANT: Don't pre-filter at database level for status\r\n    // The status calculation is complex and depends on user attempts\r\n    // We need to fetch all quizzes and then filter by status in JavaScript\r\n    // Only apply basic database filters that are clearly safe\r\n    \r\n    if (statusFilter) {\r\n      // Only apply very basic database filters that won't interfere with status calculation\r\n      switch (statusFilter) {\r\n        case \"expired\":\r\n          // Only filter for definitely expired quizzes (endDate in past)\r\n          // But don't filter out others since a quiz might be \"completed\" vs \"expired\"\r\n          // depending on user attempts\r\n          // We'll handle this in the JavaScript processing instead\r\n          break;\r\n        case \"upcoming\":\r\n        case \"ongoing\": \r\n        case \"completed\":\r\n        default:\r\n          // Don't apply database-level filtering for these statuses\r\n          // They require complex logic based on user attempts\r\n          break;\r\n      }\r\n    }\r\n    \r\n    // Fetch ALL quizzes first (without pagination) to properly calculate status\r\n    // We need to do this because status filtering happens in JavaScript, not in database\r\n    const allQuizzes = await prisma.quiz.findMany({\r\n      where: filters,\r\n      include: {\r\n        class: {\r\n          select: {\r\n            name: true,\r\n            subject: true\r\n          }\r\n        },\r\n        attempts: {\r\n          where: {\r\n            userId\r\n          },\r\n          select: {\r\n            id: true,\r\n            score: true,\r\n            completedAt: true\r\n          }\r\n        },\r\n        _count: {\r\n          select: {\r\n            questions: true\r\n          }\r\n        }\r\n      },\r\n      orderBy\r\n    });\r\n    \r\n    console.log(`\\n📊 [API] Database query results:`);\r\n    console.log(`📈 [API] Total quizzes found: ${allQuizzes.length}`);\r\n    \r\n    // Process quizzes to determine status and transform data\r\n    const processedQuizzes = allQuizzes.map((quiz) => {\r\n      // Calculate quiz status based on dates and attempts\r\n      let status: \"upcoming\" | \"ongoing\" | \"completed\" | \"expired\" = \"ongoing\";\r\n      const startDate = quiz.startDate;\r\n      const endDate = quiz.endDate;\r\n      const hasAttempts = quiz.attempts.length > 0;\r\n      const hasCompletedAttempt = quiz.attempts.some((a) => a.completedAt !== null);\r\n      \r\n      // Debug logging for status calculation\r\n      console.log(`Quiz ${quiz.id} - ${quiz.title}:`, {\r\n        startDate: startDate?.toISOString(),\r\n        endDate: endDate?.toISOString(),\r\n        now: now.toISOString(),\r\n        hasAttempts,\r\n        hasCompletedAttempt,\r\n        maxAttempts: quiz.maxAttempts\r\n      });\r\n      \r\n      // More precise status logic\r\n      const hasStarted = !startDate || startDate <= now;\r\n      const hasExpired = endDate && endDate < now;\r\n      \r\n      if (!hasStarted) {\r\n        // Quiz has not started yet (startDate exists and is in future)\r\n        status = \"upcoming\";\r\n        console.log(`Quiz ${quiz.id} status: upcoming (not started)`);\r\n      } else if (hasExpired) {\r\n        // Quiz has ended - distinguish between completed and expired\r\n        if (hasCompletedAttempt) {\r\n          status = \"completed\";\r\n          console.log(`Quiz ${quiz.id} status: completed (ended with completed attempt)`);\r\n        } else {\r\n          status = \"expired\";\r\n          console.log(`Quiz ${quiz.id} status: expired (ended without completion)`);\r\n        }\r\n      } else if (hasCompletedAttempt && quiz.maxAttempts && quiz.attempts.length >= quiz.maxAttempts) {\r\n        // Quiz is still open but user has completed all allowed attempts\r\n        status = \"completed\";\r\n        console.log(`Quiz ${quiz.id} status: completed (max attempts reached)`);\r\n      } else {\r\n        // Quiz is currently open and available\r\n        status = \"ongoing\";\r\n        console.log(`Quiz ${quiz.id} status: ongoing (available now)`);\r\n      }\r\n      \r\n      // Calculate highest score from attempts - more efficient calculation\r\n      let highestScore = null;\r\n      if (hasCompletedAttempt) {\r\n        const scores = quiz.attempts\r\n          .filter((a) => a.completedAt !== null && a.score !== null)\r\n          .map((a) => a.score || 0);\r\n          \r\n        highestScore = scores.length ? Math.max(...scores) : null;\r\n      }\r\n      \r\n      // Check if quiz is locked (formal class check)\r\n      const userWithRoles = session.user as any;\r\n      const isFormal = quiz.tags?.includes(\"formal\") || false;\r\n      const isLocked = \r\n        (isFormal && !userWithRoles.formalStudent) ||\r\n        (quiz.maxAttempts !== null && quiz.attempts.length >= quiz.maxAttempts && !hasCompletedAttempt);\r\n      \r\n      // Generate lock reason\r\n      let lockReason = \"\";\r\n      if (isLocked) {\r\n        if (isFormal && !userWithRoles.formalStudent) {\r\n          lockReason = \"This quiz is only available to formal class students\";\r\n        } else if (quiz.maxAttempts !== null && quiz.attempts.length >= quiz.maxAttempts) {\r\n          lockReason = \"You have reached the maximum number of attempts\";\r\n        }\r\n      }\r\n\r\n      return {\r\n        id: quiz.id,\r\n        title: quiz.title,\r\n        description: quiz.description,\r\n        classId: quiz.classId,\r\n        className: quiz.class?.name || null,\r\n        subject: quiz.class?.subject || null,\r\n        startDate: quiz.startDate?.toISOString() || null,\r\n        endDate: quiz.endDate?.toISOString() || null,\r\n        durationMinutes: quiz.timeLimit,\r\n        totalQuestions: quiz._count.questions,\r\n        status,\r\n        isLocked,\r\n        lockReason,\r\n        isFormal,\r\n        attemptLimit: quiz.maxAttempts,\r\n        currentAttempts: quiz.attempts.length,\r\n        highestScore\r\n      };\r\n    }).filter((quiz): quiz is NonNullable<typeof quiz> => quiz !== null); // Remove filtered out quizzes (null values) with proper typing\r\n    \r\n    // Filter by status AFTER processing all quizzes\r\n    const filteredQuizzes = requestedStatus && requestedStatus !== \"all\" \r\n      ? processedQuizzes.filter((quiz) => quiz.status === requestedStatus)\r\n      : processedQuizzes;\r\n\r\n    // Apply pagination AFTER filtering\r\n    const totalItems = filteredQuizzes.length;\r\n    const totalPages = Math.max(1, Math.ceil(totalItems / limit));\r\n    const startIndex = skip;\r\n    const endIndex = startIndex + limit;\r\n    const paginatedQuizzes = filteredQuizzes.slice(startIndex, endIndex);\r\n    \r\n    // Log final results summary\r\n    const statusSummary = processedQuizzes.reduce((acc, quiz) => {\r\n      acc[quiz.status] = (acc[quiz.status] || 0) + 1;\r\n      return acc;\r\n    }, {} as Record<string, number>);\r\n    \r\n    console.log(`\\n📋 [API] Final results summary:`);\r\n    console.log(`🎯 [API] Status filter requested: ${requestedStatus || 'none'}`);\r\n    console.log(`📊 [API] Status distribution:`, statusSummary);\r\n    console.log(`📈 [API] Total items after filtering: ${totalItems}`);\r\n    console.log(`📄 [API] Total pages: ${totalPages}`);\r\n    console.log(`📋 [API] Items on current page: ${paginatedQuizzes.length}`);\r\n    \r\n    // Log upcoming and expired quizzes specifically\r\n    const upcomingQuizzes = processedQuizzes.filter((q) => q.status === 'upcoming');\r\n    const expiredQuizzes = processedQuizzes.filter((q) => q.status === 'expired');\r\n    \r\n    if (upcomingQuizzes.length > 0) {\r\n      console.log(`\\n🔮 [API] Upcoming quizzes (${upcomingQuizzes.length}):`);\r\n      upcomingQuizzes.forEach((quiz) => {\r\n        console.log(`  📝 ${quiz.title} - Start: ${quiz.startDate}, End: ${quiz.endDate}`);\r\n      });\r\n    }\r\n    \r\n    if (expiredQuizzes.length > 0) {\r\n      console.log(`\\n⏰ [API] Expired quizzes (${expiredQuizzes.length}):`);\r\n      expiredQuizzes.forEach((quiz) => {\r\n        console.log(`  📝 ${quiz.title} - Start: ${quiz.startDate}, End: ${quiz.endDate}`);\r\n      });\r\n    }\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      data: {\r\n        items: paginatedQuizzes,\r\n        totalItems,\r\n        totalPages,\r\n        currentPage: page,\r\n        pageSize: limit\r\n      }\r\n    });\r\n    \r\n  } catch (error) {\r\n    console.error(\"[API] Error fetching quizzes:\", error);\r\n    return NextResponse.json(\r\n      { success: false, message: \"Failed to fetch quizzes\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,IAAI,GAAgB;IACxC,IAAI;QACF,6BAA6B;QAC7B,MAAM,UAAU,MAAM,CAAA,GAAA,uIAAA,CAAA,mBAAgB,AAAD,EAAE,mJAAA,CAAA,cAAW;QAClD,IAAI,CAAC,SAAS,MAAM;YAClB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAO,SAAS;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjG;QAEA,MAAM,SAAS,QAAQ,IAAI,CAAC,EAAE;QAE9B,yBAAyB;QACzB,MAAM,eAAe,IAAI,OAAO,CAAC,YAAY;QAC7C,MAAM,SAAS,aAAa,GAAG,CAAC;QAChC,MAAM,kBAAkB,aAAa,GAAG,CAAC,WAAY,8BAA8B;QACnF,MAAM,UAAU,aAAa,GAAG,CAAC;QACjC,MAAM,UAAU,aAAa,GAAG,CAAC;QACjC,MAAM,gBAAgB,aAAa,GAAG,CAAC;QACvC,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,SAAS,aAAa,GAAG,CAAC,aAAa;QAC7C,MAAM,YAAY,aAAa,GAAG,CAAC,gBAAgB;QAEnD,aAAa;QACb,MAAM,OAAO,SAAS,aAAa,GAAG,CAAC,WAAW;QAClD,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QACpD,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;QAE1B,wCAAwC;QACxC,MAAM,UAAe;YACnB,8BAA8B;YAC9B,aAAa;YAEb,IAAI;gBACF,6DAA6D;gBAC7D;oBACE,OAAO;wBACL,UAAU;4BACR,MAAM;gCACJ,WAAW;4BACb;wBACF;oBACF;gBACF;gBACA,sCAAsC;gBACtC;oBAAE,UAAU;gBAAK;aAClB;QACH;QAEA,uBAAuB;QACvB,QAAQ,GAAG,CAAC,CAAC,yCAAyC,EAAE,QAAQ;QAChE,QAAQ,GAAG,CAAC,CAAC,iBAAiB,CAAC,EAAE,KAAK,SAAS,CAAC,SAAS,MAAM;QAC/D,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,iBAAiB;QAClE,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,KAAK,QAAQ,EAAE,MAAM,OAAO,EAAE,MAAM;QAE7E,2EAA2E;QAC3E,qEAAqE;QACrE,iFAAiF;QAEjF,kDAAkD;QAClD,IAAI,QAAQ;YACV,QAAQ,EAAE,GAAG;mBACR,QAAQ,EAAE;gBACb;oBAAE,OAAO;wBAAE,UAAU;wBAAQ,MAAM;oBAAc;gBAAE;gBACnD;oBAAE,aAAa;wBAAE,UAAU;wBAAQ,MAAM;oBAAc;gBAAE;aAC1D;QACH;QAEA,eAAe;QACf,IAAI,WAAW,YAAY,OAAO;YAChC,QAAQ,OAAO,GAAG;QACpB;QAEA,yCAAyC;QACzC,IAAI,WAAW,YAAY,OAAO;YAChC,qEAAqE;YACrE,QAAQ,KAAK,GAAG;gBACd;YACF;QACF;QAEA,eAAe;QACf,IAAI,eAAe;YACjB,QAAQ,SAAS,GAAG;gBAClB,GAAG,QAAQ,SAAS;gBACpB,KAAK,IAAI,KAAK;YAChB;QACF;QAEA,IAAI,WAAW;YACb,QAAQ,OAAO,GAAG;gBAChB,GAAG,QAAQ,OAAO;gBAClB,KAAK,IAAI,KAAK;YAChB;QACF;QAEA,mBAAmB;QACnB,MAAM,MAAM,IAAI;QAEhB,2BAA2B;QAC3B,MAAM,YAAY,cAAc,SAAS,SAAS;QAElD,uBAAuB;QACvB,IAAI,UAAe,EAAE;QACrB,OAAQ;YACN,KAAK;gBACH,QAAQ,IAAI,CAAC;oBAAE,OAAO;gBAAU;gBAChC;YACF,KAAK;gBACH,QAAQ,IAAI,CAAC;oBAAE,SAAS;gBAAU;gBAClC;YACF,KAAK;YACL;gBACE,QAAQ,IAAI,CAAC;oBAAE,WAAW;gBAAU;QACxC;QACA,kDAAkD;QAClD,QAAQ,IAAI,CAAC;YAAE,IAAI;QAAM;QAEzB,+CAA+C;QAC/C,IAAI,eAAe,mBAAmB,oBAAoB,QAAQ,kBAAkB;QAEpF,8DAA8D;QAC9D,iEAAiE;QACjE,uEAAuE;QACvE,0DAA0D;QAE1D,IAAI,cAAc;YAChB,sFAAsF;YACtF,OAAQ;gBACN,KAAK;oBAKH;gBACF,KAAK;gBACL,KAAK;gBACL,KAAK;gBACL;oBAGE;YACJ;QACF;QAEA,4EAA4E;QAC5E,qFAAqF;QACrF,MAAM,aAAa,MAAM,+GAAA,CAAA,SAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC5C,OAAO;YACP,SAAS;gBACP,OAAO;oBACL,QAAQ;wBACN,MAAM;wBACN,SAAS;oBACX;gBACF;gBACA,UAAU;oBACR,OAAO;wBACL;oBACF;oBACA,QAAQ;wBACN,IAAI;wBACJ,OAAO;wBACP,aAAa;oBACf;gBACF;gBACA,QAAQ;oBACN,QAAQ;wBACN,WAAW;oBACb;gBACF;YACF;YACA;QACF;QAEA,QAAQ,GAAG,CAAC,CAAC,kCAAkC,CAAC;QAChD,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,WAAW,MAAM,EAAE;QAEhE,yDAAyD;QACzD,MAAM,mBAAmB,WAAW,GAAG,CAAC,CAAC;YACvC,oDAAoD;YACpD,IAAI,SAA2D;YAC/D,MAAM,YAAY,KAAK,SAAS;YAChC,MAAM,UAAU,KAAK,OAAO;YAC5B,MAAM,cAAc,KAAK,QAAQ,CAAC,MAAM,GAAG;YAC3C,MAAM,sBAAsB,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,WAAW,KAAK;YAExE,uCAAuC;YACvC,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE;gBAC9C,WAAW,WAAW;gBACtB,SAAS,SAAS;gBAClB,KAAK,IAAI,WAAW;gBACpB;gBACA;gBACA,aAAa,KAAK,WAAW;YAC/B;YAEA,4BAA4B;YAC5B,MAAM,aAAa,CAAC,aAAa,aAAa;YAC9C,MAAM,aAAa,WAAW,UAAU;YAExC,IAAI,CAAC,YAAY;gBACf,+DAA+D;gBAC/D,SAAS;gBACT,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,+BAA+B,CAAC;YAC9D,OAAO,IAAI,YAAY;gBACrB,6DAA6D;gBAC7D,IAAI,qBAAqB;oBACvB,SAAS;oBACT,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,iDAAiD,CAAC;gBAChF,OAAO;oBACL,SAAS;oBACT,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,2CAA2C,CAAC;gBAC1E;YACF,OAAO,IAAI,uBAAuB,KAAK,WAAW,IAAI,KAAK,QAAQ,CAAC,MAAM,IAAI,KAAK,WAAW,EAAE;gBAC9F,iEAAiE;gBACjE,SAAS;gBACT,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,yCAAyC,CAAC;YACxE,OAAO;gBACL,uCAAuC;gBACvC,SAAS;gBACT,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,gCAAgC,CAAC;YAC/D;YAEA,qEAAqE;YACrE,IAAI,eAAe;YACnB,IAAI,qBAAqB;gBACvB,MAAM,SAAS,KAAK,QAAQ,CACzB,MAAM,CAAC,CAAC,IAAM,EAAE,WAAW,KAAK,QAAQ,EAAE,KAAK,KAAK,MACpD,GAAG,CAAC,CAAC,IAAM,EAAE,KAAK,IAAI;gBAEzB,eAAe,OAAO,MAAM,GAAG,KAAK,GAAG,IAAI,UAAU;YACvD;YAEA,+CAA+C;YAC/C,MAAM,gBAAgB,QAAQ,IAAI;YAClC,MAAM,WAAW,KAAK,IAAI,EAAE,SAAS,aAAa;YAClD,MAAM,WACJ,AAAC,YAAY,CAAC,cAAc,aAAa,IACxC,KAAK,WAAW,KAAK,QAAQ,KAAK,QAAQ,CAAC,MAAM,IAAI,KAAK,WAAW,IAAI,CAAC;YAE7E,uBAAuB;YACvB,IAAI,aAAa;YACjB,IAAI,UAAU;gBACZ,IAAI,YAAY,CAAC,cAAc,aAAa,EAAE;oBAC5C,aAAa;gBACf,OAAO,IAAI,KAAK,WAAW,KAAK,QAAQ,KAAK,QAAQ,CAAC,MAAM,IAAI,KAAK,WAAW,EAAE;oBAChF,aAAa;gBACf;YACF;YAEA,OAAO;gBACL,IAAI,KAAK,EAAE;gBACX,OAAO,KAAK,KAAK;gBACjB,aAAa,KAAK,WAAW;gBAC7B,SAAS,KAAK,OAAO;gBACrB,WAAW,KAAK,KAAK,EAAE,QAAQ;gBAC/B,SAAS,KAAK,KAAK,EAAE,WAAW;gBAChC,WAAW,KAAK,SAAS,EAAE,iBAAiB;gBAC5C,SAAS,KAAK,OAAO,EAAE,iBAAiB;gBACxC,iBAAiB,KAAK,SAAS;gBAC/B,gBAAgB,KAAK,MAAM,CAAC,SAAS;gBACrC;gBACA;gBACA;gBACA;gBACA,cAAc,KAAK,WAAW;gBAC9B,iBAAiB,KAAK,QAAQ,CAAC,MAAM;gBACrC;YACF;QACF,GAAG,MAAM,CAAC,CAAC,OAA2C,SAAS,OAAO,+DAA+D;QAErI,gDAAgD;QAChD,MAAM,kBAAkB,mBAAmB,oBAAoB,QAC3D,iBAAiB,MAAM,CAAC,CAAC,OAAS,KAAK,MAAM,KAAK,mBAClD;QAEJ,mCAAmC;QACnC,MAAM,aAAa,gBAAgB,MAAM;QACzC,MAAM,aAAa,KAAK,GAAG,CAAC,GAAG,KAAK,IAAI,CAAC,aAAa;QACtD,MAAM,aAAa;QACnB,MAAM,WAAW,aAAa;QAC9B,MAAM,mBAAmB,gBAAgB,KAAK,CAAC,YAAY;QAE3D,4BAA4B;QAC5B,MAAM,gBAAgB,iBAAiB,MAAM,CAAC,CAAC,KAAK;YAClD,GAAG,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI;YAC7C,OAAO;QACT,GAAG,CAAC;QAEJ,QAAQ,GAAG,CAAC,CAAC,iCAAiC,CAAC;QAC/C,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,mBAAmB,QAAQ;QAC5E,QAAQ,GAAG,CAAC,CAAC,6BAA6B,CAAC,EAAE;QAC7C,QAAQ,GAAG,CAAC,CAAC,sCAAsC,EAAE,YAAY;QACjE,QAAQ,GAAG,CAAC,CAAC,sBAAsB,EAAE,YAAY;QACjD,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,iBAAiB,MAAM,EAAE;QAExE,gDAAgD;QAChD,MAAM,kBAAkB,iBAAiB,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK;QACpE,MAAM,iBAAiB,iBAAiB,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK;QAEnE,IAAI,gBAAgB,MAAM,GAAG,GAAG;YAC9B,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,gBAAgB,MAAM,CAAC,EAAE,CAAC;YACtE,gBAAgB,OAAO,CAAC,CAAC;gBACvB,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,KAAK,CAAC,UAAU,EAAE,KAAK,SAAS,CAAC,OAAO,EAAE,KAAK,OAAO,EAAE;YACnF;QACF;QAEA,IAAI,eAAe,MAAM,GAAG,GAAG;YAC7B,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,eAAe,MAAM,CAAC,EAAE,CAAC;YACnE,eAAe,OAAO,CAAC,CAAC;gBACtB,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,KAAK,CAAC,UAAU,EAAE,KAAK,SAAS,CAAC,OAAO,EAAE,KAAK,OAAO,EAAE;YACnF;QACF;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,MAAM;gBACJ,OAAO;gBACP;gBACA;gBACA,aAAa;gBACb,UAAU;YACZ;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,SAAS;QAA0B,GACrD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}
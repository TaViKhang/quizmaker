module.exports = {

"[project]/.next-internal/server/app/api/attempts/[id]/complete/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/@prisma/client/runtime/library [external] (@prisma/client/runtime/library, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client/runtime/library", () => require("@prisma/client/runtime/library"));

module.exports = mod;
}}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}}),
"[project]/lib/db.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "db": (()=>db)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const db = globalThis.prisma || new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]();
if ("TURBOPACK compile-time truthy", 1) globalThis.prisma = db;
}}),
"[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>handler),
    "POST": (()=>handler),
    "authOptions": (()=>authOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/prisma-adapter/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/google.js [app-route] (ecmascript)");
;
;
;
;
// Domain email được ủy quyền cao hơn
const AUTHORIZED_TEACHER_DOMAINS = [
    'school.edu',
    'university.edu',
    'teacher.org'
];
// Fix cho type adapter
const prismaAdapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PrismaAdapter"])(__TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"]);
// Cải thiện error handling
const handleAuthError = (error, context)=>{
    console.error(`[Auth Error] ${context}:`, error);
    return false;
};
const authOptions = {
    adapter: prismaAdapter,
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true
        })
    ],
    session: {
        strategy: "jwt",
        maxAge: 24 * 60 * 60,
        updateAge: 4 * 60 * 60
    },
    callbacks: {
        async jwt ({ token, user, account, profile, trigger }) {
            try {
                // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập
                if (user) {
                    // Đảm bảo role có thể null
                    token.role = user.role;
                    token.id = user.id;
                    return token;
                }
                // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng
                if (trigger === 'update' && token?.sub) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                id: true,
                                name: true,
                                email: true,
                                role: true,
                                image: true
                            }
                        });
                        if (dbUser) {
                            // Cập nhật token với giá trị mới
                            token.role = dbUser.role;
                            token.name = dbUser.name;
                            token.email = dbUser.email;
                            token.picture = dbUser.image;
                            // Thêm timestamp để đảm bảo không cache token cũ
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error updating token:", error);
                    }
                    return token;
                }
                // Trường hợp token từ session: kiểm tra nếu cần cập nhật
                if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt || 0) > 60 * 1000)) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                role: true
                            }
                        });
                        if (dbUser) {
                            token.role = dbUser.role;
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error refreshing token:", error);
                    }
                }
                return token;
            } catch (error) {
                console.error("JWT callback error:", error);
                return token;
            }
        },
        async session ({ session, token }) {
            try {
                if (session.user && token) {
                    // Đảm bảo role có thể null
                    session.user.role = token.role;
                    session.user.id = token.id;
                }
                return session;
            } catch (error) {
                console.error("Session callback error:", error);
                return session;
            }
        },
        async signIn ({ user, account, profile }) {
            // Nếu user có email
            if (user?.email) {
                try {
                    // Kiểm tra user đã tồn tại chưa
                    const existingUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                        where: {
                            email: user.email
                        }
                    });
                    if (!existingUser) {
                        // Tạo user mới không có role (null) để người dùng chọn sau
                        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.create({
                            data: {
                                id: user.id,
                                email: user.email,
                                name: user.name,
                                image: user.image,
                                role: null
                            }
                        });
                        // Đánh dấu để redirect tới trang chọn role
                        return true;
                    }
                    return true;
                } catch (error) {
                    return handleAuthError(error, "signIn callback");
                }
            }
            return true;
        }
    },
    pages: {
        signIn: '/auth/signin',
        signOut: '/',
        error: '/auth/error',
        newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role
    },
    secret: process.env.NEXTAUTH_SECRET,
    debug: ("TURBOPACK compile-time value", "development") === "development",
    logger: {
        error (code, ...message) {
            console.error(`[NextAuth Error] ${code}:`, ...message);
        },
        warn (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn(`[NextAuth Warning] ${code}:`, ...message);
            }
        },
        debug (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.debug(`[NextAuth Debug] ${code}:`, ...message);
            }
        }
    }
};
const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(authOptions);
;
}}),
"[project]/lib/prisma.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prisma": (()=>prisma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
;
const prisma = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"];
}}),
"[project]/lib/utils.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cn": (()=>cn),
    "formatDuration": (()=>formatDuration),
    "generateRandomCode": (()=>generateRandomCode),
    "getSafeTheme": (()=>getSafeTheme),
    "normalizeMetadata": (()=>normalizeMetadata),
    "prepareMetadataForDB": (()=>prepareMetadataForDB)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$lib$2f$tw$2d$merge$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tailwind-merge/dist/lib/tw-merge.mjs [app-route] (ecmascript)");
;
;
function cn(...inputs) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$lib$2f$tw$2d$merge$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["twMerge"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["clsx"])(inputs));
}
function getSafeTheme(theme, mounted) {
    if (!mounted) return null;
    return theme || null;
}
function generateRandomCode(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for(let i = 0; i < length; i++){
        code += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return code;
}
function formatDuration(ms) {
    if (!ms || ms <= 0) return "0 minutes";
    const seconds = Math.floor(ms / 1000 % 60);
    const minutes = Math.floor(ms / (1000 * 60) % 60);
    const hours = Math.floor(ms / (1000 * 60 * 60));
    const parts = [];
    if (hours > 0) {
        parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);
    }
    if (minutes > 0) {
        parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);
    }
    if (seconds > 0 && hours === 0) {
        parts.push(`${seconds} ${seconds === 1 ? 'second' : 'seconds'}`);
    }
    return parts.join(' ');
}
function normalizeMetadata(metadata) {
    // Return null for falsy values (undefined, null, empty string, etc.)
    if (!metadata) return null;
    try {
        // If metadata is already an object, return it directly with type assertion
        if (typeof metadata === 'object' && metadata !== null && !Array.isArray(metadata)) {
            // Remove null/undefined values for consistency
            const cleanedMetadata = Object.fromEntries(Object.entries(metadata).filter(([_, v])=>v !== null && v !== undefined));
            return cleanedMetadata;
        }
        // If metadata is a string, try to parse it as JSON
        if (typeof metadata === 'string') {
            try {
                const parsed = JSON.parse(metadata);
                // Ensure the parsed result is actually an object
                if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
                    // Clean up null/undefined values
                    const cleanedMetadata = Object.fromEntries(Object.entries(parsed).filter(([_, v])=>v !== null && v !== undefined));
                    return cleanedMetadata;
                }
                // If parsed but not an object, return null
                return null;
            } catch (parseError) {
                console.warn("Failed to parse metadata string:", parseError);
                return null;
            }
        }
        // For all other types (number, boolean, etc.), return null
        return null;
    } catch (error) {
        console.error("Failed to normalize metadata:", error);
        return null;
    }
}
function prepareMetadataForDB(metadata) {
    if (!metadata) return null;
    try {
        // Remove null/undefined properties
        const cleanMetadata = Object.fromEntries(Object.entries(metadata).filter(([_, v])=>v !== null && v !== undefined));
        // Check if any properties remain
        if (Object.keys(cleanMetadata).length === 0) {
            return null;
        }
        return JSON.stringify(cleanMetadata);
    } catch (error) {
        console.error("Failed to prepare metadata for DB:", error);
        return null;
    }
}
}}),
"[project]/lib/question-utils.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getCodeMetadata": (()=>getCodeMetadata),
    "getDefaultMetadata": (()=>getDefaultMetadata),
    "getEssayMetadata": (()=>getEssayMetadata),
    "getFillBlankMetadata": (()=>getFillBlankMetadata),
    "getMatchingMetadata": (()=>getMatchingMetadata),
    "getMultipleChoiceMetadata": (()=>getMultipleChoiceMetadata),
    "getQuestionTypeLabel": (()=>getQuestionTypeLabel),
    "getShortAnswerMetadata": (()=>getShortAnswerMetadata),
    "getTypedMetadata": (()=>getTypedMetadata),
    "normalizeMetadata": (()=>normalizeMetadata),
    "normalizeQuestion": (()=>normalizeQuestion),
    "shuffleArray": (()=>shuffleArray)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
function shuffleArray(array) {
    if (!array || array.length === 0) return [];
    const newArray = [
        ...array
    ];
    for(let i = newArray.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [
            newArray[j],
            newArray[i]
        ];
    }
    return newArray;
}
function normalizeMetadata(metadata) {
    if (!metadata) return null;
    // If metadata is already an object, return it
    if (typeof metadata === 'object' && !Array.isArray(metadata) && metadata !== null) {
        return metadata;
    }
    // If metadata is a string, try to parse it
    if (typeof metadata === 'string') {
        try {
            // Check if the string is valid JSON
            if (metadata.trim().startsWith('{') || metadata.trim().startsWith('[')) {
                return JSON.parse(metadata);
            } else {
                console.warn("Metadata string is not valid JSON:", metadata);
                return null;
            }
        } catch (e) {
            console.error("Error parsing metadata string:", e);
            return null;
        }
    }
    // For unexpected types, log and return null
    console.warn("Unexpected metadata type:", typeof metadata);
    return null;
}
function getDefaultMetadata(questionType) {
    switch(questionType){
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MULTIPLE_CHOICE:
            return {
                allowMultiple: false,
                shuffleOptions: false
            };
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].ESSAY:
            return {
                minWords: null,
                maxWords: null,
                placeholder: "",
                richText: false
            };
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].SHORT_ANSWER:
            return {
                caseSensitive: false,
                placeholder: ""
            };
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].FILL_BLANK:
            return {
                text: "",
                caseSensitive: false
            };
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].CODE:
            return {
                language: "javascript",
                initialCode: "",
                testCases: []
            };
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MATCHING:
            return {
                shuffleOptions: false
            };
        default:
            return {};
    }
}
function normalizeQuestion(question) {
    // Clone question to avoid mutating the original
    const normalizedQuestion = {
        ...question
    };
    // Normalize metadata
    const normalizedMetadata = normalizeMetadata(question.metadata) || getDefaultMetadata(question.type);
    return {
        ...normalizedQuestion,
        metadata: normalizedMetadata
    };
}
function getTypedMetadata(question) {
    if (!question.metadata) return null;
    try {
        const normalizedMetadata = normalizeMetadata(question.metadata);
        return normalizedMetadata;
    } catch (e) {
        console.error("Error getting typed metadata:", e);
        return null;
    }
}
function getMultipleChoiceMetadata(question) {
    // Default values for multiple choice metadata
    const defaultMetadata = {
        allowMultiple: false,
        shuffleOptions: false,
        allowPartialCredit: true
    };
    // Guard clause for when metadata is completely absent
    if (!question || !question.metadata) {
        return defaultMetadata;
    }
    // Try to normalize the metadata first
    let metadata = normalizeMetadata(question.metadata);
    // If normalization fails, return default
    if (!metadata) {
        return defaultMetadata;
    }
    // Create result by merging default with whatever we can extract
    const result = {
        ...defaultMetadata
    };
    // Handle both naming conventions for multiple answers
    if (typeof metadata.allowMultiple !== 'undefined') {
        result.allowMultiple = Boolean(metadata.allowMultiple);
    } else if (typeof metadata.allowMultipleAnswers !== 'undefined') {
        result.allowMultiple = Boolean(metadata.allowMultipleAnswers);
    }
    // Handle shuffle options setting
    if (typeof metadata.shuffleOptions !== 'undefined') {
        result.shuffleOptions = Boolean(metadata.shuffleOptions);
    }
    // Handle partial credit setting, defaulting to true if undefined
    if (typeof metadata.allowPartialCredit !== 'undefined') {
        result.allowPartialCredit = Boolean(metadata.allowPartialCredit);
    }
    return result;
}
function getEssayMetadata(question) {
    return getTypedMetadata(question) || {
        minWords: undefined,
        maxWords: undefined,
        placeholder: undefined,
        richText: false
    };
}
function getShortAnswerMetadata(question) {
    return getTypedMetadata(question) || {
        caseSensitive: false,
        placeholder: undefined
    };
}
function getFillBlankMetadata(question) {
    return getTypedMetadata(question) || {
        text: "",
        caseSensitive: false
    };
}
function getCodeMetadata(question) {
    return getTypedMetadata(question) || {
        language: "javascript",
        initialCode: undefined,
        testCases: undefined
    };
}
function getMatchingMetadata(question) {
    return getTypedMetadata(question) || {
        shuffleOptions: false
    };
}
function getQuestionTypeLabel(type) {
    switch(type){
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MULTIPLE_CHOICE:
            return "Multiple Choice";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].TRUE_FALSE:
            return "True/False";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].ESSAY:
            return "Essay";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].SHORT_ANSWER:
            return "Short Answer";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MATCHING:
            return "Matching";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].FILL_BLANK:
            return "Fill in the Blanks";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].CODE:
            return "Code";
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].FILE_UPLOAD:
            return "File Upload";
        default:
            return type;
    }
}
}}),
"[project]/lib/answer-grading.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "gradeAnswer": (()=>gradeAnswer),
    "gradeFillBlankQuestion": (()=>gradeFillBlankQuestion),
    "gradeMatchingQuestion": (()=>gradeMatchingQuestion),
    "gradeMultipleChoiceAnswer": (()=>gradeMultipleChoiceAnswer)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/question-utils.ts [app-route] (ecmascript)");
;
;
async function gradeAnswer(question, answer) {
    switch(question.type){
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MULTIPLE_CHOICE:
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].TRUE_FALSE:
            return gradeMultipleChoiceQuestion(question, answer);
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].SHORT_ANSWER:
            return gradeShortAnswerQuestion(question, answer);
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].FILL_BLANK:
            return gradeFillBlankQuestion(question, answer);
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MATCHING:
            return gradeMatchingQuestion(question, answer);
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].CODE:
            return gradeCodeQuestion(question, answer);
        case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].ESSAY:
        default:
            // Manual grading required
            return {
                isCorrect: false,
                score: 0,
                needsManualGrading: true
            };
    }
}
/**
 * Grade multiple-choice or true/false questions
 */ function gradeMultipleChoiceQuestion(question, answer) {
    const metadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getMultipleChoiceMetadata"])(question);
    // Get the allowMultiple setting, checking both property names for compatibility
    let allowMultiple = metadata.allowMultiple;
    // Check if we have allowMultipleAnswers directly on the question (not in metadata)
    if (!allowMultiple && question.metadata) {
        if (typeof question.metadata === 'object' && 'allowMultipleAnswers' in question.metadata) {
            allowMultiple = Boolean(question.metadata.allowMultipleAnswers);
        }
    }
    const questionPoints = question.points || 1;
    if (!question.options || question.options.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "Question has no options defined"
        };
    }
    const correctOptionIds = question.options.filter((option)=>option.isCorrect).map((option)=>option.id);
    if (correctOptionIds.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "Question has no correct options defined"
        };
    }
    // Get selected options from answer
    const selectedOptionIds = answer.selectedOptions || [];
    // Use the new direct grading function with the extracted data
    const result = gradeMultipleChoiceAnswer(selectedOptionIds, correctOptionIds, questionPoints, allowMultiple, metadata.allowPartialCredit !== false, question.options.length);
    // Convert SimpleGradingResult to GradingResult
    return {
        isCorrect: result.isCorrect === null ? false : result.isCorrect,
        score: result.score === null ? 0 : result.score,
        needsManualGrading: false,
        feedback: result.feedback || undefined
    };
}
/**
 * Grade short answer questions
 */ function gradeShortAnswerQuestion(question, answer) {
    if (!answer.textAnswer) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: false
        };
    }
    const questionPoints = question.points || 1;
    const metadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getShortAnswerMetadata"])(question);
    const caseSensitive = metadata.caseSensitive;
    // Get all correct answers from options
    const correctOptions = question.options?.filter((option)=>option.isCorrect) || [];
    if (correctOptions.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "Question has no correct answers defined"
        };
    }
    // Normalize answers based on case sensitivity
    const normalizeAnswer = (text)=>caseSensitive ? text.trim() : text.trim().toLowerCase();
    const userAnswer = normalizeAnswer(answer.textAnswer);
    // Check if any correct option matches the user's answer
    const isCorrect = correctOptions.some((option)=>{
        const correctAnswer = normalizeAnswer(option.content);
        return userAnswer === correctAnswer;
    });
    return {
        isCorrect,
        score: isCorrect ? questionPoints : 0,
        needsManualGrading: false
    };
}
function gradeFillBlankQuestion(question, answer) {
    const questionPoints = question.points || 1;
    const metadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getFillBlankMetadata"])(question);
    const caseSensitive = metadata.caseSensitive;
    // Get expected answers from options
    const blanks = question.options?.filter((opt)=>opt.position !== null && opt.position !== undefined) || [];
    if (blanks.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "Question has no blank positions defined"
        };
    }
    let userBlankAnswers = {};
    if (answer.jsonData && typeof answer.jsonData === 'string') {
        try {
            const parsedData = JSON.parse(answer.jsonData);
            if (typeof parsedData === 'object' && parsedData !== null) {
                // Safely build userBlankAnswers Record<string, string>
                for(const key in parsedData){
                    if (Object.prototype.hasOwnProperty.call(parsedData, key) && typeof parsedData[key] === 'string') {
                        userBlankAnswers[key] = parsedData[key];
                    }
                }
            } else {
                // jsonData parsed, but not into an object suitable for blank answers
                return {
                    isCorrect: false,
                    score: 0,
                    needsManualGrading: false,
                    feedback: "Invalid answer data format for fill-in-the-blank (not an object)."
                };
            }
        } catch (e) {
            console.error("Error parsing jsonData in fill-blank question:", e);
            return {
                isCorrect: false,
                score: 0,
                needsManualGrading: false,
                feedback: "Invalid answer data format for fill-in-the-blank (JSON parse failed)."
            };
        }
    } else if (answer.jsonData) {
        // jsonData exists but is not a string, which is unexpected based on Answer interface
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: false,
            feedback: "Invalid answer data type for fill-in-the-blank (expected JSON string)."
        };
    }
    // If no jsonData, userBlankAnswers will be an empty object, leading to 0 correctCount
    // Normalize answers based on case sensitivity
    const normalizeAnswer = (text)=>caseSensitive ? text.trim() : text.trim().toLowerCase();
    // Check each blank
    let correctCount = 0;
    for (const blank of blanks){
        // Ensure blank.position is not null or undefined before converting to string
        if (blank.position === null || blank.position === undefined) continue;
        const positionKey = blank.position.toString();
        const userAnswerText = userBlankAnswers[positionKey];
        if (!userAnswerText) continue; // No answer provided for this blank
        const expectedAnswer = normalizeAnswer(blank.content);
        const normalizedUserAnswer = normalizeAnswer(userAnswerText);
        if (normalizedUserAnswer === expectedAnswer) {
            correctCount++;
        }
    }
    // Calculate score based on proportion of correct answers
    const proportion = blanks.length > 0 ? correctCount / blanks.length : 0;
    const score = Math.round(questionPoints * proportion);
    const isCorrect = blanks.length > 0 && correctCount === blanks.length;
    return {
        isCorrect,
        score,
        needsManualGrading: false,
        feedback: isCorrect ? undefined : `${correctCount}/${blanks.length} correct answers`
    };
}
function gradeMatchingQuestion(question, answer) {
    const questionPoints = question.points || 1;
    // Group options - support both premise/response and legacy left/right
    const premiseOptions = question.options?.filter((opt)=>opt.group === 'premise' || opt.group === 'left') || [];
    const responseOptions = question.options?.filter((opt)=>opt.group === 'response' || opt.group === 'right') || [];
    if (premiseOptions.length === 0 || responseOptions.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "Question has no premise or response options defined"
        };
    }
    // Get correct matches from options
    // Ensure premiseOption.id and premiseOption.matchId are valid strings
    const correctMatches = {};
    for (const premiseOption of premiseOptions){
        if (premiseOption.id && typeof premiseOption.id === 'string' && premiseOption.matchId && typeof premiseOption.matchId === 'string') {
            // Find the actual response option that this premise should match to
            const matchingResponse = responseOptions.find((response)=>response.id === premiseOption.matchId);
            if (matchingResponse && matchingResponse.id && typeof matchingResponse.id === 'string') {
                correctMatches[premiseOption.id] = matchingResponse.id;
            }
        }
    }
    // If no correct matches are defined in the question setup, it needs manual grading or review
    if (Object.keys(correctMatches).length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "No correct matches defined for this question. Please check question setup."
        };
    }
    let userAnswers = {};
    if (answer.jsonData && typeof answer.jsonData === 'string') {
        try {
            const parsedData = JSON.parse(answer.jsonData);
            if (typeof parsedData === 'object' && parsedData !== null) {
                // Safely build userAnswers Record<string, string>
                const tempUserAnswers = {};
                let allValuesAreStrings = true;
                for(const key in parsedData){
                    if (Object.prototype.hasOwnProperty.call(parsedData, key)) {
                        if (typeof parsedData[key] === 'string') {
                            tempUserAnswers[key] = parsedData[key];
                        } else {
                            allValuesAreStrings = false;
                            break;
                        }
                    }
                }
                if (allValuesAreStrings) {
                    userAnswers = tempUserAnswers;
                } else {
                    return {
                        isCorrect: false,
                        score: 0,
                        needsManualGrading: false,
                        feedback: "Invalid answer data format (some values are not strings)."
                    };
                }
            } else {
                // jsonData parsed, but not into an object
                return {
                    isCorrect: false,
                    score: 0,
                    needsManualGrading: false,
                    feedback: "Invalid answer data format (not an object)."
                };
            }
        } catch (e) {
            console.error("Error parsing jsonData in matching question:", e);
            return {
                isCorrect: false,
                score: 0,
                needsManualGrading: false,
                feedback: "Invalid answer data format (JSON parse failed)."
            };
        }
    } else {
        // No jsonData provided in the answer or it's not a string
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: false,
            feedback: "No valid answer data provided."
        };
    }
    let correctUserMatchCount = 0;
    // Iterate over the *defined correct matches* from the question setup
    for (const [definedPremiseId, definedResponseId] of Object.entries(correctMatches)){
        // Check if the user's answer for this premise matches the defined correct response
        if (userAnswers[definedPremiseId] === definedResponseId) {
            correctUserMatchCount++;
        }
    }
    const totalPossibleCorrectMatches = Object.keys(correctMatches).length;
    // Calculate score based on proportion of correct matches
    // Ensure no division by zero if totalPossibleCorrectMatches is somehow 0 (though caught above)
    const proportion = totalPossibleCorrectMatches > 0 ? correctUserMatchCount / totalPossibleCorrectMatches : 0;
    const score = Math.round(questionPoints * proportion);
    const isCorrect = correctUserMatchCount === totalPossibleCorrectMatches;
    return {
        isCorrect,
        score,
        needsManualGrading: false,
        feedback: isCorrect ? "All matches correct." : `${correctUserMatchCount}/${totalPossibleCorrectMatches} correct matches`
    };
}
/**
 * Grade code questions
 * Note: Real implementation would likely use a sandbox environment to run code
 */ function gradeCodeQuestion(question, answer) {
    if (!answer.textAnswer) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: false
        };
    }
    // Get question points
    const questionPoints = question.points || 1;
    const userCode = answer.textAnswer;
    // Try to parse metadata for expected output or test cases
    let expectedOutput = [];
    let testCases = [];
    let requiredKeywords = [];
    let prohibitedKeywords = [];
    try {
        // Extract metadata for code grading
        if (question.metadata) {
            const metadata = typeof question.metadata === 'string' ? JSON.parse(question.metadata) : question.metadata;
            expectedOutput = metadata.expectedOutput || [];
            testCases = metadata.testCases || [];
            requiredKeywords = metadata.requiredKeywords || [];
            prohibitedKeywords = metadata.prohibitedKeywords || [];
        }
    } catch (error) {
        console.error("Error parsing code question metadata:", error);
    }
    // Get expected keywords from options marked as correct
    const keywordsFromOptions = question.options?.filter((opt)=>opt.isCorrect).map((opt)=>opt.content.toLowerCase()) || [];
    // Merge with required keywords from metadata
    requiredKeywords = [
        ...requiredKeywords,
        ...keywordsFromOptions
    ];
    // If no grading criteria defined, require manual grading
    if (requiredKeywords.length === 0 && prohibitedKeywords.length === 0 && expectedOutput.length === 0 && testCases.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            needsManualGrading: true,
            feedback: "No automated grading criteria defined"
        };
    }
    // Initialize scoring variables
    let totalCriteria = 0;
    let passedCriteria = 0;
    let feedbackDetails = [];
    // Check for required keywords
    if (requiredKeywords.length > 0) {
        totalCriteria += requiredKeywords.length;
        const userCodeLower = userCode.toLowerCase();
        const matchedKeywords = requiredKeywords.filter((keyword)=>userCodeLower.includes(keyword.toLowerCase()));
        passedCriteria += matchedKeywords.length;
        if (matchedKeywords.length < requiredKeywords.length) {
            feedbackDetails.push(`Found ${matchedKeywords.length}/${requiredKeywords.length} required elements`);
        }
    }
    // Check for prohibited keywords
    if (prohibitedKeywords.length > 0) {
        totalCriteria += prohibitedKeywords.length;
        const userCodeLower = userCode.toLowerCase();
        const avoidedKeywords = prohibitedKeywords.filter((keyword)=>!userCodeLower.includes(keyword.toLowerCase()));
        passedCriteria += avoidedKeywords.length;
        if (avoidedKeywords.length < prohibitedKeywords.length) {
            feedbackDetails.push(`Used ${prohibitedKeywords.length - avoidedKeywords.length} prohibited elements`);
        }
    }
    // Check expected output if provided
    // Note: In a real implementation, this would execute the code in a sandbox
    // Here we're just doing a simple check if the output appears in the code
    if (expectedOutput.length > 0) {
        totalCriteria += expectedOutput.length;
        const userCodeLower = userCode.toLowerCase();
        const matchedOutputs = expectedOutput.filter((output)=>userCodeLower.includes(output.toLowerCase()));
        passedCriteria += matchedOutputs.length;
        if (matchedOutputs.length < expectedOutput.length) {
            feedbackDetails.push(`Code likely produces ${matchedOutputs.length}/${expectedOutput.length} expected outputs`);
        }
    }
    // Calculate score based on proportion of passed criteria
    const proportion = totalCriteria > 0 ? passedCriteria / totalCriteria : 0;
    const score = Math.round(questionPoints * proportion);
    const isCorrect = totalCriteria > 0 && passedCriteria === totalCriteria;
    // Always require manual grading for code questions
    return {
        isCorrect,
        score,
        needsManualGrading: true,
        feedback: feedbackDetails.length > 0 ? `Automatic pre-grading: ${feedbackDetails.join("; ")}` : `Automatic pre-grading: ${passedCriteria}/${totalCriteria} criteria met`
    };
}
function gradeMultipleChoiceAnswer(selectedOptions, correctOptions, maxPoints, allowMultiple = false, allowPartialCredit = true, totalOptionsCount = 0) {
    // Handle empty selections
    if (selectedOptions.length === 0) {
        return {
            isCorrect: false,
            score: 0,
            feedback: "No answer selected"
        };
    }
    // For single-choice questions (traditional MCQ)
    if (!allowMultiple) {
        // If more than one option selected for single-choice question
        if (selectedOptions.length > 1) {
            return {
                isCorrect: false,
                score: 0,
                feedback: "Multiple options selected for a single-choice question"
            };
        }
        // Check if the selected option is correct
        const isCorrect = correctOptions.includes(selectedOptions[0]);
        return {
            isCorrect,
            score: isCorrect ? maxPoints : 0,
            feedback: isCorrect ? "Correct answer" : "Incorrect answer"
        };
    }
    // For multiple-choice questions
    // Count correct selections and incorrect selections
    const selectedCorrectCount = selectedOptions.filter((id)=>correctOptions.includes(id)).length;
    const selectedIncorrectCount = selectedOptions.filter((id)=>!correctOptions.includes(id)).length;
    // Perfect answer: all correct options selected and no incorrect options
    const allCorrectSelected = selectedCorrectCount === correctOptions.length;
    const noIncorrectSelected = selectedIncorrectCount === 0;
    const isCorrect = allCorrectSelected && noIncorrectSelected;
    // Calculate score
    if (isCorrect) {
        // Full credit for perfect answer
        return {
            isCorrect: true,
            score: maxPoints,
            feedback: "All correct answers selected"
        };
    } else if (allowPartialCredit) {
        // Calculate partial credit
        // Start with proportion of correct options selected
        let partialScore = selectedCorrectCount / correctOptions.length * maxPoints;
        // Apply penalty for incorrect selections
        if (selectedIncorrectCount > 0 && totalOptionsCount > 0) {
            const penalty = selectedIncorrectCount / totalOptionsCount * maxPoints;
            partialScore = Math.max(0, partialScore - penalty);
        }
        const roundedScore = Math.round(partialScore);
        let feedback = "";
        if (selectedCorrectCount === 0) {
            feedback = "No correct answers selected";
        } else if (!allCorrectSelected && noIncorrectSelected) {
            feedback = "Some correct answers missed";
        } else if (allCorrectSelected && !noIncorrectSelected) {
            feedback = "All correct answers selected but with additional incorrect answers";
        } else {
            feedback = "Partially correct answer";
        }
        return {
            isCorrect: false,
            score: roundedScore,
            feedback
        };
    } else {
        // No partial credit
        return {
            isCorrect: false,
            score: 0,
            feedback: "Answer is incorrect (no partial credit)"
        };
    }
}
}}),
"[project]/app/api/attempts/[id]/complete/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "POST": (()=>POST)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/utils.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$answer$2d$grading$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/answer-grading.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/question-utils.ts [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
async function POST(request, { params }) {
    try {
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getServerSession"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
        if (!session?.user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                message: "Unauthorized"
            }, {
                status: 401
            });
        }
        const attemptId = params.id;
        const attempt = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quizAttempt.findUnique({
            where: {
                id: attemptId,
                userId: session.user.id,
                completedAt: null // Only complete if not already completed
            },
            include: {
                quiz: {
                    include: {
                        questions: {
                            include: {
                                options: true
                            }
                        }
                    }
                },
                answers: true
            }
        });
        if (!attempt) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                message: "Attempt not found or already completed"
            }, {
                status: 404
            });
        }
        // Get the current time for completion timestamp
        const now = new Date();
        const startTime = attempt.startedAt;
        const timeSpent = Math.round((now.getTime() - startTime.getTime()) / 1000); // In seconds
        // Grade answers and calculate total score
        let totalScore = 0;
        let totalPossibleScore = 0;
        let gradedAnswers = 0;
        let questionsWithAnswers = 0;
        // Create a map for questions for easy lookup
        const questionsMap = new Map();
        attempt.quiz.questions.forEach((q)=>questionsMap.set(q.id, q));
        // Grade all answers
        for (const answer of attempt.answers){
            const question = questionsMap.get(answer.questionId);
            if (!question) continue;
            questionsWithAnswers++;
            const points = question.points || 1;
            totalPossibleScore += points;
            // Skip if already graded
            if (answer.isCorrect !== null && answer.score !== null) {
                gradedAnswers++;
                if (answer.score !== null) {
                    totalScore += answer.score;
                }
                continue;
            }
            // Auto-grade based on question type
            let isCorrect = null;
            let score = null;
            switch(question.type){
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MULTIPLE_CHOICE:
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].TRUE_FALSE:
                    // Use selectedOptionIds if available, otherwise try to parse from textAnswer for legacy support
                    let selectedOptionIds = answer.selectedOptionIds || [];
                    if (selectedOptionIds.length === 0 && answer.selectedOption) {
                        // Legacy support - convert single selectedOption to array
                        selectedOptionIds = [
                            answer.selectedOption
                        ];
                    }
                    // Get metadata to determine if multiple selections are allowed
                    const metadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeMetadata"])(question.metadata) || {};
                    const allowMultiple = metadata.allowMultiple || metadata.allowMultipleAnswers || false;
                    const allowPartialCredit = metadata.allowPartialCredit !== false; // Default to true
                    // Get correct options
                    const correctOptions = question.options.filter((o)=>o.isCorrect);
                    const correctOptionIds = correctOptions.map((o)=>o.id);
                    // Use gradeMultipleChoiceAnswer function from lib/answer-grading.ts
                    const gradingResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$answer$2d$grading$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gradeMultipleChoiceAnswer"])(selectedOptionIds, correctOptionIds, points, allowMultiple, allowPartialCredit, question.options.length);
                    isCorrect = gradingResult.isCorrect;
                    score = gradingResult.score;
                    break;
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].SHORT_ANSWER:
                    // Short answer requires exact match with correct options
                    if (answer.textAnswer && question.options.length > 0) {
                        const metadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeMetadata"])(question.metadata) || {};
                        const caseSensitive = metadata.caseSensitive || false;
                        // Get correct answers from options
                        const correctAnswers = question.options.filter((o)=>o.isCorrect).map((o)=>o.content);
                        if (caseSensitive) {
                            isCorrect = correctAnswers.includes(answer.textAnswer);
                        } else {
                            isCorrect = correctAnswers.some((a)=>a.toLowerCase() === (answer.textAnswer || '').toLowerCase());
                        }
                        score = isCorrect ? points : 0;
                    } else {
                        isCorrect = false;
                        score = 0;
                    }
                    break;
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MATCHING:
                    if (answer.textAnswer) {
                        try {
                            const normalizedAnswerForMatching = {
                                questionId: answer.questionId,
                                selectedOptions: [],
                                textAnswer: "",
                                jsonData: answer.textAnswer
                            };
                            const matchingGradingResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$answer$2d$grading$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gradeMatchingQuestion"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeQuestion"])(question), normalizedAnswerForMatching);
                            isCorrect = matchingGradingResult.isCorrect;
                            score = matchingGradingResult.score;
                            if (matchingGradingResult.feedback) {
                                await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].answer.update({
                                    where: {
                                        id: answer.id
                                    },
                                    data: {
                                        feedback: matchingGradingResult.feedback
                                    }
                                });
                            }
                        } catch (error) {
                            console.error("Error grading matching question:", error);
                            isCorrect = null;
                            score = null;
                        }
                    } else {
                        isCorrect = false;
                        score = 0;
                    }
                    break;
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].FILL_BLANK:
                    if (answer.textAnswer) {
                        try {
                            const normalizedAnswerForFillBlank = {
                                questionId: answer.questionId,
                                selectedOptions: [],
                                textAnswer: "",
                                jsonData: answer.textAnswer
                            };
                            const fillBlankGradingResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$answer$2d$grading$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["gradeFillBlankQuestion"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$question$2d$utils$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeQuestion"])(question), normalizedAnswerForFillBlank);
                            isCorrect = fillBlankGradingResult.isCorrect;
                            score = fillBlankGradingResult.score;
                            if (fillBlankGradingResult.feedback) {
                                await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].answer.update({
                                    where: {
                                        id: answer.id
                                    },
                                    data: {
                                        feedback: fillBlankGradingResult.feedback
                                    }
                                });
                            }
                        } catch (error) {
                            console.error("Error grading fill_blank question:", error);
                            isCorrect = null;
                            score = null;
                        }
                    } else {
                        isCorrect = false;
                        score = 0;
                    }
                    break;
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].CODE:
                case __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].ESSAY:
                    isCorrect = null;
                    score = null;
                    break;
                default:
                    isCorrect = null;
                    score = null;
            }
            // Update answer with grading results if it was auto-graded
            if (isCorrect !== null && score !== null) {
                await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].answer.update({
                    where: {
                        id: answer.id
                    },
                    data: {
                        isCorrect,
                        score
                    }
                });
                gradedAnswers++;
                totalScore += score;
            }
        }
        // Calculate final score as a percentage
        const finalScore = totalPossibleScore > 0 ? Math.round(totalScore / totalPossibleScore * 100) : 0;
        // Update the attempt to mark it as completed
        const completedAttempt = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quizAttempt.update({
            where: {
                id: attemptId
            },
            data: {
                completedAt: now,
                score: finalScore,
                timeSpent: timeSpent
            }
        });
        // Return the completion data
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            data: {
                id: completedAttempt.id,
                score: completedAttempt.score,
                timeSpent: completedAttempt.timeSpent,
                completedAt: completedAttempt.completedAt,
                totalQuestions: attempt.quiz.questions.length,
                answeredQuestions: questionsWithAnswers,
                gradedQuestions: gradedAnswers,
                needsManualGrading: questionsWithAnswers > gradedAnswers
            }
        });
    } catch (error) {
        console.error("Error completing attempt:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            message: "Error completing attempt",
            error: error instanceof Error ? error.message : String(error)
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__9785f039._.js.map
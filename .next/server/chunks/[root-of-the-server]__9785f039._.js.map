{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n/**\n * Safely access theme state to avoid hydration errors\n * This is useful for conditionally rendering theme-dependent UI\n * \n * @param theme Current theme from useTheme hook\n * @param mounted Boolean indicating if component is mounted\n * @returns Safe theme value or null if not mounted\n */\nexport function getSafeTheme(\n  theme: string | undefined, \n  mounted: boolean\n): \"light\" | \"dark\" | \"system\" | null {\n  if (!mounted) return null\n  return (theme as \"light\" | \"dark\" | \"system\") || null\n}\n\n/**\n * Generate a random alphanumeric code of specified length\n * @param length Length of the code to generate\n * @returns Random alphanumeric string\n */\nexport function generateRandomCode(length: number): string {\n  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  let code = '';\n  \n  for (let i = 0; i < length; i++) {\n    code += characters.charAt(Math.floor(Math.random() * characters.length));\n  }\n  \n  return code;\n}\n\n/**\n * Format duration in milliseconds to a human-readable string\n * @param ms Duration in milliseconds\n * @returns Formatted duration string (e.g., \"1h 30m\" or \"45m\")\n */\nexport function formatDuration(ms: number): string {\n  if (!ms || ms <= 0) return \"0 minutes\";\n  \n  const seconds = Math.floor((ms / 1000) % 60);\n  const minutes = Math.floor((ms / (1000 * 60)) % 60);\n  const hours = Math.floor((ms / (1000 * 60 * 60)));\n  \n  const parts = [];\n  \n  if (hours > 0) {\n    parts.push(`${hours} ${hours === 1 ? 'hour' : 'hours'}`);\n  }\n  \n  if (minutes > 0) {\n    parts.push(`${minutes} ${minutes === 1 ? 'minute' : 'minutes'}`);\n  }\n  \n  if (seconds > 0 && hours === 0) {\n    parts.push(`${seconds} ${seconds === 1 ? 'second' : 'seconds'}`);\n  }\n  \n  return parts.join(' ');\n}\n\n/**\n * Normalize metadata to ensure correct format\n * @param metadata Metadata object or string to normalize\n * @returns Normalized object or null if invalid\n */\nexport function normalizeMetadata<T extends Record<string, any> = Record<string, any>>(metadata: unknown): T | null {\n  // Return null for falsy values (undefined, null, empty string, etc.)\n  if (!metadata) return null;\n  \n  try {\n    // If metadata is already an object, return it directly with type assertion\n    if (typeof metadata === 'object' && metadata !== null && !Array.isArray(metadata)) {\n      // Remove null/undefined values for consistency\n      const cleanedMetadata = Object.fromEntries(\n        Object.entries(metadata as Record<string, any>).filter(([_, v]) => v !== null && v !== undefined)\n      );\n      \n      return cleanedMetadata as T;\n    }\n    \n    // If metadata is a string, try to parse it as JSON\n    if (typeof metadata === 'string') {\n      try {\n        const parsed = JSON.parse(metadata);\n        \n        // Ensure the parsed result is actually an object\n        if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {\n          // Clean up null/undefined values\n          const cleanedMetadata = Object.fromEntries(\n            Object.entries(parsed).filter(([_, v]) => v !== null && v !== undefined)\n          );\n          \n          return cleanedMetadata as T;\n        }\n        \n        // If parsed but not an object, return null\n        return null;\n      } catch (parseError) {\n        console.warn(\"Failed to parse metadata string:\", parseError);\n        return null;\n    }\n    }\n    \n    // For all other types (number, boolean, etc.), return null\n    return null;\n  } catch (error) {\n    console.error(\"Failed to normalize metadata:\", error);\n    return null;\n  }\n}\n\n/**\n * Prepare metadata for database storage\n * @param metadata Metadata object to prepare\n * @returns Stringified metadata or null\n */\nexport function prepareMetadataForDB(metadata: Record<string, any> | null): string | null {\n  if (!metadata) return null;\n  \n  try {\n    // Remove null/undefined properties\n    const cleanMetadata = Object.fromEntries(\n      Object.entries(metadata).filter(([_, v]) => v !== null && v !== undefined)\n    );\n    \n    // Check if any properties remain\n    if (Object.keys(cleanMetadata).length === 0) {\n      return null;\n    }\n    \n    return JSON.stringify(cleanMetadata);\n  } catch (error) {\n    console.error(\"Failed to prepare metadata for DB:\", error);\n    return null;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/question-utils.ts"],"sourcesContent":["import { QuestionType } from \"@prisma/client\";\nimport { \n  MultipleChoiceMetadata,\n  EssayMetadata,\n  ShortAnswerMetadata,\n  FillBlankMetadata,\n  CodeMetadata,\n  MatchingMetadata,\n} from \"@/app/api/schemas/question-metadata-schemas\";\n\n/**\n * Interface for Question data structure\n */\nexport interface Question {\n  id: string;\n  content: string;\n  type: QuestionType;\n  points: number;\n  order: number;\n  explanation?: string | null;\n  metadata?: any | null;\n  mediaType?: string | null;\n  mediaUrl?: string | null;\n  options?: Option[];\n}\n\n/**\n * Interface for Option data structure\n */\nexport interface Option {\n  id: string;\n  content: string;\n  isCorrect: boolean;\n  order: number;\n  group?: string | null;\n  matchId?: string | null;\n  position?: number | null;\n}\n\n/**\n * Interface for Answer data structure\n */\nexport interface Answer {\n  questionId: string;\n  selectedOptions: string[];  // IDs of selected options\n  textAnswer: string;         // Text answer for essay/short answer/code\n  jsonData: string | null; // Complex data for matching/fill-blank questions (JSON string)\n}\n\n/**\n * Shuffles an array using Fisher-Yates algorithm\n * @param array The array to shuffle\n * @returns A new shuffled array\n */\nexport function shuffleArray<T>(array: T[]): T[] {\n  if (!array || array.length === 0) return [];\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n}\n\n/**\n * Normalize metadata from string or object format\n */\nexport function normalizeMetadata<T = any>(metadata: any): T | null {\n  if (!metadata) return null;\n  \n  // If metadata is already an object, return it\n  if (typeof metadata === 'object' && !Array.isArray(metadata) && metadata !== null) {\n    return metadata as T;\n  }\n  \n  // If metadata is a string, try to parse it\n  if (typeof metadata === 'string') {\n    try {\n      // Check if the string is valid JSON\n      if (metadata.trim().startsWith('{') || metadata.trim().startsWith('[')) {\n        return JSON.parse(metadata) as T;\n      } else {\n        console.warn(\"Metadata string is not valid JSON:\", metadata);\n        return null;\n      }\n    } catch (e) {\n      console.error(\"Error parsing metadata string:\", e);\n      return null;\n    }\n  }\n  \n  // For unexpected types, log and return null\n  console.warn(\"Unexpected metadata type:\", typeof metadata);\n  return null;\n}\n\n/**\n * Get default metadata structure based on question type\n */\nexport function getDefaultMetadata(questionType: QuestionType): any {\n  switch (questionType) {\n    case QuestionType.MULTIPLE_CHOICE:\n      return { allowMultiple: false, shuffleOptions: false };\n    \n    case QuestionType.ESSAY:\n      return { minWords: null, maxWords: null, placeholder: \"\", richText: false };\n    \n    case QuestionType.SHORT_ANSWER:\n      return { caseSensitive: false, placeholder: \"\" };\n    \n    case QuestionType.FILL_BLANK:\n      return { text: \"\", caseSensitive: false };\n    \n    case QuestionType.CODE:\n      return { language: \"javascript\", initialCode: \"\", testCases: [] };\n    \n    case QuestionType.MATCHING:\n      return { shuffleOptions: false };\n    \n    default:\n      return {};\n  }\n}\n\n/**\n * Normalize question data ensuring it has the correct metadata structure\n */\nexport function normalizeQuestion(question: Question): Question {\n  // Clone question to avoid mutating the original\n  const normalizedQuestion = { ...question };\n  \n  // Normalize metadata\n  const normalizedMetadata = normalizeMetadata(question.metadata) || \n    getDefaultMetadata(question.type);\n  \n  return {\n    ...normalizedQuestion,\n    metadata: normalizedMetadata\n  };\n}\n\n/**\n * Get type-specific metadata from a normalized question\n */\nexport function getTypedMetadata<T>(question: Question): T | null {\n  if (!question.metadata) return null;\n  \n  try {\n    const normalizedMetadata = normalizeMetadata<T>(question.metadata);\n    return normalizedMetadata;\n  } catch (e) {\n    console.error(\"Error getting typed metadata:\", e);\n    return null;\n  }\n}\n\n/**\n * Get multiple choice specific metadata\n * Improved to handle various metadata formats and provide stronger type safety\n */\nexport function getMultipleChoiceMetadata(question: Question): MultipleChoiceMetadata {\n  // Default values for multiple choice metadata\n  const defaultMetadata: MultipleChoiceMetadata = { \n    allowMultiple: false, \n    shuffleOptions: false, \n    allowPartialCredit: true \n  };\n  \n  // Guard clause for when metadata is completely absent\n  if (!question || !question.metadata) {\n    return defaultMetadata;\n  }\n  \n  // Try to normalize the metadata first\n  let metadata = normalizeMetadata<any>(question.metadata);\n  \n  // If normalization fails, return default\n  if (!metadata) {\n    return defaultMetadata;\n  }\n  \n  // Create result by merging default with whatever we can extract\n  const result: MultipleChoiceMetadata = { \n    ...defaultMetadata \n  };\n  \n  // Handle both naming conventions for multiple answers\n  if (typeof metadata.allowMultiple !== 'undefined') {\n    result.allowMultiple = Boolean(metadata.allowMultiple);\n  } else if (typeof metadata.allowMultipleAnswers !== 'undefined') {\n    result.allowMultiple = Boolean(metadata.allowMultipleAnswers);\n    }\n  \n  // Handle shuffle options setting\n  if (typeof metadata.shuffleOptions !== 'undefined') {\n    result.shuffleOptions = Boolean(metadata.shuffleOptions);\n  }\n  \n  // Handle partial credit setting, defaulting to true if undefined\n  if (typeof metadata.allowPartialCredit !== 'undefined') {\n    result.allowPartialCredit = Boolean(metadata.allowPartialCredit);\n  }\n  \n  return result;\n}\n\n/**\n * Get essay specific metadata\n */\nexport function getEssayMetadata(question: Question): EssayMetadata {\n  return getTypedMetadata<EssayMetadata>(question) || \n    { minWords: undefined, maxWords: undefined, placeholder: undefined, richText: false };\n}\n\n/**\n * Get short answer specific metadata\n */\nexport function getShortAnswerMetadata(question: Question): ShortAnswerMetadata {\n  return getTypedMetadata<ShortAnswerMetadata>(question) || \n    { caseSensitive: false, placeholder: undefined };\n}\n\n/**\n * Get fill-blank specific metadata\n */\nexport function getFillBlankMetadata(question: Question): FillBlankMetadata {\n  return getTypedMetadata<FillBlankMetadata>(question) || \n    { text: \"\", caseSensitive: false };\n}\n\n/**\n * Get code specific metadata\n */\nexport function getCodeMetadata(question: Question): CodeMetadata {\n  return getTypedMetadata<CodeMetadata>(question) || \n    { language: \"javascript\", initialCode: undefined, testCases: undefined };\n}\n\n/**\n * Get matching specific metadata\n */\nexport function getMatchingMetadata(question: Question): MatchingMetadata {\n  return getTypedMetadata<MatchingMetadata>(question) || \n    { shuffleOptions: false };\n}\n\n/**\n * Get the display label for a question type\n */\nexport function getQuestionTypeLabel(type: QuestionType): string {\n  switch (type) {\n    case QuestionType.MULTIPLE_CHOICE: return \"Multiple Choice\";\n    case QuestionType.TRUE_FALSE: return \"True/False\";\n    case QuestionType.ESSAY: return \"Essay\";\n    case QuestionType.SHORT_ANSWER: return \"Short Answer\";\n    case QuestionType.MATCHING: return \"Matching\";\n    case QuestionType.FILL_BLANK: return \"Fill in the Blanks\";\n    case QuestionType.CODE: return \"Code\";\n    case QuestionType.FILE_UPLOAD: return \"File Upload\";\n    default: return type;\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/answer-grading.ts"],"sourcesContent":["import { QuestionType } from \"@prisma/client\";\nimport { Question, Answer, Option } from \"./question-utils\";\nimport { \n  getMultipleChoiceMetadata,\n  getShortAnswerMetadata,\n  getFillBlankMetadata\n} from \"./question-utils\";\n\n/**\n * Result of grading an answer\n */\nexport interface GradingResult {\n  isCorrect: boolean;\n  score: number;\n  needsManualGrading: boolean;\n  feedback?: string;\n}\n\n/**\n * Result for the simplified direct grading function\n */\nexport interface SimpleGradingResult {\n  isCorrect: boolean | null;\n  score: number | null;\n  feedback?: string | null;\n}\n\n/**\n * Grade an answer for any question type\n */\nexport async function gradeAnswer(\n  question: Question, \n  answer: Answer\n): Promise<GradingResult> {\n  switch (question.type) {\n    case QuestionType.MULTIPLE_CHOICE:\n    case QuestionType.TRUE_FALSE:\n      return gradeMultipleChoiceQuestion(question, answer);\n    \n    case QuestionType.SHORT_ANSWER:\n      return gradeShortAnswerQuestion(question, answer);\n    \n    case QuestionType.FILL_BLANK:\n      return gradeFillBlankQuestion(question, answer);\n    \n    case QuestionType.MATCHING:\n      return gradeMatchingQuestion(question, answer);\n    \n    case QuestionType.CODE:\n      return gradeCodeQuestion(question, answer);\n    \n    case QuestionType.ESSAY:\n    default:\n      // Manual grading required\n      return {\n        isCorrect: false,\n        score: 0,\n        needsManualGrading: true\n      };\n  }\n}\n\n/**\n * Grade multiple-choice or true/false questions\n */\nfunction gradeMultipleChoiceQuestion(\n  question: Question, \n  answer: Answer\n): GradingResult {\n  const metadata = getMultipleChoiceMetadata(question);\n  \n  // Get the allowMultiple setting, checking both property names for compatibility\n  let allowMultiple = metadata.allowMultiple;\n  \n  // Check if we have allowMultipleAnswers directly on the question (not in metadata)\n  if (!allowMultiple && question.metadata) {\n    if (typeof question.metadata === 'object' && 'allowMultipleAnswers' in question.metadata) {\n      allowMultiple = Boolean(question.metadata.allowMultipleAnswers);\n    }\n  }\n  \n  const questionPoints = question.points || 1;\n  \n  if (!question.options || question.options.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true,\n      feedback: \"Question has no options defined\"\n    };\n  }\n  \n  const correctOptionIds = question.options\n    .filter(option => option.isCorrect)\n    .map(option => option.id);\n  \n  if (correctOptionIds.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true,\n      feedback: \"Question has no correct options defined\"\n    };\n  }\n  \n  // Get selected options from answer\n  const selectedOptionIds = answer.selectedOptions || [];\n    \n  // Use the new direct grading function with the extracted data\n  const result = gradeMultipleChoiceAnswer(\n    selectedOptionIds,\n    correctOptionIds,\n    questionPoints,\n    allowMultiple,\n    metadata.allowPartialCredit !== false,\n    question.options.length\n  );\n  \n  // Convert SimpleGradingResult to GradingResult\n    return {\n    isCorrect: result.isCorrect === null ? false : result.isCorrect,\n    score: result.score === null ? 0 : result.score,\n      needsManualGrading: false,\n    feedback: result.feedback || undefined\n    };\n}\n\n/**\n * Grade short answer questions\n */\nfunction gradeShortAnswerQuestion(\n  question: Question, \n  answer: Answer\n): GradingResult {\n  if (!answer.textAnswer) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: false\n    };\n  }\n  \n  const questionPoints = question.points || 1;\n  const metadata = getShortAnswerMetadata(question);\n  const caseSensitive = metadata.caseSensitive;\n  \n  // Get all correct answers from options\n  const correctOptions = question.options?.filter(option => option.isCorrect) || [];\n  \n  if (correctOptions.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true,\n      feedback: \"Question has no correct answers defined\"\n    };\n  }\n  \n  // Normalize answers based on case sensitivity\n  const normalizeAnswer = (text: string) => \n    caseSensitive ? text.trim() : text.trim().toLowerCase();\n  \n  const userAnswer = normalizeAnswer(answer.textAnswer);\n  \n  // Check if any correct option matches the user's answer\n  const isCorrect = correctOptions.some(option => {\n    const correctAnswer = normalizeAnswer(option.content);\n    return userAnswer === correctAnswer;\n  });\n  \n  return {\n    isCorrect,\n    score: isCorrect ? questionPoints : 0,\n    needsManualGrading: false\n  };\n}\n\n/**\n * Grade fill-in-the-blank questions\n */\nexport function gradeFillBlankQuestion(\n  question: Question, \n  answer: Answer\n): GradingResult {\n  const questionPoints = question.points || 1;\n  const metadata = getFillBlankMetadata(question);\n  const caseSensitive = metadata.caseSensitive;\n  \n  // Get expected answers from options\n  const blanks = question.options?.filter(\n    opt => opt.position !== null && opt.position !== undefined\n  ) || [];\n  \n  if (blanks.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true,\n      feedback: \"Question has no blank positions defined\"\n    };\n  }\n\n  let userBlankAnswers: Record<string, string> = {};\n  if (answer.jsonData && typeof answer.jsonData === 'string') {\n    try {\n      const parsedData = JSON.parse(answer.jsonData);\n      if (typeof parsedData === 'object' && parsedData !== null) {\n        // Safely build userBlankAnswers Record<string, string>\n        for (const key in parsedData) {\n          if (Object.prototype.hasOwnProperty.call(parsedData, key) && typeof parsedData[key] === 'string') {\n            userBlankAnswers[key] = parsedData[key];\n          }\n        }\n      } else {\n        // jsonData parsed, but not into an object suitable for blank answers\n        return {\n          isCorrect: false,\n          score: 0,\n          needsManualGrading: false,\n          feedback: \"Invalid answer data format for fill-in-the-blank (not an object).\"\n        };\n      }\n    } catch (e) {\n      console.error(\"Error parsing jsonData in fill-blank question:\", e);\n      return {\n        isCorrect: false,\n        score: 0,\n        needsManualGrading: false,\n        feedback: \"Invalid answer data format for fill-in-the-blank (JSON parse failed).\"\n      };\n    }\n  } else if (answer.jsonData) { \n    // jsonData exists but is not a string, which is unexpected based on Answer interface\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: false,\n      feedback: \"Invalid answer data type for fill-in-the-blank (expected JSON string).\"\n    };\n  }\n  // If no jsonData, userBlankAnswers will be an empty object, leading to 0 correctCount\n  \n  // Normalize answers based on case sensitivity\n  const normalizeAnswer = (text: string) => \n    caseSensitive ? text.trim() : text.trim().toLowerCase();\n  \n  // Check each blank\n  let correctCount = 0;\n  \n  for (const blank of blanks) {\n    // Ensure blank.position is not null or undefined before converting to string\n    if (blank.position === null || blank.position === undefined) continue;\n    const positionKey = blank.position.toString();\n    \n    const userAnswerText = userBlankAnswers[positionKey];\n    if (!userAnswerText) continue; // No answer provided for this blank\n    \n    const expectedAnswer = normalizeAnswer(blank.content);\n    const normalizedUserAnswer = normalizeAnswer(userAnswerText);\n    \n    if (normalizedUserAnswer === expectedAnswer) {\n      correctCount++;\n    }\n  }\n  \n  // Calculate score based on proportion of correct answers\n  const proportion = blanks.length > 0 ? correctCount / blanks.length : 0;\n  const score = Math.round(questionPoints * proportion);\n  const isCorrect = blanks.length > 0 && correctCount === blanks.length;\n  \n  return {\n    isCorrect,\n    score,\n    needsManualGrading: false,\n    feedback: isCorrect ? undefined : `${correctCount}/${blanks.length} correct answers`\n  };\n}\n\n/**\n * Grade matching questions\n */\nexport function gradeMatchingQuestion(\n  question: Question, \n  answer: Answer\n): GradingResult {\n  const questionPoints = question.points || 1;\n\n  // Group options - support both premise/response and legacy left/right\n  const premiseOptions = question.options?.filter(opt => opt.group === 'premise' || opt.group === 'left') || [];\n  const responseOptions = question.options?.filter(opt => opt.group === 'response' || opt.group === 'right') || [];\n\n  if (premiseOptions.length === 0 || responseOptions.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true, // Requires setup\n      feedback: \"Question has no premise or response options defined\"\n    };\n  }\n\n  // Get correct matches from options\n  // Ensure premiseOption.id and premiseOption.matchId are valid strings\n  const correctMatches: Record<string, string> = {};\n  for (const premiseOption of premiseOptions) {\n    if (premiseOption.id && typeof premiseOption.id === 'string' && \n        premiseOption.matchId && typeof premiseOption.matchId === 'string') {\n      // Find the actual response option that this premise should match to\n      const matchingResponse = responseOptions.find(\n        response => response.id === premiseOption.matchId\n      );\n      if (matchingResponse && matchingResponse.id && typeof matchingResponse.id === 'string') {\n        correctMatches[premiseOption.id] = matchingResponse.id;\n      }\n    }\n  }\n\n  // If no correct matches are defined in the question setup, it needs manual grading or review\n  if (Object.keys(correctMatches).length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true, // Requires setup\n      feedback: \"No correct matches defined for this question. Please check question setup.\"\n    };\n  }\n\n  let userAnswers: Record<string, string> = {};\n  if (answer.jsonData && typeof answer.jsonData === 'string') {\n    try {\n      const parsedData = JSON.parse(answer.jsonData);\n      if (typeof parsedData === 'object' && parsedData !== null) {\n        // Safely build userAnswers Record<string, string>\n        const tempUserAnswers: Record<string, string> = {};\n        let allValuesAreStrings = true;\n        for (const key in parsedData) {\n          if (Object.prototype.hasOwnProperty.call(parsedData, key)) {\n            if (typeof parsedData[key] === 'string') {\n              tempUserAnswers[key] = parsedData[key];\n            } else {\n              allValuesAreStrings = false;\n              break;\n            }\n          }\n        }\n        if (allValuesAreStrings) {\n          userAnswers = tempUserAnswers;\n        } else {\n          return {\n            isCorrect: false,\n            score: 0,\n            needsManualGrading: false,\n            feedback: \"Invalid answer data format (some values are not strings).\"\n          };\n        }\n      } else {\n        // jsonData parsed, but not into an object\n        return {\n            isCorrect: false,\n            score: 0,\n            needsManualGrading: false, \n            feedback: \"Invalid answer data format (not an object).\"\n        };\n      }\n    } catch (e) {\n      console.error(\"Error parsing jsonData in matching question:\", e);\n      return {\n        isCorrect: false,\n        score: 0,\n        needsManualGrading: false, \n        feedback: \"Invalid answer data format (JSON parse failed).\"\n      };\n    }\n  } else {\n    // No jsonData provided in the answer or it's not a string\n    return {\n        isCorrect: false,\n        score: 0,\n        needsManualGrading: false,\n        feedback: \"No valid answer data provided.\"\n    };\n  }\n  \n  let correctUserMatchCount = 0;\n  // Iterate over the *defined correct matches* from the question setup\n  for (const [definedPremiseId, definedResponseId] of Object.entries(correctMatches)) {\n    // Check if the user's answer for this premise matches the defined correct response\n    if (userAnswers[definedPremiseId] === definedResponseId) {\n      correctUserMatchCount++;\n    }\n  }\n  \n  const totalPossibleCorrectMatches = Object.keys(correctMatches).length;\n  \n  // Calculate score based on proportion of correct matches\n  // Ensure no division by zero if totalPossibleCorrectMatches is somehow 0 (though caught above)\n  const proportion = totalPossibleCorrectMatches > 0 \n                   ? correctUserMatchCount / totalPossibleCorrectMatches \n                   : 0;\n  const score = Math.round(questionPoints * proportion);\n  const isCorrect = correctUserMatchCount === totalPossibleCorrectMatches;\n  \n  return {\n    isCorrect,\n    score,\n    needsManualGrading: false, // Matching questions are auto-graded\n    feedback: isCorrect ? \"All matches correct.\" : `${correctUserMatchCount}/${totalPossibleCorrectMatches} correct matches`\n  };\n}\n\n/**\n * Grade code questions\n * Note: Real implementation would likely use a sandbox environment to run code\n */\nfunction gradeCodeQuestion(\n  question: Question, \n  answer: Answer\n): GradingResult {\n  if (!answer.textAnswer) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: false\n    };\n  }\n  \n  // Get question points\n  const questionPoints = question.points || 1;\n  const userCode = answer.textAnswer;\n  \n  // Try to parse metadata for expected output or test cases\n  let expectedOutput: string[] = [];\n  let testCases: Array<{input: string, output: string}> = [];\n  let requiredKeywords: string[] = [];\n  let prohibitedKeywords: string[] = [];\n  \n  try {\n    // Extract metadata for code grading\n    if (question.metadata) {\n      const metadata = typeof question.metadata === 'string' \n        ? JSON.parse(question.metadata) \n        : question.metadata;\n      \n      expectedOutput = metadata.expectedOutput || [];\n      testCases = metadata.testCases || [];\n      requiredKeywords = metadata.requiredKeywords || [];\n      prohibitedKeywords = metadata.prohibitedKeywords || [];\n    }\n  } catch (error) {\n    console.error(\"Error parsing code question metadata:\", error);\n  }\n  \n  // Get expected keywords from options marked as correct\n  const keywordsFromOptions = question.options\n    ?.filter(opt => opt.isCorrect)\n    .map(opt => opt.content.toLowerCase()) || [];\n  \n  // Merge with required keywords from metadata\n  requiredKeywords = [...requiredKeywords, ...keywordsFromOptions];\n  \n  // If no grading criteria defined, require manual grading\n  if (requiredKeywords.length === 0 && \n      prohibitedKeywords.length === 0 &&\n      expectedOutput.length === 0 && \n      testCases.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      needsManualGrading: true,\n      feedback: \"No automated grading criteria defined\"\n    };\n  }\n  \n  // Initialize scoring variables\n  let totalCriteria = 0;\n  let passedCriteria = 0;\n  let feedbackDetails: string[] = [];\n  \n  // Check for required keywords\n  if (requiredKeywords.length > 0) {\n    totalCriteria += requiredKeywords.length;\n    const userCodeLower = userCode.toLowerCase();\n    \n    const matchedKeywords = requiredKeywords.filter(\n      keyword => userCodeLower.includes(keyword.toLowerCase())\n    );\n    \n    passedCriteria += matchedKeywords.length;\n    \n    if (matchedKeywords.length < requiredKeywords.length) {\n      feedbackDetails.push(`Found ${matchedKeywords.length}/${requiredKeywords.length} required elements`);\n    }\n  }\n  \n  // Check for prohibited keywords\n  if (prohibitedKeywords.length > 0) {\n    totalCriteria += prohibitedKeywords.length;\n    const userCodeLower = userCode.toLowerCase();\n    \n    const avoidedKeywords = prohibitedKeywords.filter(\n      keyword => !userCodeLower.includes(keyword.toLowerCase())\n    );\n    \n    passedCriteria += avoidedKeywords.length;\n    \n    if (avoidedKeywords.length < prohibitedKeywords.length) {\n      feedbackDetails.push(`Used ${prohibitedKeywords.length - avoidedKeywords.length} prohibited elements`);\n    }\n  }\n  \n  // Check expected output if provided\n  // Note: In a real implementation, this would execute the code in a sandbox\n  // Here we're just doing a simple check if the output appears in the code\n  if (expectedOutput.length > 0) {\n    totalCriteria += expectedOutput.length;\n    const userCodeLower = userCode.toLowerCase();\n    \n    const matchedOutputs = expectedOutput.filter(\n      output => userCodeLower.includes(output.toLowerCase())\n    );\n    \n    passedCriteria += matchedOutputs.length;\n    \n    if (matchedOutputs.length < expectedOutput.length) {\n      feedbackDetails.push(`Code likely produces ${matchedOutputs.length}/${expectedOutput.length} expected outputs`);\n    }\n  }\n  \n  // Calculate score based on proportion of passed criteria\n  const proportion = totalCriteria > 0 ? passedCriteria / totalCriteria : 0;\n  const score = Math.round(questionPoints * proportion);\n  const isCorrect = totalCriteria > 0 && passedCriteria === totalCriteria;\n  \n  // Always require manual grading for code questions\n  return {\n    isCorrect,\n    score,\n    needsManualGrading: true,\n    feedback: feedbackDetails.length > 0 \n      ? `Automatic pre-grading: ${feedbackDetails.join(\"; \")}` \n      : `Automatic pre-grading: ${passedCriteria}/${totalCriteria} criteria met`\n  };\n}\n\n/**\n * Grades a multiple choice answer directly (without requiring Question and Answer objects)\n * Works for both single-choice and multiple-choice questions\n * \n * @param selectedOptions Array of selected option IDs\n * @param correctOptions Array of correct option IDs\n * @param maxPoints Maximum points for the question\n * @param allowMultiple Whether multiple selections are allowed\n * @param allowPartialCredit Whether partial credit is allowed\n * @param totalOptionsCount Total number of options in the question\n * @returns SimpleGradingResult with isCorrect and score\n */\nexport function gradeMultipleChoiceAnswer(\n  selectedOptions: string[],\n  correctOptions: string[],\n  maxPoints: number,\n  allowMultiple: boolean = false,\n  allowPartialCredit: boolean = true,\n  totalOptionsCount: number = 0\n): SimpleGradingResult {\n  // Handle empty selections\n  if (selectedOptions.length === 0) {\n    return {\n      isCorrect: false,\n      score: 0,\n      feedback: \"No answer selected\"\n    };\n  }\n\n  // For single-choice questions (traditional MCQ)\n  if (!allowMultiple) {\n    // If more than one option selected for single-choice question\n    if (selectedOptions.length > 1) {\n      return {\n        isCorrect: false,\n        score: 0,\n        feedback: \"Multiple options selected for a single-choice question\"\n      };\n    }\n\n    // Check if the selected option is correct\n    const isCorrect = correctOptions.includes(selectedOptions[0]);\n    return {\n      isCorrect,\n      score: isCorrect ? maxPoints : 0,\n      feedback: isCorrect ? \"Correct answer\" : \"Incorrect answer\"\n    };\n  }\n\n  // For multiple-choice questions\n  // Count correct selections and incorrect selections\n  const selectedCorrectCount = selectedOptions.filter(id => \n    correctOptions.includes(id)\n  ).length;\n  \n  const selectedIncorrectCount = selectedOptions.filter(id => \n    !correctOptions.includes(id)\n  ).length;\n  \n  // Perfect answer: all correct options selected and no incorrect options\n  const allCorrectSelected = selectedCorrectCount === correctOptions.length;\n  const noIncorrectSelected = selectedIncorrectCount === 0;\n  const isCorrect = allCorrectSelected && noIncorrectSelected;\n  \n  // Calculate score\n  if (isCorrect) {\n    // Full credit for perfect answer\n    return {\n      isCorrect: true,\n      score: maxPoints,\n      feedback: \"All correct answers selected\"\n    };\n  } else if (allowPartialCredit) {\n    // Calculate partial credit\n    // Start with proportion of correct options selected\n    let partialScore = (selectedCorrectCount / correctOptions.length) * maxPoints;\n    \n    // Apply penalty for incorrect selections\n    if (selectedIncorrectCount > 0 && totalOptionsCount > 0) {\n      const penalty = (selectedIncorrectCount / totalOptionsCount) * maxPoints;\n      partialScore = Math.max(0, partialScore - penalty);\n    }\n    \n    const roundedScore = Math.round(partialScore);\n    \n    let feedback = \"\";\n    if (selectedCorrectCount === 0) {\n      feedback = \"No correct answers selected\";\n    } else if (!allCorrectSelected && noIncorrectSelected) {\n      feedback = \"Some correct answers missed\";\n    } else if (allCorrectSelected && !noIncorrectSelected) {\n      feedback = \"All correct answers selected but with additional incorrect answers\";\n    } else {\n      feedback = \"Partially correct answer\";\n    }\n    \n    return {\n      isCorrect: false,\n      score: roundedScore,\n      feedback\n    };\n  } else {\n    // No partial credit\n    return {\n      isCorrect: false,\n      score: 0,\n      feedback: \"Answer is incorrect (no partial credit)\"\n    };\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1153, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/attempts/%5Bid%5D/complete/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\nimport { prisma } from \"@/lib/prisma\";\nimport { QuestionType } from \"@prisma/client\";\nimport { normalizeMetadata } from '@/lib/utils';\nimport { gradeMultipleChoiceAnswer, gradeMatchingQuestion, gradeFillBlankQuestion } from '@/lib/answer-grading';\nimport { normalizeQuestion } from '@/lib/question-utils';\n\ninterface ExtendedAnswer {\n  id: string;\n  questionId: string;\n  attemptId: string;\n  selectedOption: string | null;\n  selectedOptionIds: string[];\n  textAnswer: string | null;\n  isCorrect: boolean | null;\n  score: number | null;\n  feedback: string | null;\n}\n\ninterface QuestionOption {\n  id: string;\n  content: string;\n  isCorrect: boolean;\n  [key: string]: any;\n}\n\n/**\n * POST /api/attempts/[id]/complete\n * Complete a quiz attempt and calculate score\n * @param request\n * @param params.id - The attempt ID\n */\nexport async function POST(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json({ success: false, message: \"Unauthorized\" }, { status: 401 });\n    }\n\n    const attemptId = params.id;\n    const attempt = await prisma.quizAttempt.findUnique({\n      where: {\n        id: attemptId,\n        userId: session.user.id,\n        completedAt: null // Only complete if not already completed\n      },\n      include: {\n        quiz: {\n          include: {\n            questions: {\n              include: {\n                options: true\n              }\n            }\n          }\n        },\n        answers: true\n      }\n    });\n\n    if (!attempt) {\n      return NextResponse.json(\n        { success: false, message: \"Attempt not found or already completed\" },\n        { status: 404 }\n      );\n    }\n\n    // Get the current time for completion timestamp\n    const now = new Date();\n    const startTime = attempt.startedAt;\n    const timeSpent = Math.round((now.getTime() - startTime.getTime()) / 1000); // In seconds\n\n    // Grade answers and calculate total score\n    let totalScore = 0;\n    let totalPossibleScore = 0;\n    let gradedAnswers = 0;\n    let questionsWithAnswers = 0;\n\n    // Create a map for questions for easy lookup\n    const questionsMap = new Map();\n    attempt.quiz.questions.forEach(q => questionsMap.set(q.id, q));\n\n    // Grade all answers\n    for (const answer of attempt.answers as ExtendedAnswer[]) {\n      const question = questionsMap.get(answer.questionId);\n      if (!question) continue;\n\n      questionsWithAnswers++;\n      const points = question.points || 1;\n      totalPossibleScore += points;\n\n      // Skip if already graded\n      if (answer.isCorrect !== null && answer.score !== null) {\n        gradedAnswers++;\n        if (answer.score !== null) {\n          totalScore += answer.score;\n        }\n        continue;\n      }\n\n      // Auto-grade based on question type\n      let isCorrect: boolean | null = null;\n      let score: number | null = null;\n\n      switch (question.type) {\n        case QuestionType.MULTIPLE_CHOICE:\n        case QuestionType.TRUE_FALSE:\n          // Use selectedOptionIds if available, otherwise try to parse from textAnswer for legacy support\n          let selectedOptionIds = answer.selectedOptionIds || [];\n          if (selectedOptionIds.length === 0 && answer.selectedOption) {\n            // Legacy support - convert single selectedOption to array\n            selectedOptionIds = [answer.selectedOption];\n          }\n\n          // Get metadata to determine if multiple selections are allowed\n          const metadata = normalizeMetadata(question.metadata) || {};\n          const allowMultiple = metadata.allowMultiple || metadata.allowMultipleAnswers || false;\n          const allowPartialCredit = metadata.allowPartialCredit !== false; // Default to true\n\n          // Get correct options\n          const correctOptions = question.options.filter((o: QuestionOption) => o.isCorrect);\n          const correctOptionIds = correctOptions.map((o: QuestionOption) => o.id);\n\n          // Use gradeMultipleChoiceAnswer function from lib/answer-grading.ts\n          const gradingResult = gradeMultipleChoiceAnswer(\n            selectedOptionIds,\n            correctOptionIds,\n            points,\n            allowMultiple,\n            allowPartialCredit,\n            question.options.length\n          );\n\n          isCorrect = gradingResult.isCorrect;\n          score = gradingResult.score;\n          break;\n\n        case QuestionType.SHORT_ANSWER:\n          // Short answer requires exact match with correct options\n          if (answer.textAnswer && question.options.length > 0) {\n            const metadata = normalizeMetadata(question.metadata) || {};\n            const caseSensitive = metadata.caseSensitive || false;\n            \n            // Get correct answers from options\n            const correctAnswers = question.options\n              .filter((o: QuestionOption) => o.isCorrect)\n              .map((o: QuestionOption) => o.content);\n            \n            if (caseSensitive) {\n              isCorrect = correctAnswers.includes(answer.textAnswer);\n            } else {\n              isCorrect = correctAnswers.some((a: string) => \n                a.toLowerCase() === (answer.textAnswer || '').toLowerCase()\n              );\n            }\n            \n            score = isCorrect ? points : 0;\n          } else {\n            isCorrect = false;\n            score = 0;\n          }\n          break;\n\n        case QuestionType.MATCHING:\n          if (answer.textAnswer) {\n            try {\n              const normalizedAnswerForMatching = {\n                questionId: answer.questionId,\n                selectedOptions: [],\n                textAnswer: \"\",\n                jsonData: answer.textAnswer\n              };\n              const matchingGradingResult = gradeMatchingQuestion(\n                normalizeQuestion(question),\n                normalizedAnswerForMatching\n              );\n              isCorrect = matchingGradingResult.isCorrect;\n              score = matchingGradingResult.score;\n              if (matchingGradingResult.feedback) {\n                await prisma.answer.update({\n                  where: { id: answer.id },\n                  data: { feedback: matchingGradingResult.feedback }\n                });\n              }\n            } catch (error) {\n              console.error(\"Error grading matching question:\", error);\n              isCorrect = null;\n              score = null;\n            }\n          } else {\n            isCorrect = false;\n            score = 0;\n          }\n          break;\n\n        case QuestionType.FILL_BLANK:\n          if (answer.textAnswer) {\n            try {\n              const normalizedAnswerForFillBlank = {\n                questionId: answer.questionId,\n                selectedOptions: [],\n                textAnswer: \"\",\n                jsonData: answer.textAnswer\n              };\n              const fillBlankGradingResult = gradeFillBlankQuestion(\n                normalizeQuestion(question),\n                normalizedAnswerForFillBlank\n              );\n              isCorrect = fillBlankGradingResult.isCorrect;\n              score = fillBlankGradingResult.score;\n              if (fillBlankGradingResult.feedback) {\n                await prisma.answer.update({\n                  where: { id: answer.id },\n                  data: { feedback: fillBlankGradingResult.feedback }\n                });\n              }\n            } catch (error) {\n              console.error(\"Error grading fill_blank question:\", error);\n              isCorrect = null;\n              score = null;\n            }\n          } else {\n            isCorrect = false;\n            score = 0;\n          }\n          break;\n\n        case QuestionType.CODE:\n        case QuestionType.ESSAY:\n          isCorrect = null;\n          score = null;\n          break;\n\n        default:\n          isCorrect = null;\n          score = null;\n      }\n\n      // Update answer with grading results if it was auto-graded\n      if (isCorrect !== null && score !== null) {\n        await prisma.answer.update({\n          where: { id: answer.id },\n          data: { isCorrect, score }\n        });\n        gradedAnswers++;\n        totalScore += score;\n      }\n    }\n\n    // Calculate final score as a percentage\n    const finalScore = totalPossibleScore > 0 \n      ? Math.round((totalScore / totalPossibleScore) * 100) \n      : 0;\n\n    // Update the attempt to mark it as completed\n    const completedAttempt = await prisma.quizAttempt.update({\n      where: { id: attemptId },\n      data: {\n        completedAt: now,\n        score: finalScore,\n        timeSpent: timeSpent\n      }\n    });\n\n    // Return the completion data\n    return NextResponse.json({\n      success: true,\n      data: {\n        id: completedAttempt.id,\n        score: completedAttempt.score,\n        timeSpent: completedAttempt.timeSpent,\n        completedAt: completedAttempt.completedAt,\n        totalQuestions: attempt.quiz.questions.length,\n        answeredQuestions: questionsWithAnswers,\n        gradedQuestions: gradedAnswers,\n        needsManualGrading: questionsWithAnswers > gradedAnswers\n      }\n    });\n  } catch (error) {\n    console.error(\"Error completing attempt:\", error);\n    return NextResponse.json(\n      { \n        success: false, \n        message: \"Error completing attempt\", \n        error: error instanceof Error ? error.message : String(error)\n      },\n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/question-utils.ts"],"sourcesContent":["import { QuestionType } from \"@prisma/client\";\nimport { \n  MultipleChoiceMetadata,\n  EssayMetadata,\n  ShortAnswerMetadata,\n  FillBlankMetadata,\n  CodeMetadata,\n  MatchingMetadata,\n} from \"@/app/api/schemas/question-metadata-schemas\";\n\n/**\n * Interface for Question data structure\n */\nexport interface Question {\n  id: string;\n  content: string;\n  type: QuestionType;\n  points: number;\n  order: number;\n  explanation?: string | null;\n  metadata?: any | null;\n  mediaType?: string | null;\n  mediaUrl?: string | null;\n  options?: Option[];\n}\n\n/**\n * Interface for Option data structure\n */\nexport interface Option {\n  id: string;\n  content: string;\n  isCorrect: boolean;\n  order: number;\n  group?: string | null;\n  matchId?: string | null;\n  position?: number | null;\n}\n\n/**\n * Interface for Answer data structure\n */\nexport interface Answer {\n  questionId: string;\n  selectedOptions: string[];  // IDs of selected options\n  textAnswer: string;         // Text answer for essay/short answer/code\n  jsonData: string | null; // Complex data for matching/fill-blank questions (JSON string)\n}\n\n/**\n * Shuffles an array using Fisher-Yates algorithm\n * @param array The array to shuffle\n * @returns A new shuffled array\n */\nexport function shuffleArray<T>(array: T[]): T[] {\n  if (!array || array.length === 0) return [];\n  const newArray = [...array];\n  for (let i = newArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];\n  }\n  return newArray;\n}\n\n/**\n * Normalize metadata from string or object format\n */\nexport function normalizeMetadata<T = any>(metadata: any): T | null {\n  if (!metadata) return null;\n  \n  // If metadata is already an object, return it\n  if (typeof metadata === 'object' && !Array.isArray(metadata) && metadata !== null) {\n    return metadata as T;\n  }\n  \n  // If metadata is a string, try to parse it\n  if (typeof metadata === 'string') {\n    try {\n      // Check if the string is valid JSON\n      if (metadata.trim().startsWith('{') || metadata.trim().startsWith('[')) {\n        return JSON.parse(metadata) as T;\n      } else {\n        console.warn(\"Metadata string is not valid JSON:\", metadata);\n        return null;\n      }\n    } catch (e) {\n      console.error(\"Error parsing metadata string:\", e);\n      return null;\n    }\n  }\n  \n  // For unexpected types, log and return null\n  console.warn(\"Unexpected metadata type:\", typeof metadata);\n  return null;\n}\n\n/**\n * Get default metadata structure based on question type\n */\nexport function getDefaultMetadata(questionType: QuestionType): any {\n  switch (questionType) {\n    case QuestionType.MULTIPLE_CHOICE:\n      return { allowMultiple: false, shuffleOptions: false };\n    \n    case QuestionType.ESSAY:\n      return { minWords: null, maxWords: null, placeholder: \"\", richText: false };\n    \n    case QuestionType.SHORT_ANSWER:\n      return { caseSensitive: false, placeholder: \"\" };\n    \n    case QuestionType.FILL_BLANK:\n      return { text: \"\", caseSensitive: false };\n    \n    case QuestionType.CODE:\n      return { language: \"javascript\", initialCode: \"\", testCases: [] };\n    \n    case QuestionType.MATCHING:\n      return { shuffleOptions: false };\n    \n    default:\n      return {};\n  }\n}\n\n/**\n * Normalize question data ensuring it has the correct metadata structure\n */\nexport function normalizeQuestion(question: Question): Question {\n  // Clone question to avoid mutating the original\n  const normalizedQuestion = { ...question };\n  \n  // Normalize metadata\n  const normalizedMetadata = normalizeMetadata(question.metadata) || \n    getDefaultMetadata(question.type);\n  \n  return {\n    ...normalizedQuestion,\n    metadata: normalizedMetadata\n  };\n}\n\n/**\n * Get type-specific metadata from a normalized question\n */\nexport function getTypedMetadata<T>(question: Question): T | null {\n  if (!question.metadata) return null;\n  \n  try {\n    const normalizedMetadata = normalizeMetadata<T>(question.metadata);\n    return normalizedMetadata;\n  } catch (e) {\n    console.error(\"Error getting typed metadata:\", e);\n    return null;\n  }\n}\n\n/**\n * Get multiple choice specific metadata\n * Improved to handle various metadata formats and provide stronger type safety\n */\nexport function getMultipleChoiceMetadata(question: Question): MultipleChoiceMetadata {\n  // Default values for multiple choice metadata\n  const defaultMetadata: MultipleChoiceMetadata = { \n    allowMultiple: false, \n    shuffleOptions: false, \n    allowPartialCredit: true \n  };\n  \n  // Guard clause for when metadata is completely absent\n  if (!question || !question.metadata) {\n    return defaultMetadata;\n  }\n  \n  // Try to normalize the metadata first\n  let metadata = normalizeMetadata<any>(question.metadata);\n  \n  // If normalization fails, return default\n  if (!metadata) {\n    return defaultMetadata;\n  }\n  \n  // Create result by merging default with whatever we can extract\n  const result: MultipleChoiceMetadata = { \n    ...defaultMetadata \n  };\n  \n  // Handle both naming conventions for multiple answers\n  if (typeof metadata.allowMultiple !== 'undefined') {\n    result.allowMultiple = Boolean(metadata.allowMultiple);\n  } else if (typeof metadata.allowMultipleAnswers !== 'undefined') {\n    result.allowMultiple = Boolean(metadata.allowMultipleAnswers);\n    }\n  \n  // Handle shuffle options setting\n  if (typeof metadata.shuffleOptions !== 'undefined') {\n    result.shuffleOptions = Boolean(metadata.shuffleOptions);\n  }\n  \n  // Handle partial credit setting, defaulting to true if undefined\n  if (typeof metadata.allowPartialCredit !== 'undefined') {\n    result.allowPartialCredit = Boolean(metadata.allowPartialCredit);\n  }\n  \n  return result;\n}\n\n/**\n * Get essay specific metadata\n */\nexport function getEssayMetadata(question: Question): EssayMetadata {\n  return getTypedMetadata<EssayMetadata>(question) || \n    { minWords: undefined, maxWords: undefined, placeholder: undefined, richText: false };\n}\n\n/**\n * Get short answer specific metadata\n */\nexport function getShortAnswerMetadata(question: Question): ShortAnswerMetadata {\n  return getTypedMetadata<ShortAnswerMetadata>(question) || \n    { caseSensitive: false, placeholder: undefined };\n}\n\n/**\n * Get fill-blank specific metadata\n */\nexport function getFillBlankMetadata(question: Question): FillBlankMetadata {\n  return getTypedMetadata<FillBlankMetadata>(question) || \n    { text: \"\", caseSensitive: false };\n}\n\n/**\n * Get code specific metadata\n */\nexport function getCodeMetadata(question: Question): CodeMetadata {\n  return getTypedMetadata<CodeMetadata>(question) || \n    { language: \"javascript\", initialCode: undefined, testCases: undefined };\n}\n\n/**\n * Get matching specific metadata\n */\nexport function getMatchingMetadata(question: Question): MatchingMetadata {\n  return getTypedMetadata<MatchingMetadata>(question) || \n    { shuffleOptions: false };\n}\n\n/**\n * Get the display label for a question type\n */\nexport function getQuestionTypeLabel(type: QuestionType): string {\n  switch (type) {\n    case QuestionType.MULTIPLE_CHOICE: return \"Multiple Choice\";\n    case QuestionType.TRUE_FALSE: return \"True/False\";\n    case QuestionType.ESSAY: return \"Essay\";\n    case QuestionType.SHORT_ANSWER: return \"Short Answer\";\n    case QuestionType.MATCHING: return \"Matching\";\n    case QuestionType.FILL_BLANK: return \"Fill in the Blanks\";\n    case QuestionType.CODE: return \"Code\";\n    case QuestionType.FILE_UPLOAD: return \"File Upload\";\n    default: return type;\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/attempts/%5Bid%5D/answers/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\nimport { prisma } from \"@/lib/prisma\";\nimport { z } from \"zod\";\nimport { QuestionType } from \"@prisma/client\";\nimport { normalizeMetadata } from \"@/lib/question-utils\";\n\n// Define schema for answer submission\nconst AnswerSubmissionSchema = z.object({\n  questionId: z.string().min(1, \"Question ID is required\"),\n  selectedOptions: z.array(z.string()).optional(),\n  textAnswer: z.string().nullable().optional(),\n  jsonData: z.union([\n    z.record(z.unknown()),\n    z.string()\n  ]).nullable().optional() // Allow object, string, null, or undefined\n});\n\ntype AnswerSubmission = z.infer<typeof AnswerSubmissionSchema>;\n\n/**\n * GET /api/attempts/[id]/answers\n * Get all answers for an attempt\n */\nexport async function GET(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Verify authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json(\n        { success: false, message: \"Authentication required\" },\n        { status: 401 }\n      );\n    }\n\n    const userId = session.user.id;\n    const attemptId = params.id;\n\n    // Get attempt with answers\n    const attempt = await prisma.quizAttempt.findFirst({\n      where: {\n        id: attemptId,\n      },\n      include: {\n        answers: {\n          include: {\n            question: {\n              select: {\n                type: true,\n              }\n            }\n          }\n        },\n      },\n    });\n    \n    if (!attempt) {\n      return NextResponse.json(\n        { success: false, message: \"Attempt not found\" },\n        { status: 404 }\n      );\n    }\n\n    // Check if the user is authorized to view this attempt\n    const isOwner = attempt.userId === userId;\n    const isTeacher = (session.user as any).role === \"TEACHER\";\n    \n    if (!isOwner && !isTeacher) {\n      return NextResponse.json(\n        { success: false, message: \"You don't have permission to view this attempt's answers\" },\n        { status: 403 }\n      );\n    }\n\n    // Format the answers based on their question types\n    const formattedAnswers = attempt.answers.map(answer => {\n      const questionType = answer.question?.type;\n      const baseAnswer = {\n        id: answer.id,\n        questionId: answer.questionId,\n        selectedOption: answer.selectedOption,\n        textAnswer: answer.textAnswer,\n        isCorrect: answer.isCorrect,\n        score: answer.score,\n        feedback: answer.feedback,\n      };\n\n      // For complex question types that might store json as a string\n      if (answer.textAnswer && ['MATCHING', 'FILL_BLANK', 'CODE'].includes(questionType as string)) {\n        try {\n          const jsonData = JSON.parse(answer.textAnswer);\n          return {\n            ...baseAnswer,\n            jsonData,\n          };\n        } catch (e) {\n          console.error(`Error parsing JSON for ${questionType} answer:`, e);\n        }\n      }\n\n      return baseAnswer;\n    });\n\n    return NextResponse.json({\n      success: true,\n      data: formattedAnswers,\n    });\n  } catch (error) {\n    console.error(\"[API] Error fetching answers:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to fetch answers\" },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * POST /api/attempts/[id]/answers\n * Submit an answer for a quiz attempt\n */\nexport async function POST(\n  req: NextRequest,\n  { params }: { params: { id: string } }\n) {\n  try {\n    // Verify authentication\n    const session = await getServerSession(authOptions);\n    if (!session?.user) {\n      return NextResponse.json(\n        { success: false, message: \"Authentication required\" },\n        { status: 401 }\n      );\n    }\n\n    const userId = session.user.id;\n    const attemptId = params.id;\n\n    // Get attempt to check ownership\n    const attempt = await prisma.quizAttempt.findFirst({\n      where: {\n        id: attemptId,\n        userId: userId,\n      },\n      include: {\n        quiz: {\n          select: {\n            id: true,\n            title: true,\n            showResults: true,\n          }\n        }\n      }\n    });\n    \n    if (!attempt) {\n      return NextResponse.json(\n        { success: false, message: \"Attempt not found or you don't have access\" },\n        { status: 404 }\n      );\n    }\n\n    // Check if the attempt is already completed\n    if (attempt.completedAt) {\n      return NextResponse.json(\n        { success: false, message: \"This attempt is already completed\" },\n        { status: 400 }\n      );\n    }\n\n    // Parse and validate request body\n    const body = await req.json();\n    const validationResult = AnswerSubmissionSchema.safeParse(body);\n    \n    if (!validationResult.success) {\n      return NextResponse.json(\n        { \n          success: false, \n          message: \"Invalid answer submission\",\n          errors: validationResult.error.errors \n        },\n        { status: 400 }\n      );\n    }\n\n    const answerData = validationResult.data;\n\n    // Get the question to determine appropriate handling\n    const question = await prisma.question.findFirst({\n      where: {\n        id: answerData.questionId,\n        quiz: {\n          attempts: {\n            some: {\n              id: attemptId,\n            },\n          },\n        },\n      },\n      include: {\n        options: true,\n      }\n    });\n\n    if (!question) {\n      return NextResponse.json(\n        { success: false, message: \"Question not found or does not belong to this quiz\" },\n        { status: 404 }\n      );\n    }\n\n    // Process the answer data based on question type\n    // For DB storage, we need to format the data according to the schema\n    const questionMetadata = normalizeMetadata(question.metadata);\n    let dbAnswerData: any = { selectedOption: null, textAnswer: null };\n    \n    try {\n      switch (question.type) {\n        case QuestionType.MULTIPLE_CHOICE:\n        case QuestionType.TRUE_FALSE:\n          // For multiple choice questions, handle both single and multiple selection\n          if (answerData.selectedOptions && answerData.selectedOptions.length > 0) {\n            // Store first option in selectedOption field for backward compatibility\n            dbAnswerData.selectedOption = answerData.selectedOptions[0];\n            \n            // Store all selected options in the new selectedOptionIds field\n            dbAnswerData.selectedOptionIds = answerData.selectedOptions;\n            \n            // For backward compatibility, still store multiple options as JSON in textAnswer\n            if (answerData.selectedOptions.length > 1) {\n              dbAnswerData.textAnswer = JSON.stringify(answerData.selectedOptions);\n            }\n          }\n          break;\n\n        case QuestionType.SHORT_ANSWER:\n        case QuestionType.ESSAY:\n          // For text-based answers\n          dbAnswerData.textAnswer = answerData.textAnswer || null;\n          break;\n\n        case QuestionType.MATCHING:\n        case QuestionType.FILL_BLANK:\n        case QuestionType.CODE:\n          // For complex data types, ensure the data is properly serialized\n          if (answerData.jsonData !== null && typeof answerData.jsonData !== 'undefined') {\n            let finalJsonDataAsObject: Record<string, unknown>;\n\n            if (typeof answerData.jsonData === 'string') {\n              try {\n                finalJsonDataAsObject = JSON.parse(answerData.jsonData);\n                // Ensure the parsed result is actually an object and not a primitive (e.g. a string like \"\"test\"\" or a number)\n                if (typeof finalJsonDataAsObject !== 'object' || finalJsonDataAsObject === null) {\n                  throw new Error(\"Parsed jsonData is not a valid object.\");\n                }\n              } catch (e) {\n                console.error(\"jsonData was a string but not valid JSON or not an object after parsing:\", e);\n                return NextResponse.json(\n                  { success: false, message: \"Invalid jsonData format: Expected a parsable JSON object string.\" },\n                  { status: 400 }\n                );\n              }\n            } else if (typeof answerData.jsonData === 'object') {\n              // It's already an object (and not null, as checked by the outer if)\n              finalJsonDataAsObject = answerData.jsonData;\n            } else {\n              // This case should not be reached if Zod validation with union is correct\n              return NextResponse.json(\n                { success: false, message: \"Unexpected type for jsonData after validation.\" },\n                { status: 400 }\n              );\n            }\n\n            // Now, finalJsonDataAsObject is guaranteed to be an object. Stringify it for storage.\n            try {\n              dbAnswerData.textAnswer = JSON.stringify(finalJsonDataAsObject);\n            } catch (e) {\n                console.error(\"Error stringifying finalJsonDataAsObject:\", e);\n                return NextResponse.json(\n                    { success: false, message: \"Failed to serialize jsonData for storage.\" },\n                    { status: 500 } // Internal server error\n                );\n            }\n          } else if (question.type === QuestionType.CODE && answerData.textAnswer) {\n            // Fallback for CODE questions that might send direct text if jsonData is not provided\n            dbAnswerData.textAnswer = answerData.textAnswer;\n          }\n          break;\n\n        default:\n          dbAnswerData.textAnswer = answerData.textAnswer || null;\n      }\n    } catch (error) {\n      console.error(\"Error processing answer data:\", error);\n      return NextResponse.json(\n        { success: false, message: \"Failed to process answer data\" },\n        { status: 500 }\n      );\n    }\n\n    // Check if an answer already exists for this question in this attempt\n    const existingAnswer = await prisma.answer.findFirst({\n      where: {\n        attemptId,\n        questionId: answerData.questionId,\n      },\n    });\n\n    // Update or create the answer\n    let answer;\n    \n    try {\n      if (existingAnswer) {\n        // Update existing answer\n        answer = await prisma.answer.update({\n          where: {\n            id: existingAnswer.id,\n          },\n          data: dbAnswerData,\n        });\n      } else {\n        // Create new answer\n        answer = await prisma.answer.create({\n          data: {\n            attemptId,\n            questionId: answerData.questionId,\n            ...dbAnswerData,\n          },\n        });\n      }\n    } catch (error) {\n      console.error(\"Database error saving answer:\", error);\n      return NextResponse.json(\n        { success: false, message: \"Failed to save answer to database\" },\n        { status: 500 }\n      );\n    }\n\n    // Format the response based on question type\n    let responseData: any = {\n      id: answer.id,\n      questionId: answer.questionId,\n      saved: true,\n    };\n\n    // Add additional detail\n    switch (question.type) {\n      case QuestionType.MULTIPLE_CHOICE:\n      case QuestionType.TRUE_FALSE:\n        responseData.selectedOptions = answerData.selectedOptions || [];\n        break;\n        \n      case QuestionType.SHORT_ANSWER:\n      case QuestionType.ESSAY:\n      case QuestionType.CODE:\n        responseData.textAnswer = answerData.textAnswer || '';\n        break;\n        \n      case QuestionType.MATCHING:\n      case QuestionType.FILL_BLANK:\n        responseData.jsonData = answerData.jsonData || {};\n        break;\n    }\n\n    return NextResponse.json({\n      success: true,\n      data: responseData,\n    });\n  } catch (error) {\n    console.error(\"[API] Error submitting answer:\", error);\n    return NextResponse.json(\n      { success: false, message: \"Failed to submit answer\" },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}
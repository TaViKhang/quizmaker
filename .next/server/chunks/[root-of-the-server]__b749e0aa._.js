module.exports = {

"[project]/.next-internal/server/app/api/teacher/quizzes/[quizId]/questions/[questionId]/route/actions.js [app-rsc] (server actions loader, ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}}),
"[externals]/util [external] (util, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}}),
"[externals]/url [external] (url, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}}),
"[externals]/http [external] (http, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}}),
"[externals]/crypto [external] (crypto, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}}),
"[externals]/assert [external] (assert, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("assert", () => require("assert"));

module.exports = mod;
}}),
"[externals]/querystring [external] (querystring, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("querystring", () => require("querystring"));

module.exports = mod;
}}),
"[externals]/buffer [external] (buffer, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}}),
"[externals]/zlib [external] (zlib, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}}),
"[externals]/https [external] (https, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}}),
"[externals]/events [external] (events, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}}),
"[externals]/@prisma/client/runtime/library [external] (@prisma/client/runtime/library, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client/runtime/library", () => require("@prisma/client/runtime/library"));

module.exports = mod;
}}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}}),
"[project]/lib/db.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "db": (()=>db)
});
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const db = globalThis.prisma || new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]();
if ("TURBOPACK compile-time truthy", 1) globalThis.prisma = db;
}}),
"[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GET": (()=>handler),
    "POST": (()=>handler),
    "authOptions": (()=>authOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@auth/prisma-adapter/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/providers/google.js [app-route] (ecmascript)");
;
;
;
;
// Domain email được ủy quyền cao hơn
const AUTHORIZED_TEACHER_DOMAINS = [
    'school.edu',
    'university.edu',
    'teacher.org'
];
// Fix cho type adapter
const prismaAdapter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$auth$2f$prisma$2d$adapter$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PrismaAdapter"])(__TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"]);
// Cải thiện error handling
const handleAuthError = (error, context)=>{
    console.error(`[Auth Error] ${context}:`, error);
    return false;
};
const authOptions = {
    adapter: prismaAdapter,
    providers: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$providers$2f$google$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])({
            clientId: process.env.GOOGLE_CLIENT_ID,
            clientSecret: process.env.GOOGLE_CLIENT_SECRET,
            allowDangerousEmailAccountLinking: true
        })
    ],
    session: {
        strategy: "jwt",
        maxAge: 24 * 60 * 60,
        updateAge: 4 * 60 * 60
    },
    callbacks: {
        async jwt ({ token, user, account, profile, trigger }) {
            try {
                // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập
                if (user) {
                    // Đảm bảo role có thể null
                    token.role = user.role;
                    token.id = user.id;
                    return token;
                }
                // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng
                if (trigger === 'update' && token?.sub) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                id: true,
                                name: true,
                                email: true,
                                role: true,
                                image: true
                            }
                        });
                        if (dbUser) {
                            // Cập nhật token với giá trị mới
                            token.role = dbUser.role;
                            token.name = dbUser.name;
                            token.email = dbUser.email;
                            token.picture = dbUser.image;
                            // Thêm timestamp để đảm bảo không cache token cũ
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error updating token:", error);
                    }
                    return token;
                }
                // Trường hợp token từ session: kiểm tra nếu cần cập nhật
                if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt || 0) > 60 * 1000)) {
                    try {
                        const dbUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                            where: {
                                id: token.sub
                            },
                            select: {
                                role: true
                            }
                        });
                        if (dbUser) {
                            token.role = dbUser.role;
                            token.updatedAt = Date.now();
                        }
                    } catch (error) {
                        console.error("Error refreshing token:", error);
                    }
                }
                return token;
            } catch (error) {
                console.error("JWT callback error:", error);
                return token;
            }
        },
        async session ({ session, token }) {
            try {
                if (session.user && token) {
                    // Đảm bảo role có thể null
                    session.user.role = token.role;
                    session.user.id = token.id;
                }
                return session;
            } catch (error) {
                console.error("Session callback error:", error);
                return session;
            }
        },
        async signIn ({ user, account, profile }) {
            // Nếu user có email
            if (user?.email) {
                try {
                    // Kiểm tra user đã tồn tại chưa
                    const existingUser = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.findUnique({
                        where: {
                            email: user.email
                        }
                    });
                    if (!existingUser) {
                        // Tạo user mới không có role (null) để người dùng chọn sau
                        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"].user.create({
                            data: {
                                id: user.id,
                                email: user.email,
                                name: user.name,
                                image: user.image,
                                role: null
                            }
                        });
                        // Đánh dấu để redirect tới trang chọn role
                        return true;
                    }
                    return true;
                } catch (error) {
                    return handleAuthError(error, "signIn callback");
                }
            }
            return true;
        }
    },
    pages: {
        signIn: '/auth/signin',
        signOut: '/',
        error: '/auth/error',
        newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role
    },
    secret: process.env.NEXTAUTH_SECRET,
    debug: ("TURBOPACK compile-time value", "development") === "development",
    logger: {
        error (code, ...message) {
            console.error(`[NextAuth Error] ${code}:`, ...message);
        },
        warn (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.warn(`[NextAuth Warning] ${code}:`, ...message);
            }
        },
        debug (code, ...message) {
            if ("TURBOPACK compile-time truthy", 1) {
                console.debug(`[NextAuth Debug] ${code}:`, ...message);
            }
        }
    }
};
const handler = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(authOptions);
;
}}),
"[project]/lib/prisma.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prisma": (()=>prisma)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
;
const prisma = __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["db"];
}}),
"[project]/app/api/teacher/quizzes/[quizId]/questions/[questionId]/route.ts [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DELETE": (()=>DELETE),
    "GET": (()=>GET),
    "PUT": (()=>PUT)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$next$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next-auth/next/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/api/auth/[...nextauth]/route.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/prisma.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
// Common schema for question data in PUT requests (fields are optional for partial updates)
const questionBaseUpdateSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().min(1).max(10000).optional(),
    explanation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
    points: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].coerce.number().int().min(1).optional(),
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].nativeEnum(__TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"]).optional(),
    order: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].coerce.number().int().optional()
});
// Type-specific schemas for PUT
const multipleChoiceUpdateSchema = questionBaseUpdateSchema.extend({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].literal(__TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MULTIPLE_CHOICE),
    metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        allowMultiple: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().optional(),
        allowMultipleAnswers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().optional(),
        shuffleOptions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().optional()
    }).optional(),
    options: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().min(1),
        isCorrect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean(),
        explanation: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
        order: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].number().int().min(0).optional()
    })).optional()
});
// Định nghĩa schema cho một option trong câu hỏi matching
const matchingOptionUpdateSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional(),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().min(1, "Option content cannot be empty"),
    group: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].enum([
        'premise',
        'response'
    ], {
        errorMap: ()=>({
                message: "Option group must be 'premise' or 'response'."
            })
    }),
    order: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].number().int().min(0, "Option order must be a non-negative integer."),
    matchId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].string().optional().nullable()
});
const matchingUpdateSchema = questionBaseUpdateSchema.extend({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].literal(__TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["QuestionType"].MATCHING),
    options: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].array(matchingOptionUpdateSchema).min(4, "Matching questions require at least 2 premises and 2 responses in total.").refine((options)=>{
        const premises = options.filter((opt)=>opt.group === 'premise');
        const responses = options.filter((opt)=>opt.group === 'response');
        return premises.length >= 2 && responses.length >= 2;
    }, {
        message: "Must have at least two premises and two responses."
    }).refine((options)=>{
        // Lấy tất cả ID của response options (bao gồm cả ID tạm thời)
        const responseIds = new Set(options.filter((opt)=>opt.group === 'response').map((opt)=>opt.id).filter(Boolean));
        // Với mỗi premise, kiểm tra xem matchId có tồn tại trong danh sách responseIds không
        const allPremisesWithValidMatches = options.filter((opt)=>opt.group === 'premise').every((premise)=>{
            // Nếu premise có matchId, kiểm tra xem matchId đó có tồn tại trong responseIds không
            return premise.matchId && responseIds.has(premise.matchId);
        });
        return allPremisesWithValidMatches;
    }, {
        message: "Each premise must be matched to a valid response option in the same question."
    }).refine((options)=>{
        const premises = options.filter((opt)=>opt.group === 'premise');
        const matchedResponseIds = new Set();
        for (const premise of premises){
            if (premise.matchId) {
                if (matchedResponseIds.has(premise.matchId)) {
                    return false; // Tìm thấy một response được match nhiều lần
                }
                matchedResponseIds.add(premise.matchId);
            }
        }
        return true;
    }, {
        message: "Each response can only be matched by one premise (one-to-one matching enforced)."
    }).optional(),
    metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].object({
        shuffleOptions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].boolean().optional()
    }).optional()
});
// Combined question update schema using discriminated union
const questionUpdateSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["z"].discriminatedUnion("type", [
    multipleChoiceUpdateSchema,
    matchingUpdateSchema
]).or(questionBaseUpdateSchema); // Allow updates without specifying type
async function GET(req, { params }) {
    try {
        const paramsData = await params;
        const { quizId, questionId } = paramsData;
        // Check authentication
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$next$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getServerSession"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
        if (!session?.user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 401
            });
        }
        // Check if user is a teacher
        if (session.user.role !== __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["Role"].TEACHER) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 403
            });
        }
        const userId = session.user.id;
        // Check if the quiz exists and belongs to the teacher
        const quiz = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quiz.findUnique({
            where: {
                id: quizId,
                authorId: userId
            }
        });
        if (!quiz) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không tìm thấy quiz"
            }, {
                status: 404
            });
        }
        // Find the question
        const question = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.findUnique({
            where: {
                id: questionId,
                quizId
            },
            include: {
                options: {
                    orderBy: {
                        order: "asc"
                    }
                }
            }
        });
        if (!question) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không tìm thấy câu hỏi"
            }, {
                status: 404
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(question);
    } catch (error) {
        console.error("Error retrieving question:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Lỗi khi lấy thông tin câu hỏi"
        }, {
            status: 500
        });
    }
}
async function PUT(req, { params }) {
    try {
        const paramsData = await params;
        const { quizId, questionId } = paramsData;
        // Check authentication
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$next$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getServerSession"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
        if (!session?.user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 401
            });
        }
        // Check if user is a teacher
        if (session.user.role !== __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["Role"].TEACHER) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 403
            });
        }
        const userId = session.user.id;
        // Check if the quiz exists and belongs to the teacher
        const quiz = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quiz.findUnique({
            where: {
                id: quizId,
                authorId: userId
            }
        });
        if (!quiz) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Quiz không tồn tại hoặc bạn không có quyền chỉnh sửa"
            }, {
                status: 404
            });
        }
        // Parse request body
        const data = await req.json();
        // Validate request body
        const validationResult = questionUpdateSchema.safeParse(data);
        if (!validationResult.success) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Dữ liệu không hợp lệ",
                details: validationResult.error.errors
            }, {
                status: 400
            });
        }
        // Ensure the question exists
        const existingQuestion = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.findUnique({
            where: {
                id: questionId,
                quizId: quizId
            },
            include: {
                options: true
            }
        });
        if (!existingQuestion) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Câu hỏi không tồn tại"
            }, {
                status: 404
            });
        }
        // Process metadata
        let metadata = data.metadata;
        // For multiple choice questions, ensure metadata format is consistent
        if (existingQuestion.type === "MULTIPLE_CHOICE") {
            // Normalize metadata field names for consistency
            metadata = {
                ...metadata || {},
                // Convert allowMultipleAnswers to allowMultiple if exists
                ...metadata?.allowMultipleAnswers !== undefined && {
                    allowMultiple: Boolean(metadata.allowMultipleAnswers)
                },
                // Ensure consistent metadata properties
                allowMultiple: metadata?.allowMultiple !== undefined ? Boolean(metadata.allowMultiple) : metadata?.allowMultipleAnswers !== undefined ? Boolean(metadata.allowMultipleAnswers) : Boolean(existingQuestion.metadata?.allowMultiple || false),
                shuffleOptions: metadata?.shuffleOptions !== undefined ? Boolean(metadata.shuffleOptions) : Boolean(existingQuestion.metadata?.shuffleOptions || false)
            };
            // Remove old naming convention if exists
            if (metadata.allowMultipleAnswers !== undefined) {
                delete metadata.allowMultipleAnswers;
            }
        }
        // Begin updating the question
        const updatedQuestion = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].$transaction(async (tx)=>{
            // Update the question itself
            const question = await tx.question.update({
                where: {
                    id: questionId
                },
                data: {
                    content: data.content !== undefined ? data.content : existingQuestion.content,
                    points: data.points !== undefined ? data.points : existingQuestion.points,
                    order: data.order !== undefined ? data.order : existingQuestion.order,
                    explanation: data.explanation !== undefined ? data.explanation : existingQuestion.explanation,
                    metadata: metadata !== undefined ? metadata : existingQuestion.metadata
                },
                include: {
                    options: true
                }
            });
            // Handle options update if provided
            if (data.options && Array.isArray(data.options)) {
                // Get map of existing options by ID for easy lookup
                const existingOptionsMap = new Map();
                existingQuestion.options.forEach((option)=>{
                    existingOptionsMap.set(option.id, option);
                });
                // Track IDs of options to keep (not delete)
                const optionIdsToKeep = new Set();
                // Xử lý đặc biệt cho câu hỏi MATCHING
                if (existingQuestion.type === "MATCHING") {
                    const premiseOptionsFromRequest = data.options.filter((opt)=>opt.group === 'premise');
                    const responseOptionsFromRequest = data.options.filter((opt)=>opt.group === 'response');
                    const clientResponseIdToDbResponseIdMap = new Map();
                    // Process Response Options first
                    for (const responseOpt of responseOptionsFromRequest){
                        if (responseOpt.id && responseOpt.id.startsWith('id_')) {
                            // New response option (client-generated ID)
                            const newResponse = await tx.option.create({
                                data: {
                                    questionId: questionId,
                                    content: responseOpt.content,
                                    group: 'response',
                                    order: responseOpt.order ?? 0,
                                    isCorrect: false
                                }
                            });
                            clientResponseIdToDbResponseIdMap.set(responseOpt.id, newResponse.id);
                            optionIdsToKeep.add(newResponse.id);
                        } else if (responseOpt.id) {
                            // Existing response option (DB ID)
                            const existingDbOption = existingOptionsMap.get(responseOpt.id);
                            if (existingDbOption) {
                                await tx.option.update({
                                    where: {
                                        id: responseOpt.id
                                    },
                                    data: {
                                        content: responseOpt.content,
                                        order: responseOpt.order
                                    }
                                });
                                optionIdsToKeep.add(responseOpt.id);
                                clientResponseIdToDbResponseIdMap.set(responseOpt.id, responseOpt.id); // Map DB ID to itself
                            } else {
                                // ID was provided, but not found in DB - treat as new if content exists
                                if (responseOpt.content) {
                                    const newResponse = await tx.option.create({
                                        data: {
                                            questionId: questionId,
                                            content: responseOpt.content,
                                            group: 'response',
                                            order: responseOpt.order ?? 0,
                                            isCorrect: false
                                        }
                                    });
                                    // If original responseOpt.id was some non-client-id, we still need to map it if it was used in a matchId
                                    clientResponseIdToDbResponseIdMap.set(responseOpt.id, newResponse.id);
                                    optionIdsToKeep.add(newResponse.id);
                                }
                            }
                        } else {
                            // New response option (no ID from client)
                            if (responseOpt.content) {
                                const newResponse = await tx.option.create({
                                    data: {
                                        questionId: questionId,
                                        content: responseOpt.content,
                                        group: 'response',
                                        order: responseOpt.order ?? 0,
                                        isCorrect: false
                                    }
                                });
                                optionIdsToKeep.add(newResponse.id);
                            // No client ID to map here
                            }
                        }
                    }
                    // Process Premise Options
                    for (const premiseOpt of premiseOptionsFromRequest){
                        let finalMatchId = null;
                        if (premiseOpt.matchId) {
                            finalMatchId = clientResponseIdToDbResponseIdMap.get(premiseOpt.matchId) || premiseOpt.matchId;
                        }
                        if (premiseOpt.id && premiseOpt.id.startsWith('id_')) {
                            // New premise option (client-generated ID)
                            const newPremise = await tx.option.create({
                                data: {
                                    questionId: questionId,
                                    content: premiseOpt.content,
                                    group: 'premise',
                                    order: premiseOpt.order ?? 0,
                                    matchId: finalMatchId,
                                    isCorrect: false
                                }
                            });
                            optionIdsToKeep.add(newPremise.id);
                        } else if (premiseOpt.id) {
                            // Existing premise option (DB ID)
                            const existingDbOption = existingOptionsMap.get(premiseOpt.id);
                            if (existingDbOption) {
                                await tx.option.update({
                                    where: {
                                        id: premiseOpt.id
                                    },
                                    data: {
                                        content: premiseOpt.content,
                                        order: premiseOpt.order,
                                        matchId: finalMatchId
                                    }
                                });
                                optionIdsToKeep.add(premiseOpt.id);
                            } else {
                                // ID was provided, but not found in DB - treat as new
                                if (premiseOpt.content) {
                                    const newPremise = await tx.option.create({
                                        data: {
                                            questionId: questionId,
                                            content: premiseOpt.content,
                                            group: 'premise',
                                            order: premiseOpt.order ?? 0,
                                            matchId: finalMatchId,
                                            isCorrect: false
                                        }
                                    });
                                    optionIdsToKeep.add(newPremise.id);
                                }
                            }
                        } else {
                            // New premise option (no ID from client)
                            if (premiseOpt.content) {
                                const newPremise = await tx.option.create({
                                    data: {
                                        questionId: questionId,
                                        content: premiseOpt.content,
                                        group: 'premise',
                                        order: premiseOpt.order ?? 0,
                                        matchId: finalMatchId,
                                        isCorrect: false
                                    }
                                });
                                optionIdsToKeep.add(newPremise.id);
                            }
                        }
                    }
                } else {
                    // Handle options for other question types (non-MATCHING)
                    for (const option of data.options){
                        if (option.id && existingOptionsMap.has(option.id)) {
                            // Update existing option
                            await tx.option.update({
                                where: {
                                    id: option.id
                                },
                                data: {
                                    content: option.content,
                                    isCorrect: option.isCorrect,
                                    order: option.order,
                                    group: option.group,
                                    matchId: option.matchId,
                                    position: option.position
                                }
                            });
                            optionIdsToKeep.add(option.id);
                        } else {
                            // Create new option only if it has content
                            if (option.content) {
                                const newOption = await tx.option.create({
                                    data: {
                                        questionId: questionId,
                                        content: option.content,
                                        isCorrect: Boolean(option.isCorrect),
                                        order: option.order || 0,
                                        group: option.group,
                                        matchId: option.matchId,
                                        position: option.position
                                    }
                                });
                                optionIdsToKeep.add(newOption.id);
                            }
                        }
                    }
                }
                // Delete options that weren't in the update and are not in optionIdsToKeep
                const idsToDelete = existingQuestion.options.map((opt)=>opt.id).filter((id)=>!optionIdsToKeep.has(id));
                if (idsToDelete.length > 0) {
                    await tx.option.deleteMany({
                        where: {
                            questionId: questionId,
                            id: {
                                in: idsToDelete
                            }
                        }
                    });
                }
            }
            // Get the updated question with new options
            return await tx.question.findUnique({
                where: {
                    id: questionId
                },
                include: {
                    options: {
                        orderBy: {
                            order: "asc"
                        }
                    }
                }
            });
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(updatedQuestion);
    } catch (error) {
        console.error("Error updating question:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Lỗi khi cập nhật câu hỏi"
        }, {
            status: 500
        });
    }
}
async function DELETE(req, { params }) {
    try {
        const paramsData = await params;
        const { quizId, questionId } = paramsData;
        // Check authentication
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2d$auth$2f$next$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getServerSession"])(__TURBOPACK__imported__module__$5b$project$5d2f$app$2f$api$2f$auth$2f5b2e2e2e$nextauth$5d2f$route$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["authOptions"]);
        if (!session?.user) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 401
            });
        }
        // Check if user is a teacher
        if (session.user.role !== __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["Role"].TEACHER) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không được phép"
            }, {
                status: 403
            });
        }
        const userId = session.user.id;
        // Check if the quiz exists and belongs to the teacher
        const quiz = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].quiz.findUnique({
            where: {
                id: quizId,
                authorId: userId
            }
        });
        if (!quiz) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không tìm thấy quiz"
            }, {
                status: 404
            });
        }
        // Check if the question exists and belongs to the quiz
        const existingQuestion = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.findUnique({
            where: {
                id: questionId,
                quizId
            }
        });
        if (!existingQuestion) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: "Không tìm thấy câu hỏi"
            }, {
                status: 404
            });
        }
        // Delete the question
        await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.delete({
            where: {
                id: questionId
            }
        });
        // Update order of remaining questions
        const remainingQuestions = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.findMany({
            where: {
                quizId,
                order: {
                    gt: existingQuestion.order
                }
            },
            orderBy: {
                order: "asc"
            }
        });
        // Update the order of remaining questions
        await Promise.all(remainingQuestions.map((question)=>__TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$prisma$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].question.update({
                where: {
                    id: question.id
                },
                data: {
                    order: question.order - 1
                }
            })));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true
        });
    } catch (error) {
        console.error("Error deleting question:", error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: "Lỗi khi xóa câu hỏi"
        }, {
            status: 500
        });
    }
}
}}),

};

//# sourceMappingURL=%5Broot-of-the-server%5D__b749e0aa._.js.map
{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/teacher/quizzes/%5BquizId%5D/questions/%5BquestionId%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth/next\";\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\nimport { prisma } from \"@/lib/prisma\";\nimport { Role, QuestionType } from \"@prisma/client\";\nimport { z } from \"zod\";\n\n// Common schema for question data in PUT requests (fields are optional for partial updates)\nconst questionBaseUpdateSchema = z.object({\n  content: z.string().min(1).max(10000).optional(),\n  explanation: z.string().optional(),\n  points: z.coerce.number().int().min(1).optional(),\n  type: z.nativeEnum(QuestionType).optional(),\n  order: z.coerce.number().int().optional(),\n});\n\n// Type-specific schemas for PUT\nconst multipleChoiceUpdateSchema = questionBaseUpdateSchema.extend({\n  type: z.literal(QuestionType.MULTIPLE_CHOICE),\n  metadata: z.object({\n    allowMultiple: z.boolean().optional(),\n    allowMultipleAnswers: z.boolean().optional(),\n    shuffleOptions: z.boolean().optional(),\n  }).optional(),\n  options: z.array(\n    z.object({\n      id: z.string().optional(),\n      content: z.string().min(1),\n      isCorrect: z.boolean(),\n      explanation: z.string().optional(),\n      order: z.number().int().min(0).optional(),\n    })\n  ).optional(),\n});\n\n// Định nghĩa schema cho một option trong câu hỏi matching\nconst matchingOptionUpdateSchema = z.object({\n  id: z.string().optional(), // id có thể được client gửi lên (cả ID tạm thời hoặc ID thật từ DB)\n  content: z.string().min(1, \"Option content cannot be empty\"),\n  group: z.enum(['premise', 'response'], {\n    errorMap: () => ({ message: \"Option group must be 'premise' or 'response'.\" })\n  }),\n  order: z.number().int().min(0, \"Option order must be a non-negative integer.\"),\n  matchId: z.string().optional().nullable(), // matchId có trên premise, trỏ đến id của response\n});\n\nconst matchingUpdateSchema = questionBaseUpdateSchema.extend({\n  type: z.literal(QuestionType.MATCHING),\n  options: z.array(matchingOptionUpdateSchema)\n    .min(4, \"Matching questions require at least 2 premises and 2 responses in total.\")\n    .refine(\n      (options) => {\n        const premises = options.filter(opt => opt.group === 'premise');\n        const responses = options.filter(opt => opt.group === 'response');\n        return premises.length >= 2 && responses.length >= 2;\n      },\n      { message: \"Must have at least two premises and two responses.\" }\n    )\n    .refine(\n      (options) => {\n        // Lấy tất cả ID của response options (bao gồm cả ID tạm thời)\n        const responseIds = new Set(\n          options.filter(opt => opt.group === 'response').map(opt => opt.id).filter(Boolean)\n        );\n        \n        // Với mỗi premise, kiểm tra xem matchId có tồn tại trong danh sách responseIds không\n        const allPremisesWithValidMatches = options\n          .filter(opt => opt.group === 'premise')\n          .every(premise => {\n            // Nếu premise có matchId, kiểm tra xem matchId đó có tồn tại trong responseIds không\n            return premise.matchId && responseIds.has(premise.matchId);\n          });\n        \n        return allPremisesWithValidMatches;\n      },\n      { message: \"Each premise must be matched to a valid response option in the same question.\" }\n    )\n    .refine(\n      (options) => { // Đảm bảo không có response nào được match bởi nhiều premise (nếu là one-to-one)\n        const premises = options.filter(opt => opt.group === 'premise');\n        const matchedResponseIds = new Set<string>();\n        \n        for (const premise of premises) {\n          if (premise.matchId) {\n            if (matchedResponseIds.has(premise.matchId)) {\n              return false; // Tìm thấy một response được match nhiều lần\n            }\n            matchedResponseIds.add(premise.matchId);\n          }\n        }\n        return true;\n      },\n      { message: \"Each response can only be matched by one premise (one-to-one matching enforced).\" }\n    ).optional(),\n  metadata: z.object({\n    shuffleOptions: z.boolean().optional()\n  }).optional(),\n});\n\n// Combined question update schema using discriminated union\nconst questionUpdateSchema = z.discriminatedUnion(\"type\", [\n  multipleChoiceUpdateSchema,\n  matchingUpdateSchema,\n  // Add other question type schemas as needed\n]).or(questionBaseUpdateSchema); // Allow updates without specifying type\n\ninterface RouteParams {\n  params: {\n    quizId: string;\n    questionId: string;\n  };\n}\n\n/**\n * GET handler for retrieving a specific question\n */\nexport async function GET(req: NextRequest, { params }: RouteParams) {\n  try {\n    const paramsData = await params;\n    const { quizId, questionId } = paramsData;\n    \n    // Check authentication\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 401 });\n    }\n    \n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 403 });\n    }\n    \n    const userId = session.user.id;\n    \n    // Check if the quiz exists and belongs to the teacher\n    const quiz = await prisma.quiz.findUnique({\n      where: {\n        id: quizId,\n        authorId: userId,\n      },\n    });\n    \n    if (!quiz) {\n      return NextResponse.json({ error: \"Không tìm thấy quiz\" }, { status: 404 });\n    }\n    \n    // Find the question\n    const question = await prisma.question.findUnique({\n      where: {\n        id: questionId,\n        quizId,\n      },\n      include: {\n        options: {\n          orderBy: {\n            order: \"asc\",\n          },\n        },\n        // Include other related data based on question type\n      },\n    });\n    \n    if (!question) {\n      return NextResponse.json({ error: \"Không tìm thấy câu hỏi\" }, { status: 404 });\n    }\n    \n    return NextResponse.json(question);\n  } catch (error) {\n    console.error(\"Error retrieving question:\", error);\n    return NextResponse.json(\n      { error: \"Lỗi khi lấy thông tin câu hỏi\" },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * PUT handler for updating a question\n */\nexport async function PUT(req: NextRequest, { params }: RouteParams) {\n  try {\n    const paramsData = await params;\n    const { quizId, questionId } = paramsData;\n    \n    // Check authentication\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 401 });\n    }\n    \n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 403 });\n    }\n    \n    const userId = session.user.id;\n    \n    // Check if the quiz exists and belongs to the teacher\n    const quiz = await prisma.quiz.findUnique({\n      where: {\n        id: quizId,\n        authorId: userId,\n      },\n    });\n    \n    if (!quiz) {\n      return NextResponse.json(\n        { error: \"Quiz không tồn tại hoặc bạn không có quyền chỉnh sửa\" },\n        { status: 404 }\n      );\n    }\n    \n    // Parse request body\n    const data = await req.json();\n    \n    // Validate request body\n    const validationResult = questionUpdateSchema.safeParse(data);\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { \n          error: \"Dữ liệu không hợp lệ\", \n          details: validationResult.error.errors \n        },\n        { status: 400 }\n      );\n    }\n    \n    // Ensure the question exists\n    const existingQuestion = await prisma.question.findUnique({\n      where: {\n        id: questionId,\n        quizId: quizId,\n      },\n      include: {\n        options: true,\n      },\n    });\n    \n    if (!existingQuestion) {\n      return NextResponse.json(\n        { error: \"Câu hỏi không tồn tại\" },\n        { status: 404 }\n      );\n    }\n    \n    // Process metadata\n    let metadata = data.metadata;\n    \n    // For multiple choice questions, ensure metadata format is consistent\n    if (existingQuestion.type === \"MULTIPLE_CHOICE\") {\n      // Normalize metadata field names for consistency\n      metadata = {\n        ...(metadata || {}),\n        // Convert allowMultipleAnswers to allowMultiple if exists\n        ...(metadata?.allowMultipleAnswers !== undefined && {\n          allowMultiple: Boolean(metadata.allowMultipleAnswers)\n        }),\n        // Ensure consistent metadata properties\n        allowMultiple: metadata?.allowMultiple !== undefined \n          ? Boolean(metadata.allowMultiple) \n          : (metadata?.allowMultipleAnswers !== undefined \n              ? Boolean(metadata.allowMultipleAnswers) \n              : Boolean((existingQuestion.metadata as any)?.allowMultiple || false)),\n        shuffleOptions: metadata?.shuffleOptions !== undefined\n          ? Boolean(metadata.shuffleOptions)\n          : Boolean((existingQuestion.metadata as any)?.shuffleOptions || false),\n      };\n      \n      // Remove old naming convention if exists\n      if (metadata.allowMultipleAnswers !== undefined) {\n        delete metadata.allowMultipleAnswers;\n      }\n    }\n    \n    // Begin updating the question\n    const updatedQuestion = await prisma.$transaction(async (tx) => {\n      // Update the question itself\n      const question = await tx.question.update({\n        where: {\n          id: questionId,\n        },\n        data: {\n          content: data.content !== undefined ? data.content : existingQuestion.content,\n          points: data.points !== undefined ? data.points : existingQuestion.points,\n          order: data.order !== undefined ? data.order : existingQuestion.order,\n          explanation: data.explanation !== undefined ? data.explanation : existingQuestion.explanation,\n          metadata: metadata !== undefined ? metadata : existingQuestion.metadata,\n        },\n        include: {\n          options: true,\n        },\n      });\n      \n      // Handle options update if provided\n      if (data.options && Array.isArray(data.options)) {\n        // Get map of existing options by ID for easy lookup\n        const existingOptionsMap = new Map();\n        existingQuestion.options.forEach(option => {\n          existingOptionsMap.set(option.id, option);\n        });\n        \n        // Track IDs of options to keep (not delete)\n        const optionIdsToKeep = new Set<string>();\n        \n        // Xử lý đặc biệt cho câu hỏi MATCHING\n        if (existingQuestion.type === \"MATCHING\") {\n          const premiseOptionsFromRequest = data.options.filter((opt: any) => opt.group === 'premise');\n          const responseOptionsFromRequest = data.options.filter((opt: any) => opt.group === 'response');\n          const clientResponseIdToDbResponseIdMap = new Map<string, string>();\n\n          // Process Response Options first\n          for (const responseOpt of responseOptionsFromRequest) {\n            if (responseOpt.id && responseOpt.id.startsWith('id_')) {\n              // New response option (client-generated ID)\n              const newResponse = await tx.option.create({\n                data: {\n                  questionId: questionId,\n                  content: responseOpt.content,\n                  group: 'response',\n                  order: responseOpt.order ?? 0,\n                  isCorrect: false,\n                },\n              });\n              clientResponseIdToDbResponseIdMap.set(responseOpt.id, newResponse.id);\n              optionIdsToKeep.add(newResponse.id);\n            } else if (responseOpt.id) {\n              // Existing response option (DB ID)\n              const existingDbOption = existingOptionsMap.get(responseOpt.id);\n              if (existingDbOption) {\n                await tx.option.update({\n                  where: { id: responseOpt.id },\n                  data: {\n                    content: responseOpt.content,\n                    order: responseOpt.order,\n                  },\n                });\n                optionIdsToKeep.add(responseOpt.id);\n                clientResponseIdToDbResponseIdMap.set(responseOpt.id, responseOpt.id); // Map DB ID to itself\n              } else {\n                 // ID was provided, but not found in DB - treat as new if content exists\n                 if (responseOpt.content) {\n                    const newResponse = await tx.option.create({\n                        data: {\n                            questionId: questionId,\n                            content: responseOpt.content,\n                            group: 'response',\n                            order: responseOpt.order ?? 0,\n                            isCorrect: false,\n                        },\n                    });\n                    // If original responseOpt.id was some non-client-id, we still need to map it if it was used in a matchId\n                    clientResponseIdToDbResponseIdMap.set(responseOpt.id, newResponse.id); \n                    optionIdsToKeep.add(newResponse.id);\n                 }\n              }\n            } else {\n              // New response option (no ID from client)\n              if (responseOpt.content) { // Only create if there is content\n                const newResponse = await tx.option.create({\n                    data: {\n                    questionId: questionId,\n                    content: responseOpt.content,\n                    group: 'response',\n                    order: responseOpt.order ?? 0,\n                    isCorrect: false,\n                    },\n                });\n                optionIdsToKeep.add(newResponse.id);\n                // No client ID to map here\n              }\n            }\n          }\n\n          // Process Premise Options\n          for (const premiseOpt of premiseOptionsFromRequest) {\n            let finalMatchId = null;\n            if (premiseOpt.matchId) {\n              finalMatchId = clientResponseIdToDbResponseIdMap.get(premiseOpt.matchId) || premiseOpt.matchId;\n            }\n\n            if (premiseOpt.id && premiseOpt.id.startsWith('id_')) {\n              // New premise option (client-generated ID)\n              const newPremise = await tx.option.create({\n                data: {\n                  questionId: questionId,\n                  content: premiseOpt.content,\n                  group: 'premise',\n                  order: premiseOpt.order ?? 0,\n                  matchId: finalMatchId,\n                  isCorrect: false,\n                },\n              });\n              optionIdsToKeep.add(newPremise.id);\n            } else if (premiseOpt.id) {\n              // Existing premise option (DB ID)\n              const existingDbOption = existingOptionsMap.get(premiseOpt.id);\n              if (existingDbOption) {\n                await tx.option.update({\n                  where: { id: premiseOpt.id },\n                  data: {\n                    content: premiseOpt.content,\n                    order: premiseOpt.order,\n                    matchId: finalMatchId,\n                  },\n                });\n                optionIdsToKeep.add(premiseOpt.id);\n              } else {\n                // ID was provided, but not found in DB - treat as new\n                if (premiseOpt.content) {\n                    const newPremise = await tx.option.create({\n                        data: {\n                            questionId: questionId,\n                            content: premiseOpt.content,\n                            group: 'premise',\n                            order: premiseOpt.order ?? 0,\n                            matchId: finalMatchId,\n                            isCorrect: false,\n                        },\n                    });\n                    optionIdsToKeep.add(newPremise.id);\n                }\n              }\n            } else {\n              // New premise option (no ID from client)\n               if (premiseOpt.content) { // Only create if there is content\n                    const newPremise = await tx.option.create({\n                        data: {\n                        questionId: questionId,\n                        content: premiseOpt.content,\n                        group: 'premise',\n                        order: premiseOpt.order ?? 0,\n                        matchId: finalMatchId,\n                        isCorrect: false,\n                        },\n                    });\n                    optionIdsToKeep.add(newPremise.id);\n               }\n            }\n          }\n        } else {\n          // Handle options for other question types (non-MATCHING)\n          for (const option of data.options) {\n            if (option.id && existingOptionsMap.has(option.id)) {\n              // Update existing option\n              await tx.option.update({\n                where: { id: option.id },\n                data: {\n                  content: option.content,\n                  isCorrect: option.isCorrect,\n                  order: option.order,\n                  group: option.group,\n                  matchId: option.matchId,\n                  position: option.position,\n                },\n              });\n              optionIdsToKeep.add(option.id);\n            } else {\n              // Create new option only if it has content\n              if (option.content) { \n                const newOption = await tx.option.create({\n                  data: {\n                    questionId: questionId,\n                    content: option.content,\n                    isCorrect: Boolean(option.isCorrect),\n                    order: option.order || 0,\n                    group: option.group,\n                    matchId: option.matchId,\n                    position: option.position,\n                  },\n                });\n                optionIdsToKeep.add(newOption.id);\n              }\n            }\n          }\n        }\n        \n        // Delete options that weren't in the update and are not in optionIdsToKeep\n        const idsToDelete = existingQuestion.options\n                            .map(opt => opt.id)\n                            .filter(id => !optionIdsToKeep.has(id));\n        \n        if (idsToDelete.length > 0) {\n            await tx.option.deleteMany({\n                where: {\n                questionId: questionId,\n                id: { in: idsToDelete },\n                },\n            });\n        }\n      }\n      \n      // Get the updated question with new options\n      return await tx.question.findUnique({\n        where: {\n          id: questionId,\n        },\n        include: {\n          options: {\n            orderBy: {\n              order: \"asc\",\n            },\n          },\n        },\n      });\n    });\n    \n    return NextResponse.json(updatedQuestion);\n  } catch (error) {\n    console.error(\"Error updating question:\", error);\n    return NextResponse.json(\n      { error: \"Lỗi khi cập nhật câu hỏi\" },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * DELETE handler for deleting a question\n */\nexport async function DELETE(req: NextRequest, { params }: RouteParams) {\n  try {\n    const paramsData = await params;\n    const { quizId, questionId } = paramsData;\n    \n    // Check authentication\n    const session = await getServerSession(authOptions);\n    \n    if (!session?.user) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 401 });\n    }\n    \n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json({ error: \"Không được phép\" }, { status: 403 });\n    }\n    \n    const userId = session.user.id;\n    \n    // Check if the quiz exists and belongs to the teacher\n    const quiz = await prisma.quiz.findUnique({\n      where: {\n        id: quizId,\n        authorId: userId,\n      },\n    });\n    \n    if (!quiz) {\n      return NextResponse.json({ error: \"Không tìm thấy quiz\" }, { status: 404 });\n    }\n    \n    // Check if the question exists and belongs to the quiz\n    const existingQuestion = await prisma.question.findUnique({\n      where: {\n        id: questionId,\n        quizId,\n      },\n    });\n    \n    if (!existingQuestion) {\n      return NextResponse.json({ error: \"Không tìm thấy câu hỏi\" }, { status: 404 });\n    }\n    \n    // Delete the question\n    await prisma.question.delete({\n      where: {\n        id: questionId,\n      },\n    });\n    \n    // Update order of remaining questions\n    const remainingQuestions = await prisma.question.findMany({\n      where: {\n        quizId,\n        order: {\n          gt: existingQuestion.order,\n        },\n      },\n      orderBy: {\n        order: \"asc\",\n      },\n    });\n    \n    // Update the order of remaining questions\n    await Promise.all(\n      remainingQuestions.map((question) =>\n        prisma.question.update({\n          where: { id: question.id },\n          data: { order: question.order - 1 },\n        })\n      )\n    );\n    \n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error(\"Error deleting question:\", error);\n    return NextResponse.json(\n      { error: \"Lỗi khi xóa câu hỏi\" },\n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}
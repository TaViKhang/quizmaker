{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\ndeclare global {\n  var prisma: PrismaClient | undefined;\n}\n\nexport const db = globalThis.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\nimport { db } from \"@/lib/db\"\nimport GoogleProvider from \"next-auth/providers/google\"\nimport { ROLES, RoleType } from \"@/lib/constants\"\n\n// Domain email được ủy quyền cao hơn\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\n\n// Fix cho type adapter\nconst prismaAdapter = PrismaAdapter(db) as any\n\n// Cải thiện error handling\nconst handleAuthError = (error: any, context: string) => {\n  console.error(`[Auth Error] ${context}:`, error);\n  return false;\n}\n\nexport const authOptions: AuthOptions = {\n  adapter: prismaAdapter,\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      allowDangerousEmailAccountLinking: true,\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 24 * 60 * 60, // 24 hours\n    updateAge: 4 * 60 * 60, // 4 hours\n  },\n  callbacks: {\n    async jwt({ token, user, account, profile, trigger }) {\n      try {\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\n        if (user) {\n          // Đảm bảo role có thể null\n          token.role = user.role as RoleType | null;\n          token.id = user.id;\n          return token;\n        }\n        \n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\n        if (trigger === 'update' && token?.sub) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { \n                id: true, \n                name: true, \n                email: true, \n                role: true, \n                image: true \n              }\n            });\n            \n            if (dbUser) {\n              // Cập nhật token với giá trị mới\n              token.role = dbUser.role as RoleType | null;\n              token.name = dbUser.name;\n              token.email = dbUser.email;\n              token.picture = dbUser.image;\n              \n              // Thêm timestamp để đảm bảo không cache token cũ\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error updating token:\", error);\n          }\n          return token;\n        }\n        \n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\n          try {\n            const dbUser = await db.user.findUnique({\n              where: { id: token.sub },\n              select: { role: true }\n            });\n            \n            if (dbUser) {\n              token.role = dbUser.role as RoleType | null;\n              token.updatedAt = Date.now();\n            }\n          } catch (error) {\n            console.error(\"Error refreshing token:\", error);\n          }\n        }\n        \n        return token;\n      } catch (error) {\n        console.error(\"JWT callback error:\", error);\n        return token;\n      }\n    },\n    async session({ session, token }) {\n      try {\n        if (session.user && token) {\n          // Đảm bảo role có thể null\n          session.user.role = token.role as RoleType | null;\n          session.user.id = token.id as string;\n        }\n        return session;\n      } catch (error) {\n        console.error(\"Session callback error:\", error);\n        return session;\n      }\n    },\n    async signIn({ user, account, profile }) {\n      // Nếu user có email\n      if (user?.email) {\n        try {\n          // Kiểm tra user đã tồn tại chưa\n          const existingUser = await db.user.findUnique({\n            where: { email: user.email },\n          })\n          \n          if (!existingUser) {\n            // Tạo user mới không có role (null) để người dùng chọn sau\n            await db.user.create({\n              data: {\n                id: user.id,\n                email: user.email,\n                name: user.name,\n                image: user.image,\n                role: null, // Không thiết lập role mặc định\n              },\n            })\n            \n            // Đánh dấu để redirect tới trang chọn role\n            return true\n          }\n          \n          return true\n        } catch (error) {\n          return handleAuthError(error, \"signIn callback\");\n        }\n      }\n      \n      return true\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    signOut: '/',\n    error: '/auth/error',\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  debug: process.env.NODE_ENV === \"development\",\n  logger: {\n    error(code, ...message) {\n      console.error(`[NextAuth Error] ${code}:`, ...message);\n    },\n    warn(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\n      }\n    },\n    debug(code, ...message) {\n      if (process.env.NODE_ENV === \"development\") {\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\n      }\n    },\n  },\n}\n\nconst handler = NextAuth(authOptions)\nexport { handler as GET, handler as POST }\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\n\n// Re-export với tên khác để không phá vỡ code đang sử dụng\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/teacher/classes/%5BclassId%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth/next\";\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\nimport { prisma } from \"@/lib/prisma\";\nimport { Role, ClassType } from \"@prisma/client\";\nimport { generateRandomCode } from \"@/lib/utils\";\nimport { z } from \"zod\";\n\ninterface RouteParams {\n  params: {\n    classId: string;\n  };\n}\n\n/**\n * GET handler for retrieving a specific class with detailed information\n */\nexport async function GET(req: NextRequest, { params }: RouteParams) {\n  try {\n    // Get user session\n    const session = await getServerSession(authOptions);\n\n    // Check authentication\n    if (!session || !session.user) {\n      return NextResponse.json(\n        { error: \"Unauthorized access\" },\n        { status: 401 }\n      );\n    }\n\n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json(\n        { error: \"Access denied: Teacher role required\" },\n        { status: 403 }\n      );\n    }\n\n    const { classId } = params;\n\n    // Check if class exists and belongs to the teacher\n    const classExists = await prisma.class.findUnique({\n      where: {\n        id: classId,\n        teacherId: session.user.id,\n      },\n    });\n\n    if (!classExists) {\n      return NextResponse.json(\n        { error: \"Class not found or you don't have access to it\" },\n        { status: 404 }\n      );\n    }\n\n    // Get detailed class information\n    const classInfo = await prisma.class.findUnique({\n      where: {\n        id: classId,\n      },\n      include: {\n        _count: {\n          select: {\n            students: true,\n            quizzes: true,\n          },\n        },\n      },\n    });\n\n    // Get student count and basic stats\n    const studentCount = await prisma.classEnrollment.count({\n      where: {\n        classId,\n      },\n    });\n\n    // Get quiz counts by status\n    const quizCounts = await prisma.quiz.groupBy({\n      by: ['isActive', 'isPublished'],\n      where: {\n        classId,\n      },\n      _count: {\n        id: true,\n      },\n    });\n\n    const activePublishedQuizzes = quizCounts.find(q => q.isActive && q.isPublished)?._count.id || 0;\n    const draftQuizzes = quizCounts.find(q => !q.isPublished)?._count.id || 0;\n    const inactiveQuizzes = quizCounts.find(q => !q.isActive && q.isPublished)?._count.id || 0;\n\n    // Get recent activity\n    const recentQuizzes = await prisma.quiz.findMany({\n      where: {\n        classId,\n      },\n      orderBy: {\n        updatedAt: 'desc',\n      },\n      take: 5,\n      select: {\n        id: true,\n        title: true,\n        isActive: true,\n        isPublished: true,\n        updatedAt: true,\n      },\n    });\n\n    const recentEnrollments = await prisma.classEnrollment.findMany({\n      where: {\n        classId,\n      },\n      orderBy: {\n        joinedAt: 'desc',\n      },\n      take: 5,\n      select: {\n        id: true,\n        joinedAt: true,\n        student: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          },\n        },\n      },\n    });\n\n    // Get quiz statistics\n    const quizAttempts = await prisma.quizAttempt.findMany({\n      where: {\n        quiz: {\n          classId,\n        },\n        completedAt: {\n          not: null,\n        },\n      },\n      select: {\n        score: true,\n        userId: true,\n        completedAt: true,\n        quiz: {\n          select: {\n            id: true,\n            title: true,\n            passingScore: true,\n          },\n        },\n      },\n    });\n\n    // Calculate average scores using best attempt per student per quiz\n    const studentQuizBestScores = new Map<string, Map<string, number>>();\n\n    // Group attempts by student and quiz, keeping only best score\n    quizAttempts.forEach(attempt => {\n      if (attempt.score !== null) {\n        if (!studentQuizBestScores.has(attempt.userId)) {\n          studentQuizBestScores.set(attempt.userId, new Map());\n        }\n\n        const studentQuizzes = studentQuizBestScores.get(attempt.userId)!;\n        const currentBest = studentQuizzes.get(attempt.quiz.id) || 0;\n\n        if (attempt.score > currentBest) {\n          studentQuizzes.set(attempt.quiz.id, attempt.score);\n        }\n      }\n    });\n\n    // Calculate average from best scores only\n    const allBestScores: number[] = [];\n    studentQuizBestScores.forEach(quizzes => {\n      quizzes.forEach(score => {\n        allBestScores.push(score);\n      });\n    });\n\n    const averageScore = allBestScores.length > 0\n      ? Math.round(allBestScores.reduce((sum, score) => sum + score, 0) / allBestScores.length)\n      : null;\n\n    // Calculate student participation\n    const totalStudents = studentCount;\n    const studentsWithAttempts = new Set(quizAttempts.map(a => a.userId)).size;\n    \n    const participationRate = totalStudents > 0\n      ? Math.round((studentsWithAttempts / totalStudents) * 100)\n      : 0;\n\n    // Calculate top performing students using best scores per quiz\n    const studentPerformance = new Map();\n\n    // Process all attempts to calculate student performance using best scores\n    quizAttempts.forEach(attempt => {\n      const { userId, score, completedAt } = attempt;\n\n      if (!studentPerformance.has(userId)) {\n        studentPerformance.set(userId, {\n          id: userId,\n          quizBestScores: new Map(),\n          totalAttempts: 0,\n          averageScore: null,\n          lastAttemptAt: null\n        });\n      }\n\n      const student = studentPerformance.get(userId);\n      student.totalAttempts += 1; // Count all attempts for practice tracking\n\n      if (score !== null) {\n        // Track best score per quiz\n        const currentBest = student.quizBestScores.get(attempt.quiz.id) || 0;\n        if (score > currentBest) {\n          student.quizBestScores.set(attempt.quiz.id, score);\n        }\n\n        // Calculate average from best scores\n        const bestScores = Array.from(student.quizBestScores.values());\n        student.averageScore = bestScores.length > 0\n          ? Math.round(bestScores.reduce((sum, s) => sum + s, 0) / bestScores.length)\n          : null;\n      }\n\n      // Update last attempt time if newer\n      if (completedAt && (!student.lastAttemptAt || new Date(completedAt) > new Date(student.lastAttemptAt))) {\n        student.lastAttemptAt = completedAt;\n      }\n    });\n    \n    // Get student details from the database\n    const studentIds = Array.from(studentPerformance.keys());\n    const studentsWithDetails = await prisma.user.findMany({\n      where: {\n        id: {\n          in: studentIds\n        }\n      },\n      select: {\n        id: true,\n        name: true,\n        email: true,\n        enrolledClasses: {\n          where: {\n            classId\n          },\n          select: {\n            lastActive: true\n          }\n        }\n      }\n    });\n    \n    // Combine performance data with student details\n    const topStudents = studentsWithDetails.map(student => {\n      const performance = studentPerformance.get(student.id);\n      return {\n        id: student.id,\n        name: student.name,\n        email: student.email,\n        attemptCount: performance?.totalAttempts || 0, // Total practice attempts\n        completedQuizzes: performance?.quizBestScores?.size || 0, // Unique quizzes completed\n        averageScore: performance?.averageScore || null,\n        lastActive: student.enrolledClasses[0]?.lastActive?.toISOString() || performance?.lastAttemptAt?.toISOString() || null\n      };\n    })\n    .filter(student => student.attemptCount > 0) // Only include students with attempts\n    .sort((a, b) => {\n      // First sort by average score (higher is better)\n      if (a.averageScore !== b.averageScore) {\n        return (b.averageScore || 0) - (a.averageScore || 0);\n      }\n\n      // Then by completed quizzes (higher is better)\n      if (a.completedQuizzes !== b.completedQuizzes) {\n        return b.completedQuizzes - a.completedQuizzes;\n      }\n\n      // Finally by most recent activity (newer is better)\n      return new Date(b.lastActive || 0).getTime() - new Date(a.lastActive || 0).getTime();\n    })\n    .slice(0, 5); // Take top 5 students\n\n    // Format the response\n    const formattedClass = {\n      id: classInfo?.id,\n      name: classInfo?.name,\n      description: classInfo?.description,\n      subject: classInfo?.subject,\n      type: classInfo?.type,\n      inviteCode: classInfo?.code,\n      isActive: classInfo?.isActive,\n      teacherId: classInfo?.teacherId,\n      createdAt: classInfo?.createdAt.toISOString(),\n      updatedAt: classInfo?.updatedAt.toISOString(),\n      topStudents,\n      stats: {\n        students: {\n          total: studentCount,\n          active: studentsWithAttempts,\n          participationRate,\n        },\n        quizzes: {\n          total: classInfo?._count.quizzes || 0,\n          active: activePublishedQuizzes,\n          drafts: draftQuizzes,\n          inactive: inactiveQuizzes,\n        },\n        performance: {\n          averageScore,\n          completedAttempts: quizAttempts.length,\n        },\n      },\n      recentActivity: {\n        quizzes: recentQuizzes.map(quiz => ({\n          ...quiz,\n          updatedAt: quiz.updatedAt.toISOString(),\n        })),\n        enrollments: recentEnrollments.map(enrollment => ({\n          id: enrollment.id,\n          student: enrollment.student,\n          joinedAt: enrollment.joinedAt.toISOString(),\n        })),\n      },\n    };\n\n    return NextResponse.json(formattedClass);\n  } catch (error) {\n    console.error(\"Error fetching class:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch class details\" },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * PUT handler for updating a class\n */\nexport async function PUT(req: NextRequest, { params }: RouteParams) {\n  try {\n    // Get user session\n    const session = await getServerSession(authOptions);\n\n    // Check authentication\n    if (!session || !session.user) {\n      return NextResponse.json(\n        { error: \"Unauthorized access\" },\n        { status: 401 }\n      );\n    }\n\n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json(\n        { error: \"Access denied: Teacher role required\" },\n        { status: 403 }\n      );\n    }\n\n    const { classId } = params;\n\n    // Check if class exists and belongs to the teacher\n    const classExists = await prisma.class.findUnique({\n      where: {\n        id: classId,\n        teacherId: session.user.id,\n      },\n    });\n\n    if (!classExists) {\n      return NextResponse.json(\n        { error: \"Class not found or you don't have access to it\" },\n        { status: 404 }\n      );\n    }\n\n    // Parse request body\n    const body = await req.json();\n\n    // Validate request body\n    const updateSchema = z.object({\n      name: z.string().min(1, \"Class name is required\").optional(),\n      description: z.string().nullable().optional(),\n      subject: z.string().nullable().optional(),\n      type: z.nativeEnum(ClassType).optional(),\n      isActive: z.boolean().optional(),\n    });\n\n    const validatedData = updateSchema.parse(body);\n\n    // Update the class\n    const updatedClass = await prisma.class.update({\n      where: {\n        id: classId,\n      },\n      data: validatedData,\n    });\n\n    return NextResponse.json({\n      message: \"Class updated successfully\",\n      class: {\n        id: updatedClass.id,\n        name: updatedClass.name,\n        description: updatedClass.description,\n        subject: updatedClass.subject,\n        type: updatedClass.type,\n        isActive: updatedClass.isActive,\n        updatedAt: updatedClass.updatedAt.toISOString(),\n      },\n    });\n  } catch (error) {\n    console.error(\"Error updating class:\", error);\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { error: \"Validation error\", details: error.errors },\n        { status: 400 }\n      );\n    }\n    return NextResponse.json(\n      { error: \"Failed to update class\" },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * DELETE handler for deleting a class\n */\nexport async function DELETE(req: NextRequest, { params }: RouteParams) {\n  try {\n    // Get user session\n    const session = await getServerSession(authOptions);\n\n    // Check authentication\n    if (!session || !session.user) {\n      return NextResponse.json(\n        { error: \"Unauthorized access\" },\n        { status: 401 }\n      );\n    }\n\n    // Check if user is a teacher\n    if (session.user.role !== Role.TEACHER) {\n      return NextResponse.json(\n        { error: \"Access denied: Teacher role required\" },\n        { status: 403 }\n      );\n    }\n\n    const { classId } = params;\n\n    // Check if class exists and belongs to the teacher\n    const classExists = await prisma.class.findUnique({\n      where: {\n        id: classId,\n        teacherId: session.user.id,\n      },\n    });\n\n    if (!classExists) {\n      return NextResponse.json(\n        { error: \"Class not found or you don't have access to it\" },\n        { status: 404 }\n      );\n    }\n\n    // Delete the class - this will cascade delete all related records if you have set up your schema correctly\n    await prisma.class.delete({\n      where: {\n        id: classId,\n      },\n    });\n\n    return NextResponse.json({\n      message: \"Class deleted successfully\",\n    });\n  } catch (error) {\n    console.error(\"Error deleting class:\", error);\n    return NextResponse.json(\n      { error: \"Failed to delete class\" },\n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}
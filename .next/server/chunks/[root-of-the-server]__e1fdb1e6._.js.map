{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const db = globalThis.prisma || new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\r\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\r\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\r\nimport { db } from \"@/lib/db\"\r\nimport GoogleProvider from \"next-auth/providers/google\"\r\nimport { ROLES, RoleType } from \"@/lib/constants\"\r\n\r\n// Domain email được ủy quyền cao hơn\r\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\r\n\r\n// Fix cho type adapter\r\nconst prismaAdapter = PrismaAdapter(db) as any\r\n\r\n// Cải thiện error handling\r\nconst handleAuthError = (error: any, context: string) => {\r\n  console.error(`[Auth Error] ${context}:`, error);\r\n  return false;\r\n}\r\n\r\nexport const authOptions: AuthOptions = {\r\n  adapter: prismaAdapter,\r\n  providers: [\r\n    GoogleProvider({\r\n      clientId: process.env.GOOGLE_CLIENT_ID!,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\r\n      allowDangerousEmailAccountLinking: true,\r\n    }),\r\n  ],\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 24 * 60 * 60, // 24 hours\r\n    updateAge: 4 * 60 * 60, // 4 hours\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user, account, profile, trigger }) {\r\n      try {\r\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\r\n        if (user) {\r\n          // Đảm bảo role có thể null\r\n          token.role = user.role as RoleType | null;\r\n          token.id = user.id;\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\r\n        if (trigger === 'update' && token?.sub) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { \r\n                id: true, \r\n                name: true, \r\n                email: true, \r\n                role: true, \r\n                image: true \r\n              }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              // Cập nhật token với giá trị mới\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.name = dbUser.name;\r\n              token.email = dbUser.email;\r\n              token.picture = dbUser.image;\r\n              \r\n              // Thêm timestamp để đảm bảo không cache token cũ\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error updating token:\", error);\r\n          }\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\r\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { role: true }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error refreshing token:\", error);\r\n          }\r\n        }\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        console.error(\"JWT callback error:\", error);\r\n        return token;\r\n      }\r\n    },\r\n    async session({ session, token }) {\r\n      try {\r\n        if (session.user && token) {\r\n          // Đảm bảo role có thể null\r\n          session.user.role = token.role as RoleType | null;\r\n          session.user.id = token.id as string;\r\n        }\r\n        return session;\r\n      } catch (error) {\r\n        console.error(\"Session callback error:\", error);\r\n        return session;\r\n      }\r\n    },\r\n    async signIn({ user, account, profile }) {\r\n      // Nếu user có email\r\n      if (user?.email) {\r\n        try {\r\n          // Kiểm tra user đã tồn tại chưa\r\n          const existingUser = await db.user.findUnique({\r\n            where: { email: user.email },\r\n          })\r\n          \r\n          if (!existingUser) {\r\n            // Tạo user mới không có role (null) để người dùng chọn sau\r\n            await db.user.create({\r\n              data: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                image: user.image,\r\n                role: null, // Không thiết lập role mặc định\r\n              },\r\n            })\r\n            \r\n            // Đánh dấu để redirect tới trang chọn role\r\n            return true\r\n          }\r\n          \r\n          return true\r\n        } catch (error) {\r\n          return handleAuthError(error, \"signIn callback\");\r\n        }\r\n      }\r\n      \r\n      return true\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/auth/signin',\r\n    signOut: '/',\r\n    error: '/auth/error',\r\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n  debug: process.env.NODE_ENV === \"development\",\r\n  logger: {\r\n    error(code, ...message) {\r\n      console.error(`[NextAuth Error] ${code}:`, ...message);\r\n    },\r\n    warn(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\r\n      }\r\n    },\r\n    debug(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\r\n      }\r\n    },\r\n  },\r\n}\r\n\r\nconst handler = NextAuth(authOptions)\r\nexport { handler as GET, handler as POST }\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/prisma.ts"],"sourcesContent":["import { db } from './db';\r\n\r\n// Re-export với tên khác để không phá vỡ code đang sử dụng\r\nexport const prisma = db;"],"names":[],"mappings":";;;AAAA;;AAGO,MAAM,SAAS,2GAAA,CAAA,KAAE","debugId":null}},
    {"offset": {"line": 362, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/users/me/score-analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth/next\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { format, subMonths, subDays, parseISO, startOfMonth, endOfMonth, \r\n  startOfWeek, endOfWeek, addDays, isBefore, differenceInDays, subWeeks } from \"date-fns\";\r\nimport { QuizAttempt, Prisma } from \"@prisma/client\";\r\n\r\n// Kiểu dữ liệu cho QuizAttempt đã được thêm include\r\ntype QuizAttemptWithQuiz = QuizAttempt & {\r\n  quiz: {\r\n    title: string;\r\n    category?: string; // category thay cho subject vì trong schema không có subject\r\n  }\r\n};\r\n\r\n// Interface cho request query parameters\r\ninterface ScoreAnalyticsQueryParams {\r\n  timeFrame?: string; // last7days, last30days, last90days, last6months, lastYear, allTime\r\n  subject?: string;\r\n  minScore?: string;\r\n  maxScore?: string;\r\n  includePublicQuizzes?: boolean;\r\n}\r\n\r\n// Response utilities\r\ninterface SuccessResponseOptions {\r\n  headers?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Utility function to create consistent API responses\r\n */\r\nfunction createApiResponse<T>(data: T, options: SuccessResponseOptions = {}) {\r\n  return NextResponse.json(\r\n    {\r\n      success: true,\r\n      data\r\n    },\r\n    {\r\n      headers: options.headers || {}\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Cấu hình cache cho response\r\n */\r\nexport const dynamic = 'force-dynamic'; // Opt out of static rendering\r\nexport const revalidate = 3600; // Revalidate every hour\r\n\r\n/**\r\n * Response data types that match the frontend expectations\r\n */\r\ninterface OverallScoreStats {\r\n  averageScore: number;\r\n  previousAverageScore: number | null;\r\n  improvement: number | null;\r\n  totalAssessments: number;\r\n  currentPeriodLabel: string;\r\n  previousPeriodLabel: string | null;\r\n}\r\n\r\ninterface TimePointScoreData {\r\n  date: string; // ISO YYYY-MM-DD\r\n  averageScore: number;\r\n  assessmentCount: number;\r\n}\r\n\r\ninterface SubjectScorePerformance {\r\n  subject: string;\r\n  averageScore: number;\r\n  assessmentCount: number;\r\n}\r\n\r\ninterface ScoreAnalyticsData {\r\n  overallStats: OverallScoreStats;\r\n  timeSeriesData: TimePointScoreData[];\r\n  subjectPerformance: SubjectScorePerformance[];\r\n}\r\n\r\n/**\r\n * GET /api/users/me/score-analytics\r\n * \r\n * Fetches score analytics data for the current authenticated student\r\n * Supports filtering by timeFrame (last7days, last30days, last90days, allTime)\r\n * Returns data formatted according to the ScoreAnalyticsData interface\r\n */\r\nexport async function GET(req: NextRequest) {\r\n  try {\r\n    // Parse request URL for query parameters\r\n    const { searchParams } = new URL(req.url);\r\n    const queryParams: ScoreAnalyticsQueryParams = {\r\n      timeFrame: searchParams.get('timeFrame') || 'last30days',\r\n      subject: searchParams.get('subject') || undefined,\r\n      minScore: searchParams.get('minScore') || undefined,\r\n      maxScore: searchParams.get('maxScore') || undefined,\r\n      includePublicQuizzes: searchParams.get('includePublicQuizzes') === 'true',\r\n    };\r\n\r\n    // Get the current session to identify the user\r\n    const session = await getServerSession(authOptions);\r\n\r\n    if (!session?.user?.id) {\r\n      return NextResponse.json(\r\n        { success: false, error: \"Authentication required\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    const userId = session.user.id;\r\n\r\n    // Check if the user has the student role\r\n    const user = await prisma.user.findUnique({\r\n      where: { id: userId },\r\n      select: { role: true }\r\n    });\r\n\r\n    if (user?.role !== \"STUDENT\") {\r\n      return NextResponse.json(\r\n        { success: false, error: \"Only students can access this endpoint\" },\r\n        { status: 403 }\r\n      );\r\n    }\r\n\r\n    // Get date ranges for current and previous periods based on timeFrame\r\n    const { currentStartDate, currentEndDate, previousStartDate, previousEndDate, currentPeriodLabel, previousPeriodLabel } = getDateRanges(queryParams.timeFrame);\r\n    \r\n    // Calculate the appropriate time grouping based on the timeFrame\r\n    const timeGrouping = getTimeGrouping(queryParams.timeFrame);\r\n    \r\n    // Build filters\r\n    const currentPeriodFilter = {\r\n      userId,\r\n      completedAt: { \r\n        not: null,\r\n        gte: currentStartDate,\r\n        lte: currentEndDate\r\n      }\r\n    };\r\n    \r\n    const previousPeriodFilter = {\r\n      userId,\r\n      completedAt: { \r\n        not: null,\r\n        gte: previousStartDate,\r\n        lte: previousEndDate\r\n      }\r\n    };\r\n    \r\n    // Add score filter if provided\r\n    let scoreFilter = {};\r\n    if (queryParams.minScore || queryParams.maxScore) {\r\n      scoreFilter = {\r\n        score: {\r\n          ...(queryParams.minScore && { gte: parseFloat(queryParams.minScore) }),\r\n          ...(queryParams.maxScore && { lte: parseFloat(queryParams.maxScore) }),\r\n        }\r\n      };\r\n    }\r\n    \r\n    // Build category filter if provided\r\n    let categoryFilter = {};\r\n    if (queryParams.subject) {\r\n      categoryFilter = {\r\n        quiz: {\r\n          category: { equals: queryParams.subject }\r\n        }\r\n      };\r\n    }\r\n    \r\n    // Combine all filters\r\n    const currentPeriodWhereClause = {\r\n      ...currentPeriodFilter,\r\n      ...scoreFilter,\r\n      ...categoryFilter\r\n    };\r\n    \r\n    const previousPeriodWhereClause = {\r\n      ...previousPeriodFilter,\r\n      ...scoreFilter,\r\n      ...categoryFilter\r\n    };\r\n    \r\n    // 1. Fetch ALL completed attempts within current period for accurate analytics\r\n    // (not limited by pagination, we need all data for proper calculations)\r\n    const currentPeriodAttempts = await prisma.quizAttempt.findMany({\r\n      where: currentPeriodWhereClause,\r\n      include: {\r\n        quiz: {\r\n          select: {\r\n            title: true,\r\n            category: true,\r\n            isPublic: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: { completedAt: 'desc' },\r\n    }) as (QuizAttemptWithQuiz & { quiz: { isPublic?: boolean } })[];\r\n    \r\n    // Filter attempts based on quiz visibility setting (include or exclude public quizzes)\r\n    const filteredAttempts = queryParams.includePublicQuizzes\r\n      ? currentPeriodAttempts\r\n      : currentPeriodAttempts.filter(attempt => !attempt.quiz?.isPublic);\r\n\r\n    // Debug logging for development\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log(`[Score Analytics API] User: ${userId}`);\r\n      console.log(`[Score Analytics API] Time frame: ${queryParams.timeFrame}`);\r\n      console.log(`[Score Analytics API] Include public quizzes: ${queryParams.includePublicQuizzes}`);\r\n      console.log(`[Score Analytics API] Total attempts found: ${currentPeriodAttempts.length}`);\r\n      console.log(`[Score Analytics API] Filtered attempts: ${filteredAttempts.length}`);\r\n      console.log(`[Score Analytics API] Public quiz attempts filtered out: ${currentPeriodAttempts.length - filteredAttempts.length}`);\r\n    }\r\n\r\n    if (!filteredAttempts.length) {\r\n      console.log(`[Score Analytics API] No data found for user ${userId} in timeframe ${queryParams.timeFrame}`);\r\n      return NextResponse.json(\r\n        {\r\n          success: true,\r\n          data: {\r\n            overallStats: {\r\n              averageScore: 0,\r\n              previousAverageScore: null,\r\n              improvement: null,\r\n              totalAssessments: 0,\r\n              currentPeriodLabel,\r\n              previousPeriodLabel\r\n            },\r\n            timeSeriesData: [],\r\n            subjectPerformance: []\r\n          }\r\n        },\r\n        {\r\n        headers: {\r\n          'Cache-Control': 'max-age=3600, s-maxage=3600'\r\n          }\r\n        }\r\n      );\r\n    }\r\n\r\n    // 2. Calculate overall stats\r\n    const overallStats = await calculateOverallStats(\r\n      userId, \r\n      currentStartDate, currentEndDate, \r\n      previousStartDate, previousEndDate,\r\n      currentPeriodLabel, previousPeriodLabel,\r\n      currentPeriodWhereClause, previousPeriodWhereClause\r\n    );\r\n    \r\n    // 3. Generate time series data\r\n    const timeSeriesData = generateTimeSeriesData(filteredAttempts, timeGrouping, currentStartDate, currentEndDate);\r\n    \r\n    // 4. Calculate subject performance\r\n    const subjectPerformance = calculateSubjectPerformance(filteredAttempts);\r\n    \r\n    // 5. Combine all data into the final response\r\n    const analyticsData: ScoreAnalyticsData = {\r\n      overallStats,\r\n      timeSeriesData,\r\n      subjectPerformance,\r\n    };\r\n\r\n    // Debug logging for successful response\r\n    if (process.env.NODE_ENV === 'development') {\r\n      console.log(`[Score Analytics API] Successful response for user ${userId}:`);\r\n      console.log(`[Score Analytics API] - Average score: ${overallStats.averageScore}`);\r\n      console.log(`[Score Analytics API] - Total assessments: ${overallStats.totalAssessments}`);\r\n      console.log(`[Score Analytics API] - Time series data points: ${timeSeriesData.length}`);\r\n      console.log(`[Score Analytics API] - Subject performance entries: ${subjectPerformance.length}`);\r\n    }\r\n\r\n    // Return the data with appropriate cache headers\r\n    return createApiResponse(analyticsData, {\r\n      headers: {\r\n        'Cache-Control': 'max-age=3600, s-maxage=3600'\r\n      }\r\n    });\r\n    \r\n  } catch (err) {\r\n    console.error(\"Error fetching score analytics:\", err);\r\n    return NextResponse.json(\r\n      { success: false, error: \"Failed to fetch score analytics data\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate overall statistics for both current and previous periods\r\n * Uses best attempt per quiz to avoid inflated counts from practice attempts\r\n */\r\nasync function calculateOverallStats(\r\n  userId: string,\r\n  currentStartDate: Date,\r\n  currentEndDate: Date,\r\n  previousStartDate: Date,\r\n  previousEndDate: Date,\r\n  currentPeriodLabel: string,\r\n  previousPeriodLabel: string | null,\r\n  currentPeriodWhereClause: any,\r\n  previousPeriodWhereClause: any\r\n): Promise<OverallScoreStats> {\r\n  // Get current period attempts with quiz info\r\n  const currentPeriodAttempts = await prisma.quizAttempt.findMany({\r\n    where: currentPeriodWhereClause,\r\n    select: {\r\n      score: true,\r\n      quizId: true,\r\n    },\r\n  });\r\n\r\n  // Group by quiz and get best score for each unique quiz\r\n  const quizBestScores = new Map<string, number>();\r\n\r\n  currentPeriodAttempts.forEach(attempt => {\r\n    if (attempt.score !== null) {\r\n      const currentBest = quizBestScores.get(attempt.quizId) || 0;\r\n      if (attempt.score > currentBest) {\r\n        quizBestScores.set(attempt.quizId, attempt.score);\r\n      }\r\n    }\r\n  });\r\n\r\n  const currentPeriodScores = Array.from(quizBestScores.values());\r\n\r\n  const averageScore = currentPeriodScores.length > 0\r\n    ? currentPeriodScores.reduce((sum, score) => sum + score, 0) / currentPeriodScores.length\r\n    : 0;\r\n\r\n  // Count unique quizzes, not total attempts\r\n  const totalAssessments = quizBestScores.size;\r\n  \r\n  // Get previous period stats (if applicable)\r\n  let previousAverageScore: number | null = null;\r\n  let improvement: number | null = null;\r\n\r\n  if (previousStartDate && previousEndDate) {\r\n    const previousPeriodAttempts = await prisma.quizAttempt.findMany({\r\n      where: previousPeriodWhereClause,\r\n      select: {\r\n        score: true,\r\n        quizId: true,\r\n      },\r\n    });\r\n\r\n    // Group by quiz and get best score for each unique quiz in previous period\r\n    const previousQuizBestScores = new Map<string, number>();\r\n\r\n    previousPeriodAttempts.forEach(attempt => {\r\n      if (attempt.score !== null) {\r\n        const currentBest = previousQuizBestScores.get(attempt.quizId) || 0;\r\n        if (attempt.score > currentBest) {\r\n          previousQuizBestScores.set(attempt.quizId, attempt.score);\r\n        }\r\n      }\r\n    });\r\n\r\n    const previousPeriodScores = Array.from(previousQuizBestScores.values());\r\n\r\n    previousAverageScore = previousPeriodScores.length > 0\r\n      ? previousPeriodScores.reduce((sum, score) => sum + score, 0) / previousPeriodScores.length\r\n      : null;\r\n\r\n    // Calculate improvement percentage if we have both scores\r\n    if (previousAverageScore !== null && previousAverageScore > 0) {\r\n      improvement = ((averageScore - previousAverageScore) / previousAverageScore) * 100;\r\n    }\r\n  }\r\n  \r\n  return {\r\n    averageScore,\r\n    previousAverageScore,\r\n    improvement,\r\n    totalAssessments,\r\n    currentPeriodLabel,\r\n    previousPeriodLabel,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate time series data with appropriate granularity based on selected timeFrame\r\n * Uses best attempt per quiz per time period to avoid inflated counts\r\n */\r\nfunction generateTimeSeriesData(\r\n  attempts: QuizAttemptWithQuiz[],\r\n  grouping: 'day' | 'week' | 'month',\r\n  startDate: Date,\r\n  endDate: Date\r\n): TimePointScoreData[] {\r\n  // Group attempts by the specified time unit and quiz\r\n  const groupedAttempts = new Map<string, Map<string, { bestScore: number, hasAttempt: boolean }>>();\r\n\r\n  // Generate all time points in the range (even with no data)\r\n  const allTimePoints: string[] = [];\r\n  let currentDate = new Date(startDate);\r\n\r\n  while (isBefore(currentDate, endDate) || format(currentDate, 'yyyy-MM-dd') === format(endDate, 'yyyy-MM-dd')) {\r\n    let timePoint: string;\r\n\r\n    if (grouping === 'day') {\r\n      timePoint = format(currentDate, 'yyyy-MM-dd');\r\n      currentDate = addDays(currentDate, 1);\r\n    } else if (grouping === 'week') {\r\n      const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 }); // Monday as week start\r\n      timePoint = format(weekStart, 'yyyy-MM-dd');\r\n      currentDate = addDays(currentDate, 7);\r\n    } else { // month\r\n      const monthStart = startOfMonth(currentDate);\r\n      timePoint = format(monthStart, 'yyyy-MM');\r\n      currentDate = addDays(endOfMonth(currentDate), 1);\r\n    }\r\n\r\n    if (!groupedAttempts.has(timePoint)) {\r\n      groupedAttempts.set(timePoint, new Map());\r\n    }\r\n\r\n    allTimePoints.push(timePoint);\r\n  }\r\n\r\n  // Process attempts into the grouped structure, tracking best score per quiz per time period\r\n  for (const attempt of attempts) {\r\n    if (!attempt.completedAt || !attempt.score) continue;\r\n\r\n    const attemptDate = new Date(attempt.completedAt);\r\n    let timePoint: string;\r\n\r\n    if (grouping === 'day') {\r\n      timePoint = format(attemptDate, 'yyyy-MM-dd');\r\n    } else if (grouping === 'week') {\r\n      const weekStart = startOfWeek(attemptDate, { weekStartsOn: 1 }); // Monday as week start\r\n      timePoint = format(weekStart, 'yyyy-MM-dd');\r\n    } else { // month\r\n      timePoint = format(attemptDate, 'yyyy-MM');\r\n    }\r\n\r\n    if (!groupedAttempts.has(timePoint)) {\r\n      groupedAttempts.set(timePoint, new Map());\r\n    }\r\n\r\n    const timeGroup = groupedAttempts.get(timePoint)!;\r\n    const quizId = attempt.quizId;\r\n\r\n    if (!timeGroup.has(quizId)) {\r\n      timeGroup.set(quizId, { bestScore: attempt.score, hasAttempt: true });\r\n    } else {\r\n      const existing = timeGroup.get(quizId)!;\r\n      if (attempt.score > existing.bestScore) {\r\n        existing.bestScore = attempt.score;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Convert the grouped data to the expected output format\r\n  const result: TimePointScoreData[] = allTimePoints\r\n    .filter((timePoint, index, self) => self.indexOf(timePoint) === index) // Remove duplicates\r\n    .map(timePoint => {\r\n      const timeGroup = groupedAttempts.get(timePoint)!;\r\n      const quizScores = Array.from(timeGroup.values()).map(quiz => quiz.bestScore);\r\n\r\n      const averageScore = quizScores.length > 0\r\n        ? quizScores.reduce((sum, score) => sum + score, 0) / quizScores.length\r\n        : 0;\r\n\r\n      return {\r\n        date: timePoint,\r\n        averageScore,\r\n        assessmentCount: quizScores.length, // Count unique quizzes, not total attempts\r\n      };\r\n    })\r\n    .sort((a, b) => a.date.localeCompare(b.date)); // Ensure chronological order\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Calculate performance metrics by subject (category)\r\n * Uses best attempt per quiz to avoid inflated counts from practice attempts\r\n */\r\nfunction calculateSubjectPerformance(attempts: QuizAttemptWithQuiz[]): SubjectScorePerformance[] {\r\n  // Group attempts by subject and quiz, tracking best score per quiz\r\n  const subjectMap = new Map<string, Map<string, number>>();\r\n\r\n  for (const attempt of attempts) {\r\n    if (!attempt.score) continue;\r\n\r\n    const subject = attempt.quiz?.category || \"Unknown\";\r\n    const quizId = attempt.quizId;\r\n\r\n    if (!subjectMap.has(subject)) {\r\n      subjectMap.set(subject, new Map());\r\n    }\r\n\r\n    const subjectQuizzes = subjectMap.get(subject)!;\r\n\r\n    if (!subjectQuizzes.has(quizId)) {\r\n      subjectQuizzes.set(quizId, attempt.score);\r\n    } else {\r\n      const currentBest = subjectQuizzes.get(quizId)!;\r\n      if (attempt.score > currentBest) {\r\n        subjectQuizzes.set(quizId, attempt.score);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Convert the grouped data to the expected output format\r\n  const result: SubjectScorePerformance[] = Array.from(subjectMap.entries())\r\n    .map(([subject, quizScores]) => {\r\n      const scores = Array.from(quizScores.values());\r\n      const averageScore = scores.length > 0\r\n        ? scores.reduce((sum, score) => sum + score, 0) / scores.length\r\n        : 0;\r\n\r\n      return {\r\n        subject,\r\n        averageScore,\r\n        assessmentCount: scores.length, // Count unique quizzes, not total attempts\r\n      };\r\n    })\r\n    .sort((a, b) => b.averageScore - a.averageScore); // Sort by score (highest first)\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Determine the appropriate time grouping based on the timeFrame\r\n */\r\nfunction getTimeGrouping(timeFrame?: string): 'day' | 'week' | 'month' {\r\n  switch (timeFrame) {\r\n    case 'last7days':\r\n    case 'last30days':\r\n      return 'day';\r\n    case 'last90days':\r\n      return 'week';\r\n    case 'last6months':\r\n    case 'lastYear':\r\n    case 'allTime':\r\n    default:\r\n      return 'month';\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate date ranges based on timeFrame\r\n */\r\nfunction getDateRanges(timeFrame?: string) {\r\n  const now = new Date();\r\n  let currentStartDate: Date;\r\n  let currentEndDate: Date = now;\r\n  let previousStartDate: Date;\r\n  let previousEndDate: Date;\r\n  let currentPeriodLabel: string;\r\n  let previousPeriodLabel: string | null = null;\r\n  \r\n  switch (timeFrame) {\r\n    case 'last7days':\r\n      currentStartDate = subDays(now, 7);\r\n      previousStartDate = subDays(currentStartDate, 7);\r\n      previousEndDate = subDays(now, 8);\r\n      currentPeriodLabel = 'Last 7 Days';\r\n      previousPeriodLabel = 'Previous 7 Days';\r\n      break;\r\n    case 'last30days':\r\n      currentStartDate = subDays(now, 30);\r\n      previousStartDate = subDays(currentStartDate, 30);\r\n      previousEndDate = subDays(now, 31);\r\n      currentPeriodLabel = 'Last 30 Days';\r\n      previousPeriodLabel = 'Previous 30 Days';\r\n      break;\r\n    case 'last90days':\r\n      currentStartDate = subDays(now, 90);\r\n      previousStartDate = subDays(currentStartDate, 90);\r\n      previousEndDate = subDays(now, 91);\r\n      currentPeriodLabel = 'Last 3 Months';\r\n      previousPeriodLabel = 'Previous 3 Months';\r\n      break;\r\n    case 'last6months':\r\n      currentStartDate = subMonths(now, 6);\r\n      previousStartDate = subMonths(currentStartDate, 6);\r\n      previousEndDate = subDays(currentStartDate, 1);\r\n      currentPeriodLabel = 'Last 6 Months';\r\n      previousPeriodLabel = 'Previous 6 Months';\r\n      break;\r\n    case 'lastYear':\r\n      currentStartDate = subMonths(now, 12);\r\n      previousStartDate = subMonths(currentStartDate, 12);\r\n      previousEndDate = subDays(currentStartDate, 1);\r\n      currentPeriodLabel = 'Last Year';\r\n      previousPeriodLabel = 'Previous Year';\r\n      break;\r\n    case 'allTime':\r\n      currentStartDate = subMonths(now, 24); // Show up to 2 years of data\r\n      previousStartDate = new Date(0); // Use epoch time instead of null\r\n      previousEndDate = new Date(0); // Use epoch time instead of null\r\n      currentPeriodLabel = 'All Time';\r\n      previousPeriodLabel = null;\r\n      break;\r\n    default:\r\n      // Default to last 30 days\r\n      currentStartDate = subDays(now, 30);\r\n      previousStartDate = subDays(currentStartDate, 30);\r\n      previousEndDate = subDays(currentStartDate, 1);\r\n      currentPeriodLabel = 'Last 30 Days';\r\n      previousPeriodLabel = 'Previous 30 Days';\r\n  }\r\n  \r\n  return {\r\n    currentStartDate,\r\n    currentEndDate,\r\n    previousStartDate,\r\n    previousEndDate,\r\n    currentPeriodLabel,\r\n    previousPeriodLabel\r\n  };\r\n} "],"names":[],"mappings":"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","debugId":null}}]
}
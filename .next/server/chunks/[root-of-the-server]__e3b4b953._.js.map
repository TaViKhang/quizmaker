{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\ndeclare global {\r\n  var prisma: PrismaClient | undefined;\r\n}\r\n\r\nexport const db = globalThis.prisma || new PrismaClient();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalThis.prisma = db;\r\n"],"names":[],"mappings":";;;AAAA;;AAMO,MAAM,KAAK,WAAW,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY;AAEvD,wCAA2C,WAAW,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from \"next-auth\"\r\nimport { PrismaAdapter } from \"@auth/prisma-adapter\"\r\nimport { db } from \"@/lib/db\"\r\nimport GoogleProvider from \"next-auth/providers/google\"\r\nimport { ROLES, RoleType } from \"@/lib/constants\"\r\n\r\n// Domain email được ủy quyền cao hơn\r\nconst AUTHORIZED_TEACHER_DOMAINS = ['school.edu', 'university.edu', 'teacher.org']\r\n\r\n// Fix cho type adapter\r\nconst prismaAdapter = PrismaAdapter(db) as any\r\n\r\n// Cải thiện error handling\r\nconst handleAuthError = (error: any, context: string) => {\r\n  console.error(`[Auth Error] ${context}:`, error);\r\n  return false;\r\n}\r\n\r\nexport const authOptions: AuthOptions = {\r\n  adapter: prismaAdapter,\r\n  providers: [\r\n    GoogleProvider({\r\n      clientId: process.env.GOOGLE_CLIENT_ID!,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\r\n      allowDangerousEmailAccountLinking: true,\r\n    }),\r\n  ],\r\n  session: {\r\n    strategy: \"jwt\",\r\n    maxAge: 24 * 60 * 60, // 24 hours\r\n    updateAge: 4 * 60 * 60, // 4 hours\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user, account, profile, trigger }) {\r\n      try {\r\n        // Trường hợp đăng nhập - Chỉ cập nhật token khi có user từ đăng nhập\r\n        if (user) {\r\n          // Đảm bảo role có thể null\r\n          token.role = user.role as RoleType | null;\r\n          token.id = user.id;\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp trigger update - Cập nhật token khi có sự thay đổi rõ ràng\r\n        if (trigger === 'update' && token?.sub) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { \r\n                id: true, \r\n                name: true, \r\n                email: true, \r\n                role: true, \r\n                image: true \r\n              }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              // Cập nhật token với giá trị mới\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.name = dbUser.name;\r\n              token.email = dbUser.email;\r\n              token.picture = dbUser.image;\r\n              \r\n              // Thêm timestamp để đảm bảo không cache token cũ\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error updating token:\", error);\r\n          }\r\n          return token;\r\n        }\r\n        \r\n        // Trường hợp token từ session: kiểm tra nếu cần cập nhật\r\n        if (token?.sub && (!token.role || !token.updatedAt || Date.now() - (token.updatedAt as number || 0) > 60 * 1000)) {\r\n          try {\r\n            const dbUser = await db.user.findUnique({\r\n              where: { id: token.sub },\r\n              select: { role: true }\r\n            });\r\n            \r\n            if (dbUser) {\r\n              token.role = dbUser.role as RoleType | null;\r\n              token.updatedAt = Date.now();\r\n            }\r\n          } catch (error) {\r\n            console.error(\"Error refreshing token:\", error);\r\n          }\r\n        }\r\n        \r\n        return token;\r\n      } catch (error) {\r\n        console.error(\"JWT callback error:\", error);\r\n        return token;\r\n      }\r\n    },\r\n    async session({ session, token }) {\r\n      try {\r\n        if (session.user && token) {\r\n          // Đảm bảo role có thể null\r\n          session.user.role = token.role as RoleType | null;\r\n          session.user.id = token.id as string;\r\n        }\r\n        return session;\r\n      } catch (error) {\r\n        console.error(\"Session callback error:\", error);\r\n        return session;\r\n      }\r\n    },\r\n    async signIn({ user, account, profile }) {\r\n      // Nếu user có email\r\n      if (user?.email) {\r\n        try {\r\n          // Kiểm tra user đã tồn tại chưa\r\n          const existingUser = await db.user.findUnique({\r\n            where: { email: user.email },\r\n          })\r\n          \r\n          if (!existingUser) {\r\n            // Tạo user mới không có role (null) để người dùng chọn sau\r\n            await db.user.create({\r\n              data: {\r\n                id: user.id,\r\n                email: user.email,\r\n                name: user.name,\r\n                image: user.image,\r\n                role: null, // Không thiết lập role mặc định\r\n              },\r\n            })\r\n            \r\n            // Đánh dấu để redirect tới trang chọn role\r\n            return true\r\n          }\r\n          \r\n          return true\r\n        } catch (error) {\r\n          return handleAuthError(error, \"signIn callback\");\r\n        }\r\n      }\r\n      \r\n      return true\r\n    }\r\n  },\r\n  pages: {\r\n    signIn: '/auth/signin',\r\n    signOut: '/',\r\n    error: '/auth/error',\r\n    newUser: '/auth/select-role' // Điều hướng người dùng mới đến trang chọn role\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n  debug: process.env.NODE_ENV === \"development\",\r\n  logger: {\r\n    error(code, ...message) {\r\n      console.error(`[NextAuth Error] ${code}:`, ...message);\r\n    },\r\n    warn(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.warn(`[NextAuth Warning] ${code}:`, ...message);\r\n      }\r\n    },\r\n    debug(code, ...message) {\r\n      if (process.env.NODE_ENV === \"development\") {\r\n        console.debug(`[NextAuth Debug] ${code}:`, ...message);\r\n      }\r\n    },\r\n  },\r\n}\r\n\r\nconst handler = NextAuth(authOptions)\r\nexport { handler as GET, handler as POST }\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/utils/api-types.ts"],"sourcesContent":["/**\r\n * HTTP Status Codes\r\n */\r\nexport const HTTP_STATUS = {\r\n  OK: 200,\r\n  CREATED: 201,\r\n  BAD_REQUEST: 400,\r\n  UNAUTHORIZED: 401,\r\n  FORBIDDEN: 403,\r\n  NOT_FOUND: 404,\r\n  METHOD_NOT_ALLOWED: 405,\r\n  CONFLICT: 409,\r\n  INTERNAL_SERVER_ERROR: 500,\r\n} as const;\r\n\r\n/**\r\n * API Response Types\r\n */\r\nexport type ErrorResponseOptions = {\r\n  status?: number;\r\n  code?: string;\r\n  details?: Record<string, any>;\r\n};\r\n\r\nexport type SuccessResponseOptions = {\r\n  status?: number;\r\n  pagination?: {\r\n    total: number;\r\n    page: number;\r\n    limit: number;\r\n  };\r\n  cacheControl?: string;\r\n};\r\n\r\n/**\r\n * API Error Codes\r\n */\r\nexport const API_ERROR_CODES = {\r\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\r\n  NOT_FOUND: 'NOT_FOUND',\r\n  UNAUTHORIZED: 'UNAUTHORIZED',\r\n  FORBIDDEN: 'FORBIDDEN',\r\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\r\n} as const;\r\n\r\n/**\r\n * API Response Messages\r\n */\r\nexport const API_MESSAGES = {\r\n  NOT_FOUND: {\r\n    QUESTION: 'Question not found',\r\n    OPTION: 'Option not found',\r\n    QUIZ: 'Quiz not found',\r\n    USER: 'User not found',\r\n    ATTEMPT: 'Attempt not found',\r\n    ANSWER: 'Answer not found',\r\n  },\r\n  UNAUTHORIZED: 'Unauthorized access',\r\n  FORBIDDEN: 'Access forbidden',\r\n  INTERNAL_ERROR: 'Internal server error',\r\n  VALIDATION_ERROR: 'Validation error',\r\n  ATTEMPT: {\r\n    CREATED: 'Attempt created successfully',\r\n    UPDATED: 'Attempt updated successfully',\r\n    COMPLETED: 'Attempt completed successfully',\r\n    DELETED: 'Attempt deleted successfully',\r\n    MAX_ATTEMPTS_REACHED: 'Maximum attempts reached for this quiz',\r\n    ALREADY_COMPLETED: 'This attempt is already completed',\r\n    QUIZ_CLOSED: 'This quiz is no longer accepting submissions',\r\n    INVALID_ANSWER: 'Invalid answer format',\r\n    PARTIAL_SCORE: 'Some questions require manual grading',\r\n  },\r\n  ANALYTICS: {\r\n    FORBIDDEN: 'You do not have permission to view this data',\r\n    STUDENT_RESTRICTED: 'This data is only available to teachers',\r\n  }\r\n} as const; "],"names":[],"mappings":"AAAA;;CAEC;;;;;AACM,MAAM,cAAc;IACzB,IAAI;IACJ,SAAS;IACT,aAAa;IACb,cAAc;IACd,WAAW;IACX,WAAW;IACX,oBAAoB;IACpB,UAAU;IACV,uBAAuB;AACzB;AAwBO,MAAM,kBAAkB;IAC7B,kBAAkB;IAClB,WAAW;IACX,cAAc;IACd,WAAW;IACX,gBAAgB;AAClB;AAKO,MAAM,eAAe;IAC1B,WAAW;QACT,UAAU;QACV,QAAQ;QACR,MAAM;QACN,MAAM;QACN,SAAS;QACT,QAAQ;IACV;IACA,cAAc;IACd,WAAW;IACX,gBAAgB;IAChB,kBAAkB;IAClB,SAAS;QACP,SAAS;QACT,SAAS;QACT,WAAW;QACX,SAAS;QACT,sBAAsB;QACtB,mBAAmB;QACnB,aAAa;QACb,gBAAgB;QAChB,eAAe;IACjB;IACA,WAAW;QACT,WAAW;QACX,oBAAoB;IACtB;AACF","debugId":null}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/utils/api-response.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { \r\n  ErrorResponseOptions, \r\n  SuccessResponseOptions,\r\n  HTTP_STATUS,\r\n  API_ERROR_CODES,\r\n  API_MESSAGES\r\n} from \"./api-types\";\r\n\r\n/**\r\n * Class representing an API error\r\n */\r\nexport class ApiError extends Error {\r\n  statusCode: number;\r\n  code: string;\r\n  details?: any;\r\n\r\n  constructor(statusCode: number, message: string, code?: string, details?: any) {\r\n    super(message);\r\n    this.statusCode = statusCode;\r\n    this.code = code || API_ERROR_CODES.INTERNAL_ERROR;\r\n    this.details = details;\r\n    this.name = 'ApiError';\r\n  }\r\n}\r\n\r\n/**\r\n * Standard API response structure\r\n */\r\nexport interface ApiResponse<T = any> {\r\n  success: boolean;\r\n  data?: T;\r\n  error?: {\r\n    code: string;\r\n    message: string;\r\n    details?: any;\r\n  };\r\n  meta?: {\r\n    page?: number;\r\n    limit?: number;\r\n    total?: number;\r\n    totalPages?: number;\r\n  };\r\n}\r\n\r\n/**\r\n * Create a standard API response\r\n */\r\nexport function createApiResponse<T>(data: T, options?: SuccessResponseOptions) {\r\n  return NextResponse.json({\r\n    success: true,\r\n    data,\r\n    ...(options?.pagination && { meta: options.pagination }),\r\n  }, \r\n  { \r\n    status: options?.status || HTTP_STATUS.OK,\r\n    headers: options?.cacheControl ? { 'Cache-Control': options.cacheControl } : undefined\r\n  });\r\n}\r\n\r\n/**\r\n * Create a success response\r\n */\r\nexport function successResponse<T>(\r\n  data: T,\r\n  options?: SuccessResponseOptions\r\n) {\r\n  const response = NextResponse.json(\r\n    {\r\n      success: true,\r\n      data,\r\n      ...(options?.pagination && { pagination: options.pagination }),\r\n    },\r\n    { status: options?.status || HTTP_STATUS.OK }\r\n  );\r\n\r\n  // Set cache headers if provided\r\n  if (options?.cacheControl) {\r\n    response.headers.set(\"Cache-Control\", options.cacheControl);\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\n/**\r\n * Create an error response\r\n */\r\nexport function errorResponse(\r\n  message: string,\r\n  options?: ErrorResponseOptions\r\n) {\r\n  return NextResponse.json(\r\n    {\r\n      success: false,\r\n      error: {\r\n        message,\r\n        code: options?.code || API_ERROR_CODES.INTERNAL_ERROR,\r\n        ...(options?.details && { details: options.details }),\r\n      },\r\n    },\r\n    { status: options?.status || HTTP_STATUS.INTERNAL_SERVER_ERROR }\r\n  );\r\n}\r\n\r\n/**\r\n * Create an unauthorized response\r\n */\r\nexport function unauthorizedResponse() {\r\n  return errorResponse(API_MESSAGES.UNAUTHORIZED, {\r\n    status: HTTP_STATUS.UNAUTHORIZED,\r\n    code: API_ERROR_CODES.UNAUTHORIZED,\r\n  });\r\n}\r\n\r\n/**\r\n * Create a forbidden response\r\n */\r\nexport function forbiddenResponse() {\r\n  return errorResponse(API_MESSAGES.FORBIDDEN, {\r\n    status: HTTP_STATUS.FORBIDDEN,\r\n    code: API_ERROR_CODES.FORBIDDEN,\r\n  });\r\n}\r\n\r\n/**\r\n * Create a not found response\r\n */\r\nexport function notFoundResponse(message: string) {\r\n  return errorResponse(message, {\r\n    status: HTTP_STATUS.NOT_FOUND,\r\n    code: API_ERROR_CODES.NOT_FOUND,\r\n  });\r\n}\r\n\r\n/**\r\n * Create a validation error response\r\n */\r\nexport function validationErrorResponse(details: Record<string, any>) {\r\n  return errorResponse(API_MESSAGES.VALIDATION_ERROR, {\r\n    status: HTTP_STATUS.BAD_REQUEST,\r\n    code: API_ERROR_CODES.VALIDATION_ERROR,\r\n    details,\r\n  });\r\n}\r\n\r\n/**\r\n * Handle Zod validation errors\r\n */\r\nexport function handleZodError(error: any) {\r\n  const details = error.errors.reduce((acc: Record<string, any>, err: any) => {\r\n    const path = err.path.join('.');\r\n    acc[path] = err.message;\r\n    return acc;\r\n  }, {});\r\n\r\n  return validationErrorResponse(details);\r\n}\r\n\r\n/**\r\n * Create a server error response\r\n */\r\nexport function serverErrorResponse(message: string = API_MESSAGES.INTERNAL_ERROR) {\r\n  return errorResponse(message, {\r\n    status: HTTP_STATUS.INTERNAL_SERVER_ERROR,\r\n    code: API_ERROR_CODES.INTERNAL_ERROR,\r\n  });\r\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///F:/Github%20Project/quizmaker/my-project/app/api/users/me/dashboard-summary/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { getServerSession } from \"next-auth\";\r\nimport { authOptions } from \"@/app/api/auth/[...nextauth]/route\";\r\nimport { db } from \"@/lib/db\";\r\nimport { Role } from \"@prisma/client\";\r\nimport { ApiError, createApiResponse } from \"@/app/api/utils/api-response\";\r\n\r\n/**\r\n * API endpoint to get student dashboard summary statistics.\r\n * This includes:\r\n * - classesJoined: Number of active classes the student has joined.\r\n * - totalQuizzesCompleted: Total number of quizzes completed (private quizzes only).\r\n * - averageScore: Average score across all assigned quizzes (using highest score if multiple attempts).\r\n * - assignedQuizCompletionRate: Completion rate for assigned quizzes.\r\n * - assignedAverageScorePreviousPeriod: Average score from assigned quizzes completed in the previous month.\r\n * - assignedPublishedQuizzesCurrentMonthCount: Total number of assigned quizzes published in joined classes within the current month.\r\n * - assignedCompletedQuizzesCurrentMonthCount: Total number of assigned quizzes completed within the current month.\r\n * \r\n * @route GET /api/users/me/dashboard-summary\r\n * @returns {{\r\n *   classesJoined: number,\r\n *   totalQuizzesCompleted: number,\r\n *   averageScore: number,\r\n *   assignedQuizCompletionRate: number,\r\n *   assignedAverageScorePreviousPeriod: number,\r\n *   assignedPublishedQuizzesCurrentMonthCount: number,\r\n *   assignedCompletedQuizzesCurrentMonthCount: number\r\n * }}\r\n */\r\nexport async function GET() {\r\n  try {\r\n    // Verify user authentication\r\n    const session = await getServerSession(authOptions);\r\n    if (!session?.user) {\r\n      throw new ApiError(401, \"Authentication required\");\r\n    }\r\n\r\n    // Only students can access this API\r\n    if (session.user.role !== Role.STUDENT) {\r\n      throw new ApiError(403, \"Access denied: Student role required\");\r\n    }\r\n\r\n    const userId = session.user.id;\r\n    const now = new Date();\r\n    const previousMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);\r\n    const currentMonth = new Date(now.getFullYear(), now.getMonth(), 1);\r\n    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Last day of current month\r\n\r\n    // 1. Classes Joined - Count all active classes the student is enrolled in\r\n    const classesJoined = await db.classEnrollment.count({\r\n      where: {\r\n        studentId: userId,\r\n        class: {\r\n          isActive: true\r\n        }\r\n      },\r\n    });\r\n    \r\n    // 2. Get list of enrolled class IDs (for use in subsequent queries)\r\n    const enrolledClasses = await db.classEnrollment.findMany({\r\n      where: {\r\n        studentId: userId,\r\n        class: {\r\n          isActive: true\r\n        }\r\n      },\r\n      select: {\r\n        classId: true\r\n      }\r\n    });\r\n    \r\n    const enrolledClassIds = enrolledClasses.map(ec => ec.classId);\r\n    \r\n    // 3. Total Assigned Quizzes - Count all published and active quizzes in enrolled classes\r\n    let assignedPublishedQuizzesCount = 0;\r\n    if (enrolledClassIds.length > 0) {\r\n      assignedPublishedQuizzesCount = await db.quiz.count({\r\n        where: {\r\n          classId: {\r\n            in: enrolledClassIds\r\n          },\r\n          isPublished: true,\r\n          isActive: true\r\n        }\r\n      });\r\n    }\r\n      // 4. Completed Quizzes - Count UNIQUE quizzes in enrolled classes that the student has completed\r\n    const completedQuizAttempts = await db.quizAttempt.findMany({\r\n      where: {\r\n        userId: userId,\r\n        completedAt: {\r\n          not: null\r\n        },\r\n        quiz: {\r\n          classId: {\r\n            in: enrolledClassIds\r\n          },\r\n          isPublished: true\r\n        }\r\n      },\r\n      select: {\r\n        quizId: true\r\n      },\r\n      distinct: ['quizId']\r\n    });\r\n    \r\n    const totalQuizzesCompleted = completedQuizAttempts.length;\r\n    \r\n    // 5. Assigned Quiz Completion Rate calculation\r\n    let assignedQuizCompletionRate = 0;\r\n    if (assignedPublishedQuizzesCount > 0) {\r\n      assignedQuizCompletionRate = (totalQuizzesCompleted / assignedPublishedQuizzesCount) * 100;\r\n    }\r\n    \r\n    // 6. Find assigned quiz IDs for score calculations\r\n    const assignedQuizzes = await db.quiz.findMany({\r\n      where: {\r\n        classId: {\r\n          in: enrolledClassIds\r\n        },\r\n        isPublished: true,\r\n        isActive: true\r\n      },\r\n      select: {\r\n        id: true\r\n      }\r\n    });\r\n    \r\n    const assignedQuizIds = assignedQuizzes.map(quiz => quiz.id);\r\n    \r\n    // 7. Get all completed attempts for these quizzes\r\n    const allAttempts = await db.quizAttempt.findMany({\r\n      where: {\r\n        userId: userId,\r\n        quizId: {\r\n          in: assignedQuizIds\r\n        },\r\n        completedAt: {\r\n          not: null\r\n        },\r\n        score: {\r\n          not: null\r\n        }\r\n      },\r\n      select: {\r\n        quizId: true,\r\n        score: true,\r\n        completedAt: true\r\n      }\r\n    });\r\n    \r\n    // 8. Calculate average score using highest score per quiz\r\n    const bestScoresByQuiz = new Map<string, number>();\r\n    \r\n    allAttempts.forEach(attempt => {\r\n      const currentBestScore = bestScoresByQuiz.get(attempt.quizId) || 0;\r\n      if ((attempt.score || 0) > currentBestScore) {\r\n        bestScoresByQuiz.set(attempt.quizId, attempt.score || 0);\r\n      }\r\n    });\r\n    \r\n    let totalScoreSum = 0;\r\n    let totalScoredQuizzes = 0;\r\n    \r\n    bestScoresByQuiz.forEach(score => {\r\n      totalScoreSum += score;\r\n      totalScoredQuizzes++;\r\n    });\r\n    \r\n    let averageScore = 0;\r\n    if (totalScoredQuizzes > 0) {\r\n      averageScore = totalScoreSum / totalScoredQuizzes;\r\n    }\r\n    \r\n    // 9. Calculate monthly statistics for current month\r\n    // 9.1. Count published quizzes this month\r\n    let assignedPublishedQuizzesCurrentMonthCount = 0;\r\n    if (enrolledClassIds.length > 0) {\r\n      assignedPublishedQuizzesCurrentMonthCount = await db.quiz.count({\r\n        where: {\r\n          classId: {\r\n            in: enrolledClassIds\r\n          },\r\n          isPublished: true,\r\n          isActive: true,\r\n          createdAt: {\r\n            gte: currentMonth\r\n          }\r\n        }\r\n      });\r\n    }\r\n    \r\n    // 9.2. Count unique completed quizzes this month (not total attempts)\r\n    const completedQuizCurrentMonthAttempts = await db.quizAttempt.findMany({\r\n      where: {\r\n        userId: userId,\r\n        completedAt: {\r\n          not: null,\r\n          gte: currentMonth,\r\n          lte: endOfMonth\r\n        },\r\n        quiz: {\r\n          classId: {\r\n            in: enrolledClassIds\r\n          },\r\n          isPublished: true\r\n        }\r\n      },\r\n      select: {\r\n        quizId: true\r\n      }\r\n    });\r\n\r\n    // Count unique quizzes completed this month\r\n    const uniqueCompletedQuizIds = new Set(completedQuizCurrentMonthAttempts.map(attempt => attempt.quizId));\r\n    const assignedCompletedQuizzesCurrentMonthCount = uniqueCompletedQuizIds.size;\r\n    \r\n    // 10. Calculate average score from previous month for comparison\r\n    const previousMonthAttempts = allAttempts.filter(\r\n      attempt => attempt.completedAt && \r\n                new Date(attempt.completedAt) >= previousMonth && \r\n                new Date(attempt.completedAt) < currentMonth\r\n    );\r\n    \r\n    // Group by quiz and find highest score per quiz\r\n    const previousMonthBestScores = new Map<string, number>();\r\n    \r\n    previousMonthAttempts.forEach(attempt => {\r\n      const currentBestScore = previousMonthBestScores.get(attempt.quizId) || 0;\r\n      if ((attempt.score || 0) > currentBestScore) {\r\n        previousMonthBestScores.set(attempt.quizId, attempt.score || 0);\r\n      }\r\n    });\r\n    \r\n    let previousMonthTotalScore = 0;\r\n    let previousMonthQuizCount = 0;\r\n    \r\n    previousMonthBestScores.forEach(score => {\r\n      previousMonthTotalScore += score;\r\n      previousMonthQuizCount++;\r\n    });\r\n    \r\n    let assignedAverageScorePreviousPeriod = 0;\r\n    if (previousMonthQuizCount > 0) {\r\n      assignedAverageScorePreviousPeriod = previousMonthTotalScore / previousMonthQuizCount;\r\n    }\r\n    \r\n    // Return formatted response with all dashboard statistics\r\n    return createApiResponse({\r\n      classesJoined,\r\n      totalQuizzesCompleted,\r\n      averageScore: parseFloat(averageScore.toFixed(1)),\r\n      assignedQuizCompletionRate: parseFloat(assignedQuizCompletionRate.toFixed(1)),\r\n      assignedPublishedQuizzesCurrentMonthCount,\r\n      assignedCompletedQuizzesCurrentMonthCount,\r\n      assignedAverageScorePreviousPeriod: parseFloat(assignedAverageScorePreviousPeriod.toFixed(1))\r\n    });\r\n    \r\n  } catch (error) {\r\n    if (error instanceof ApiError) {\r\n      return NextResponse.json(\r\n        { success: false, error: error.message },\r\n        { status: error.statusCode }\r\n      );\r\n    }\r\n\r\n    console.error(\"Error fetching student dashboard stats:\", error);\r\n    return NextResponse.json(\r\n      { success: false, error: \"Internal server error\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n} "],"names":[],"mappings":"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","debugId":null}}]
}